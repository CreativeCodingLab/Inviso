/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "assets/js";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(1);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi main\n// module id = 0\n// module chunks = 0\n//# sourceURL=webpack:///multi_main?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);\nvar _detector = __webpack_require__(4);var _detector2 = _interopRequireDefault(_detector);\nvar _main = __webpack_require__(5);var _main2 = _interopRequireDefault(_main);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n// Check environment and set the Config helper\nif (true) {\n  console.log('----- RUNNING IN DEV ENVIRONMENT! -----');\n\n  _config2.default.isDev = true;\n}\n\nfunction init() {\n  // Check for webGL capabilities\n  if (!_detector2.default.webgl) {\n    _detector2.default.addGetWebGLMessage();\n  } else {\n    var container = document.getElementById('appContainer');\n    new _main2.default(container);\n  }\n}\n\ninit();\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app.js\n// module id = 1\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app.js?");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _tween = __webpack_require__(3);var _tween2 = _interopRequireDefault(_tween);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n// This object contains the state of the app\nexports.default = {\n  isDev: false,\n  isLoaded: false,\n  isTweening: false,\n  isRotating: true,\n  isMouseMoving: false,\n  isMouseOver: false,\n  maxAnisotropy: 1,\n  dpr: 1,\n  easing: _tween2.default.Easing.Quadratic.InOut,\n  duration: 500,\n  model: {\n    path: './assets/models/head.obj',\n    scale: 30 },\n\n  texture: {\n    path: './assets/textures/',\n    imageFiles: [] },\n\n  mesh: {\n    enableHelper: false,\n    wireframe: true,\n    translucent: false,\n    material: {\n      color: 0xffffff,\n      emissive: 0xffffff } },\n\n\n  fog: {\n    color: 0xffffff,\n    near: 0.0008 },\n\n  grid: {\n    size: 10000,\n    divisions: 80 },\n\n  camera: {\n    fov: 45,\n    near: 100,\n    far: 10000,\n    aspect: 1,\n    posX: 0,\n    posY: 2500,\n    posZ: 0 },\n\n  soundObject: {\n    defaultRadius: 50,\n    defaultTrajectoryClock: 1,\n    defaultMovementSpeed: 5,\n    defaultMovementDirection: 1,\n    defaultPosX: 0,\n    defaultPosY: 0,\n    defaultPosZ: 0 },\n\n  controls: {\n    autoRotate: false,\n    autoRotateSpeed: -0.5,\n    rotateSpeed: 0.5,\n    zoomSpeed: 0.8,\n    minDistance: 200,\n    maxDistance: 5000,\n    minPolarAngle: -Math.PI / 2,\n    maxPolarAngle: Math.PI / 2,\n    minAzimuthAngle: -Infinity,\n    maxAzimuthAngle: Infinity,\n    enableDamping: true,\n    dampingFactor: 0.5,\n    enableZoom: true,\n    target: {\n      x: 0,\n      y: 0,\n      z: 0 } },\n\n\n  ambientLight: {\n    enabled: true,\n    color: 0x777777 },\n\n  directionalLight: {\n    enabled: true,\n    color: 0xffffff,\n    intensity: 1,\n    multiplyScalar: 50,\n    hue: 0.1,\n    saturation: 0,\n    lightness: 0.5,\n    x: 0,\n    y: 30,\n    z: 0 },\n\n  shadow: {\n    enabled: true,\n    helperEnabled: false,\n    bias: 0,\n    mapWidth: 2048,\n    mapHeight: 2048,\n    near: 0,\n    far: 2048,\n    top: 2048,\n    right: 2048,\n    bottom: -2048,\n    left: -2048 },\n\n  pointLight: {\n    enabled: false,\n    color: 0xffffff,\n    intensity: 0.34,\n    distance: 115,\n    x: 0,\n    y: 0,\n    z: 0 },\n\n  hemiLight: {\n    enabled: false,\n    color: 0xc8c8c8,\n    groundColor: 0xffffff,\n    intensity: 0.55,\n    x: 0,\n    y: 0,\n    z: 0 } };\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/data/config.js\n// module id = 2\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/data/config.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;}; /**\n                                                                                                                                                                                                                                                                                        * Tween.js - Licensed under the MIT license\n                                                                                                                                                                                                                                                                                        * https://github.com/tweenjs/tween.js\n                                                                                                                                                                                                                                                                                        * ----------------------------------------------\n                                                                                                                                                                                                                                                                                        *\n                                                                                                                                                                                                                                                                                        * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n                                                                                                                                                                                                                                                                                        * Thank you all, you're awesome!\n                                                                                                                                                                                                                                                                                        */\n\n// Include a performance.now polyfill\n(function () {\n\n\tif ('performance' in window === false) {\n\t\twindow.performance = {};\n\t}\n\n\t// IE 8\n\tDate.now = Date.now || function () {\n\t\treturn new Date().getTime();\n\t};\n\n\tif ('now' in window.performance === false) {\n\t\tvar offset = window.performance.timing && window.performance.timing.navigationStart ? window.performance.timing.navigationStart :\n\t\tDate.now();\n\n\t\twindow.performance.now = function () {\n\t\t\treturn Date.now() - offset;\n\t\t};\n\t}\n\n})();\n\nvar TWEEN = TWEEN || function () {\n\n\tvar _tweens = [];\n\n\treturn {\n\n\t\tgetAll: function getAll() {\n\n\t\t\treturn _tweens;\n\n\t\t},\n\n\t\tremoveAll: function removeAll() {\n\n\t\t\t_tweens = [];\n\n\t\t},\n\n\t\tadd: function add(tween) {\n\n\t\t\t_tweens.push(tween);\n\n\t\t},\n\n\t\tremove: function remove(tween) {\n\n\t\t\tvar i = _tweens.indexOf(tween);\n\n\t\t\tif (i !== -1) {\n\t\t\t\t_tweens.splice(i, 1);\n\t\t\t}\n\n\t\t},\n\n\t\tupdate: function update(time) {\n\n\t\t\tif (_tweens.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar i = 0;\n\n\t\t\ttime = time !== undefined ? time : window.performance.now();\n\n\t\t\twhile (i < _tweens.length) {\n\n\t\t\t\tif (_tweens[i].update(time)) {\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\t_tweens.splice(i, 1);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} };\n\n\n}();\n\nTWEEN.Tween = function (object) {\n\n\tvar _object = object;\n\tvar _valuesStart = {};\n\tvar _valuesEnd = {};\n\tvar _valuesStartRepeat = {};\n\tvar _duration = 1000;\n\tvar _repeat = 0;\n\tvar _yoyo = false;\n\tvar _isPlaying = false;\n\tvar _reversed = false;\n\tvar _delayTime = 0;\n\tvar _startTime = null;\n\tvar _easingFunction = TWEEN.Easing.Linear.None;\n\tvar _interpolationFunction = TWEEN.Interpolation.Linear;\n\tvar _chainedTweens = [];\n\tvar _onStartCallback = null;\n\tvar _onStartCallbackFired = false;\n\tvar _onUpdateCallback = null;\n\tvar _onCompleteCallback = null;\n\tvar _onStopCallback = null;\n\n\t// Set all starting values present on the target object\n\tfor (var field in object) {\n\t\t_valuesStart[field] = parseFloat(object[field], 10);\n\t}\n\n\tthis.to = function (properties, duration) {\n\n\t\tif (duration !== undefined) {\n\t\t\t_duration = duration;\n\t\t}\n\n\t\t_valuesEnd = properties;\n\n\t\treturn this;\n\n\t};\n\n\tthis.start = function (time) {\n\n\t\tTWEEN.add(this);\n\n\t\t_isPlaying = true;\n\n\t\t_onStartCallbackFired = false;\n\n\t\t_startTime = time !== undefined ? time : window.performance.now();\n\t\t_startTime += _delayTime;\n\n\t\tfor (var property in _valuesEnd) {\n\n\t\t\t// Check if an Array was provided as property value\n\t\t\tif (_valuesEnd[property] instanceof Array) {\n\n\t\t\t\tif (_valuesEnd[property].length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Create a local copy of the Array with the start value at the front\n\t\t\t\t_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);\n\n\t\t\t}\n\n\t\t\t_valuesStart[property] = _object[property];\n\n\t\t\tif (_valuesStart[property] instanceof Array === false) {\n\t\t\t\t_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n\t\t\t}\n\n\t\t\t_valuesStartRepeat[property] = _valuesStart[property] || 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tthis.stop = function () {\n\n\t\tif (!_isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tTWEEN.remove(this);\n\t\t_isPlaying = false;\n\n\t\tif (_onStopCallback !== null) {\n\t\t\t_onStopCallback.call(_object);\n\t\t}\n\n\t\tthis.stopChainedTweens();\n\t\treturn this;\n\n\t};\n\n\tthis.stopChainedTweens = function () {\n\n\t\tfor (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t_chainedTweens[i].stop();\n\t\t}\n\n\t};\n\n\tthis.delay = function (amount) {\n\n\t\t_delayTime = amount;\n\t\treturn this;\n\n\t};\n\n\tthis.repeat = function (times) {\n\n\t\t_repeat = times;\n\t\treturn this;\n\n\t};\n\n\tthis.yoyo = function (yoyo) {\n\n\t\t_yoyo = yoyo;\n\t\treturn this;\n\n\t};\n\n\n\tthis.easing = function (easing) {\n\n\t\t_easingFunction = easing;\n\t\treturn this;\n\n\t};\n\n\tthis.interpolation = function (interpolation) {\n\n\t\t_interpolationFunction = interpolation;\n\t\treturn this;\n\n\t};\n\n\tthis.chain = function () {\n\n\t\t_chainedTweens = arguments;\n\t\treturn this;\n\n\t};\n\n\tthis.onStart = function (callback) {\n\n\t\t_onStartCallback = callback;\n\t\treturn this;\n\n\t};\n\n\tthis.onUpdate = function (callback) {\n\n\t\t_onUpdateCallback = callback;\n\t\treturn this;\n\n\t};\n\n\tthis.onComplete = function (callback) {\n\n\t\t_onCompleteCallback = callback;\n\t\treturn this;\n\n\t};\n\n\tthis.onStop = function (callback) {\n\n\t\t_onStopCallback = callback;\n\t\treturn this;\n\n\t};\n\n\tthis.update = function (time) {\n\n\t\tvar property;\n\t\tvar elapsed;\n\t\tvar value;\n\n\t\tif (time < _startTime) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (_onStartCallbackFired === false) {\n\n\t\t\tif (_onStartCallback !== null) {\n\t\t\t\t_onStartCallback.call(_object);\n\t\t\t}\n\n\t\t\t_onStartCallbackFired = true;\n\n\t\t}\n\n\t\telapsed = (time - _startTime) / _duration;\n\t\telapsed = elapsed > 1 ? 1 : elapsed;\n\n\t\tvalue = _easingFunction(elapsed);\n\n\t\tfor (property in _valuesEnd) {\n\n\t\t\tvar start = _valuesStart[property] || 0;\n\t\t\tvar end = _valuesEnd[property];\n\n\t\t\tif (end instanceof Array) {\n\n\t\t\t\t_object[property] = _interpolationFunction(end, value);\n\n\t\t\t} else {\n\n\t\t\t\t// Parses relative end values with start as base (e.g.: +10, -3)\n\t\t\t\tif (typeof end === 'string') {\n\t\t\t\t\tend = start + parseFloat(end, 10);\n\t\t\t\t}\n\n\t\t\t\t// Protect against non numeric properties.\n\t\t\t\tif (typeof end === 'number') {\n\t\t\t\t\t_object[property] = start + (end - start) * value;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (_onUpdateCallback !== null) {\n\t\t\t_onUpdateCallback.call(_object, value);\n\t\t}\n\n\t\tif (elapsed === 1) {\n\n\t\t\tif (_repeat > 0) {\n\n\t\t\t\tif (isFinite(_repeat)) {\n\t\t\t\t\t_repeat--;\n\t\t\t\t}\n\n\t\t\t\t// Reassign starting values, restart by making startTime = now\n\t\t\t\tfor (property in _valuesStartRepeat) {\n\n\t\t\t\t\tif (typeof _valuesEnd[property] === 'string') {\n\t\t\t\t\t\t_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_yoyo) {\n\t\t\t\t\t\tvar tmp = _valuesStartRepeat[property];\n\n\t\t\t\t\t\t_valuesStartRepeat[property] = _valuesEnd[property];\n\t\t\t\t\t\t_valuesEnd[property] = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\t_valuesStart[property] = _valuesStartRepeat[property];\n\n\t\t\t\t}\n\n\t\t\t\tif (_yoyo) {\n\t\t\t\t\t_reversed = !_reversed;\n\t\t\t\t}\n\n\t\t\t\t_startTime = time + _delayTime;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\tif (_onCompleteCallback !== null) {\n\t\t\t\t\t_onCompleteCallback.call(_object);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t\t\t_chainedTweens[i].start(time);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n};\n\n\nTWEEN.Easing = {\n\n\tLinear: {\n\n\t\tNone: function None(k) {\n\n\t\t\treturn k;\n\n\t\t} },\n\n\n\n\tQuadratic: {\n\n\t\tIn: function In(k) {\n\n\t\t\treturn k * k;\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\treturn k * (2 - k);\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k;\n\t\t\t}\n\n\t\t\treturn -0.5 * (--k * (k - 2) - 1);\n\n\t\t} },\n\n\n\n\tCubic: {\n\n\t\tIn: function In(k) {\n\n\t\t\treturn k * k * k;\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\treturn --k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\n\t\t} },\n\n\n\n\tQuartic: {\n\n\t\tIn: function In(k) {\n\n\t\t\treturn k * k * k * k;\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\treturn 1 - --k * k * k * k;\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn -0.5 * ((k -= 2) * k * k * k - 2);\n\n\t\t} },\n\n\n\n\tQuintic: {\n\n\t\tIn: function In(k) {\n\n\t\t\treturn k * k * k * k * k;\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\treturn --k * k * k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\n\t\t} },\n\n\n\n\tSinusoidal: {\n\n\t\tIn: function In(k) {\n\n\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\treturn Math.sin(k * Math.PI / 2);\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\n\t\t} },\n\n\n\n\tExponential: {\n\n\t\tIn: function In(k) {\n\n\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\n\t\t} },\n\n\n\n\tCircular: {\n\n\t\tIn: function In(k) {\n\n\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\treturn Math.sqrt(1 - --k * k);\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\n\t\t} },\n\n\n\n\tElastic: {\n\n\t\tIn: function In(k) {\n\n\t\t\tvar s;\n\t\t\tvar a = 0.1;\n\t\t\tvar p = 0.4;\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (!a || a < 1) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p * Math.asin(1 / a) / (2 * Math.PI);\n\t\t\t}\n\n\t\t\treturn -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\tvar s;\n\t\t\tvar a = 0.1;\n\t\t\tvar p = 0.4;\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (!a || a < 1) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p * Math.asin(1 / a) / (2 * Math.PI);\n\t\t\t}\n\n\t\t\treturn a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tvar s;\n\t\t\tvar a = 0.1;\n\t\t\tvar p = 0.4;\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif (!a || a < 1) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p * Math.asin(1 / a) / (2 * Math.PI);\n\t\t\t}\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t\t\t}\n\n\t\t\treturn a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n\t\t} },\n\n\n\n\tBack: {\n\n\t\tIn: function In(k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn k * k * ((s + 1) * k - s);\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tvar s = 1.70158 * 1.525;\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\n\t\t} },\n\n\n\n\tBounce: {\n\n\t\tIn: function In(k) {\n\n\t\t\treturn 1 - TWEEN.Easing.Bounce.Out(1 - k);\n\n\t\t},\n\n\t\tOut: function Out(k) {\n\n\t\t\tif (k < 1 / 2.75) {\n\t\t\t\treturn 7.5625 * k * k;\n\t\t\t} else if (k < 2 / 2.75) {\n\t\t\t\treturn 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t\t\t} else if (k < 2.5 / 2.75) {\n\t\t\t\treturn 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t\t\t} else {\n\t\t\t\treturn 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t\t\t}\n\n\t\t},\n\n\t\tInOut: function InOut(k) {\n\n\t\t\tif (k < 0.5) {\n\t\t\t\treturn TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n\t\t\t}\n\n\t\t\treturn TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\n\t\t} } };\n\n\n\n\n\nTWEEN.Interpolation = {\n\n\tLinear: function Linear(v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.Linear;\n\n\t\tif (k < 0) {\n\t\t\treturn fn(v[0], v[1], f);\n\t\t}\n\n\t\tif (k > 1) {\n\t\t\treturn fn(v[m], v[m - 1], m - f);\n\t\t}\n\n\t\treturn fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\n\t},\n\n\tBezier: function Bezier(v, k) {\n\n\t\tvar b = 0;\n\t\tvar n = v.length - 1;\n\t\tvar pw = Math.pow;\n\t\tvar bn = TWEEN.Interpolation.Utils.Bernstein;\n\n\t\tfor (var i = 0; i <= n; i++) {\n\t\t\tb += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n\t\t}\n\n\t\treturn b;\n\n\t},\n\n\tCatmullRom: function CatmullRom(v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.CatmullRom;\n\n\t\tif (v[0] === v[m]) {\n\n\t\t\tif (k < 0) {\n\t\t\t\ti = Math.floor(f = m * (1 + k));\n\t\t\t}\n\n\t\t\treturn fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n\n\t\t} else {\n\n\t\t\tif (k < 0) {\n\t\t\t\treturn v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n\t\t\t}\n\n\t\t\tif (k > 1) {\n\t\t\t\treturn v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n\t\t\t}\n\n\t\t\treturn fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n\n\t\t}\n\n\t},\n\n\tUtils: {\n\n\t\tLinear: function Linear(p0, p1, t) {\n\n\t\t\treturn (p1 - p0) * t + p0;\n\n\t\t},\n\n\t\tBernstein: function Bernstein(n, i) {\n\n\t\t\tvar fc = TWEEN.Interpolation.Utils.Factorial;\n\n\t\t\treturn fc(n) / fc(i) / fc(n - i);\n\n\t\t},\n\n\t\tFactorial: function () {\n\n\t\t\tvar a = [1];\n\n\t\t\treturn function (n) {\n\n\t\t\t\tvar s = 1;\n\n\t\t\t\tif (a[n]) {\n\t\t\t\t\treturn a[n];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = n; i > 1; i--) {\n\t\t\t\t\ts *= i;\n\t\t\t\t}\n\n\t\t\t\ta[n] = s;\n\t\t\t\treturn s;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tCatmullRom: function CatmullRom(p0, p1, p2, p3, t) {\n\n\t\t\tvar v0 = (p2 - p0) * 0.5;\n\t\t\tvar v1 = (p3 - p1) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\n\t\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\n\t\t} } };\n\n\n\n\n\n// UMD (Universal Module Definition)\n(function (root) {\n\n\tif (true) {\n\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\t\treturn TWEEN;\n\t\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\t} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n\n\t\t// Node.js\n\t\tmodule.exports = TWEEN;\n\n\t} else {\n\n\t\t// Global variable\n\t\troot.TWEEN = TWEEN;\n\n\t}\n\n})(undefined);\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tween.js/src/Tween.js\n// module id = 3\n// module chunks = 0\n//# sourceURL=webpack:///./~/tween.js/src/Tween.js?");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true }); /**\n                                                                             * @author alteredq / http://alteredqualia.com/\n                                                                             * @author mr.doob / http://mrdoob.com/\n                                                                             */exports.default =\n\n{\n  canvas: !!window.CanvasRenderingContext2D,\n  webgl: function () {\n    try {\n      var canvas = document.createElement('canvas');\n\n      return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n    } catch (e) {\n      return false;\n    }\n  }(),\n\n  workers: !!window.Worker,\n  fileapi: window.File && window.FileReader && window.FileList && window.Blob,\n\n  getWebGLErrorMessage: function getWebGLErrorMessage() {\n    var element = document.createElement('div');\n    element.id = 'webgl-error-message';\n    element.style.fontFamily = 'monospace';\n    element.style.fontSize = '13px';\n    element.style.fontWeight = 'normal';\n    element.style.textAlign = 'center';\n    element.style.background = '#fff';\n    element.style.color = '#000';\n    element.style.padding = '1.5em';\n    element.style.width = '400px';\n    element.style.margin = '5em auto 0';\n\n    if (!this.webgl) {\n      element.innerHTML = window.WebGLRenderingContext ? [\n      'Your graphics card does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000000\">WebGL</a>.<br />',\n      'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000000\">here</a>.'].\n      join('\\n') : [\n      'Your browser does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000000\">WebGL</a>.<br/>',\n      'Find out how to get it <a href=\"http://get.webgl.org/\" style=\"color:#000000\">here</a>.'].\n      join('\\n');\n    }\n\n    return element;\n  },\n\n  addGetWebGLMessage: function addGetWebGLMessage(parameters) {\n    var parent, id, element;\n\n    parameters = parameters || {};\n\n    parent = parameters.parent !== undefined ? parameters.parent : document.body;\n    id = parameters.id !== undefined ? parameters.id : 'oldie';\n\n    element = this.getWebGLErrorMessage();\n    element.id = id;\n\n    parent.appendChild(element);\n  } };\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/utils/detector.js\n// module id = 4\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/utils/detector.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();\n\n\n\n\n// Components\n\n\n\n\n\n\n// Helpers\n\n\n// Model\n\n\n// Managers\n\n\n\n// data\nvar _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);var _tween = __webpack_require__(3);var _tween2 = _interopRequireDefault(_tween);var _objloader = __webpack_require__(7);var _objloader2 = _interopRequireDefault(_objloader);var _helpers = __webpack_require__(8);var _helpers2 = _interopRequireDefault(_helpers);var _renderer = __webpack_require__(9);var _renderer2 = _interopRequireDefault(_renderer);var _camera = __webpack_require__(10);var _camera2 = _interopRequireDefault(_camera);var _light = __webpack_require__(11);var _light2 = _interopRequireDefault(_light);var _controls = __webpack_require__(12);var _controls2 = _interopRequireDefault(_controls);var _pathdrawer = __webpack_require__(14);var _pathdrawer2 = _interopRequireDefault(_pathdrawer);var _geometry = __webpack_require__(19);var _geometry2 = _interopRequireDefault(_geometry);var _model = __webpack_require__(21);var _model2 = _interopRequireDefault(_model);var _interaction = __webpack_require__(23);var _interaction2 = _interopRequireDefault(_interaction);var _guiwindow = __webpack_require__(25);var _guiwindow2 = _interopRequireDefault(_guiwindow);var _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Local vars for rStats\nvar rS = void 0,bS = void 0,glS = void 0,tS = void 0;\n\n// This class instantiates and ties all of the components together\n// starts the loading process and renders the main loop\nvar Main = function () {\n  function Main(container) {var _this = this;_classCallCheck(this, Main);\n    (0, _objloader2.default)(THREE);\n    this.overrideTriangulate();\n    this.setupAudio();\n\n    this.mouse = new THREE.Vector3();\n    this.nonScaledMouse = new THREE.Vector3();\n    this.ray = new THREE.Raycaster();\n    this.walkingRay = new THREE.Raycaster();\n\n    this.isMuted = false;\n    this.isMouseDown = false;\n    this.isAddingTrajectory = false;\n    this.isAddingObject = false;\n    this.isEditingObject = false;\n    this.isUserStudyLoading = false;\n\n    this.activeObject = null;\n\n    this.floor;\n    this.counter = 1;\n    this.movementSpeed = 10;\n    this.increment = 0.01;\n    this.direction = 1;\n\n    this.soundObjects = [];\n    this.soundTrajectories = [];\n    this.soundZones = [];\n\n    this.loader;\n    this.moveForward = 0;\n    this.moveBackwards = 0;\n    this.yawLeft = 0;\n    this.yawRight = 0;\n    this.rotationSpeed = 0.05;\n\n    this.perspectiveView = false;\n    this.keyPressed = false;\n\n    this.interactiveCone = null;\n\n    this.cameraDestination = new THREE.Vector3();\n\n    this.ray.linePrecision = 10;\n\n    // Set container property to container element\n    this.container = container;\n\n    // Start Three clock\n    this.clock = new THREE.Clock();\n\n    // Main scene creation\n    this.scene = new THREE.Scene();\n\n    // Add GridHelper\n    var grid = new THREE.GridHelper(_config2.default.grid.size, _config2.default.grid.divisions);\n    grid.position.y = -300;\n    grid.material.opacity = 0.25;\n    grid.material.transparent = true;\n    this.scene.add(grid);\n\n    /**\n                           * The X-Z raycasting plane for determining where on the floor\n                           * the user is clicking.\n                           */\n    var planeGeometry = new THREE.PlaneGeometry(_config2.default.grid.size * 2, _config2.default.grid.size * 2);\n    var planeMaterial = new THREE.MeshBasicMaterial({\n      color: 0xffffff,\n      side: THREE.BackSide,\n      visible: false });\n\n    this.floor = new THREE.Mesh(planeGeometry, planeMaterial);\n    this.floor.rotation.x = Math.PI / 2;\n    this.scene.add(this.floor);\n\n    var shadowFloor = new THREE.Mesh(planeGeometry.clone(), new THREE.MeshLambertMaterial({\n      color: 0xf0f0f0,\n      side: THREE.BackSide,\n      transparent: true,\n      opacity: 0.2 }));\n\n    shadowFloor.rotation.x = Math.PI / 2;\n    shadowFloor.position.y = -300;\n    shadowFloor.receiveShadow = true;\n    this.scene.add(shadowFloor);\n\n\n    // Get Device Pixel Ratio first for retina\n    if (window.devicePixelRatio) {\n      _config2.default.dpr = window.devicePixelRatio;\n    }\n\n    // Main renderer instantiation\n    this.renderer = new _renderer2.default(this.scene, container);\n\n    // Components instantiation\n    this.camera = new _camera2.default(this.renderer.threeRenderer);\n    this.controls = new _controls2.default(this.camera.threeCamera, document);\n    this.loader = new THREE.OBJLoader();\n    this.light = new _light2.default(this.scene);\n\n    // Create and place lights in scene\n    ['ambient', 'directional'].forEach(function (l) {return _this.light.place(l);});\n\n    /**\n                                                                                      * Setting up interface to create object/zone/trajectory instances.\n                                                                                      */\n    this.path = new _pathdrawer2.default(this.scene);\n\n    new _interaction2.default(this, this.renderer.threeRenderer, this.scene, this.camera.threecamera, this.controls.threeControls);\n\n    // Set up rStats if dev environment\n    if (_config2.default.isDev) {\n      bS = new BrowserStats();\n      glS = new glStats();\n      tS = new threeStats(this.renderer.threeRenderer);\n\n      rS = new rStats({\n        CSSPath: './assets/css/',\n        userTimingAPI: false,\n        values: {\n          frame: { caption: 'Total frame time (ms)', over: 16, average: true, avgMs: 100 },\n          fps: { caption: 'Framerate (FPS)', below: 30 },\n          calls: { caption: 'Calls (three.js)', over: 3000 },\n          raf: { caption: 'Time since last rAF (ms)', average: true, avgMs: 100 },\n          rstats: { caption: 'rStats update (ms)', average: true, avgMs: 100 },\n          texture: { caption: 'GenTex', average: true, avgMs: 100 } },\n\n        groups: [\n        { caption: 'Framerate', values: ['fps', 'raf'] },\n        { caption: 'Frame Budget', values: ['frame', 'texture', 'setup', 'render'] }],\n\n        fractions: [\n        { base: 'frame', steps: ['texture', 'setup', 'render'] }],\n\n        plugins: [bS, tS, glS] });\n\n    }\n\n    // Create user head\n    var dummyHead = new _model2.default(this.scene, this.loader);\n    dummyHead.load();\n\n    // AxisHelper for the Head Model\n    this.axisHelper = new THREE.AxisHelper(60);\n    this.axisHelper.rotation.y += Math.PI;\n    this.scene.add(this.axisHelper);\n\n    // ui elements\n    document.getElementById('add-object-button').onclick = this.toggleAddObject.bind(this);\n    var self = this;\n    document.getElementById('mute-button').onclick = function () {\n      self.toggleGlobalMute();\n      this.style.display = 'none';\n      document.getElementById('unmute-button').style.display = 'block';\n    };\n    document.getElementById('unmute-button').onclick = function () {\n      self.toggleGlobalMute();\n      this.style.display = 'none';\n      document.getElementById('mute-button').style.display = 'block';\n    };\n\n    var this_ = this;\n    document.getElementById('save-button').onclick = function () {\n      this.data = this_.export();\n      var a = document.createElement('a');\n      var blob = new Blob([this.data], { 'type': 'text/plain' });\n      a.href = window.URL.createObjectURL(blob);\n      a.download = 'export.json';\n      a.click();\n    };\n    document.getElementById('load-button').onclick = function () {\n      var i = document.getElementById('import');\n      i.click();\n      i.addEventListener('change', handleFiles, false);\n\n      function handleFiles() {\n        var reader = new FileReader();\n        reader.addEventListener('load', function (e) {\n          this_.import(e.target.result);\n        });\n        reader.readAsText(this.files[0]);\n      }\n    };\n    this.cameraLabel = document.getElementById('camera-label');\n    this.cameraLabel.onclick = this.reset.bind(this);\n    // this.cameraLabel.onclick = function (){\n    //   document.getElementById('help-camera').style.display = 'none';\n    // }\n    this.cameraLabel.innerHTML = this.perspectiveView ? 'Altitude view' : 'Aerial view';\n\n    this.gui = new _guiwindow2.default(this);\n\n    // Start render which does not wait for model fully loaded\n    this.container.querySelector('#loading').style.display = 'none';\n    this.render();\n    _config2.default.isLoaded = true;\n  }_createClass(Main, [{ key: 'render', value: function render()\n\n    {\n      // Render rStats if Dev\n      if (_config2.default.isDev) {\n        rS('frame').start();\n        glS.start();\n\n        rS('rAF').tick();\n        rS('FPS').frame();\n\n        rS('render').start();\n      }\n\n      // Call render function and pass in created scene and camera\n      this.renderer.render(this.scene, this.camera.threeCamera);\n\n      // rStats has finished determining render call now\n      if (_config2.default.isDev) {\n        rS('render').end(); // render finished\n        rS('frame').end(); // frame finished\n\n        // Local rStats update\n        rS('rStats').start();\n        rS().update();\n        rS('rStats').end();\n      }\n\n      /* Frame rate dependency for the head movement speed */\n      this.movementSpeed = 10 * (30 / rS('FPS').value());\n\n      /* Camera tweening object update */\n      _tween2.default.update();\n\n      /* Updating camera controls. */\n      this.controls.threeControls.update();\n\n      /**\n                                             * Hands over the positioning of the listener node from the head model\n                                             * to the camera in object edit view\n                                             **/\n      if (this.isEditingObject) this.setListenerPosition(this.camera.threeCamera);\n\n      /**\n                                                                                    * Differentiating between perspective and bird's-eye views. If the camera is tilted\n                                                                                    * enough the perspective view is activated, restring user's placement of object in the\n                                                                                    * X-Z plane\n                                                                                    */\n      if (this.controls.threeControls.getPolarAngle() > 0.4) {\n        if (!this.perspectiveView) {\n          document.getElementById('help-camera').style.display = 'none';\n          this.perspectiveView = true;\n          this.cameraLabel.innerHTML = 'Altitude view';\n        }\n      } else if (this.perspectiveView) {\n        this.perspectiveView = false;\n        this.cameraLabel.innerHTML = 'Aerial view';\n      }\n\n      /* Checking if the user has walked into a sound zone in each frame. */\n      this.checkZones();\n\n      /* Updating the head model's position and orientation in each frame. */\n      this.updateDummyHead();\n\n      /**\n                               * Stops an object trajectory motion if the used clicks onto a moving object\n                               */\n      for (var i in this.soundObjects) {\n        if (!this.isMouseDown || this.soundObjects[i] !== this.activeObject) {\n          if (this.soundObjects[i].type === 'SoundObject') {\n            this.soundObjects[i].followTrajectory(this.isMuted);\n          }\n        }\n      }\n\n      /* Making the GUI visible if an object is selected */\n      this.gui.display(this.activeObject);\n\n      requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n    } }, { key: 'setupAudio', value: function setupAudio()\n\n    {\n      var a = {};\n      window.AudioContext = window.AudioContext || window.webkitAudioContext;\n\n      a.context = new AudioContext();\n      a.context.listener.setOrientation(0, 0, -1, 0, 1, 0);\n      a.context.listener.setPosition(0, 1, 0);\n      a.destination = a.context.createGain();\n      a.destination.connect(a.context.destination);\n\n      this.audio = a;\n    } }, { key: 'setListenerPosition', value: function setListenerPosition(\n\n    object) {\n      var q = new THREE.Vector3();\n      object.updateMatrixWorld();\n      q.setFromMatrixPosition(object.matrixWorld);\n      this.audio.context.listener.setPosition(q.x, q.y, q.z);\n\n      var m = object.matrix;\n      var mx = m.elements[12];\n      var my = m.elements[13];\n      var mz = m.elements[14];\n      m.elements[12] = m.elements[13] = m.elements[14] = 0;\n\n      var vec = new THREE.Vector3(0, 0, -1);\n      vec.applyMatrix4(m);\n      vec.normalize();\n\n      var up = new THREE.Vector3(0, -1, 0);\n      up.applyMatrix4(m);\n      up.normalize();\n\n      this.audio.context.listener.setOrientation(vec.x, vec.y, vec.z, up.x, up.y, up.z);\n\n      m.elements[12] = mx;\n      m.elements[13] = my;\n      m.elements[14] = mz;\n    }\n\n    /**\n       * Checks if the user has walked into a sound zone by raycasting from the\n       * head model's position onto each sound zone into scene and checking if there\n       * is a hit.\n       */ }, { key: 'checkZones', value: function checkZones()\n    {\n      if (this.soundZones.length > 0) {\n        var walkingRayVector = new THREE.Vector3(0, -1, 0);\n        this.walkingRay.set(this.head.position, walkingRayVector);\n\n        for (var i in this.soundZones) {\n          var intersects = this.walkingRay.intersectObject(this.soundZones[i].shape);\n          if (intersects.length > 0) {\n            /**\n                                       * Flagging a zone \"under user\" to activate the audio file associated\n                                       * with the sound zone.\n                                       */\n            this.soundZones[i].underUser(this.audio);\n          } else {\n            this.soundZones[i].notUnderUser(this.audio);\n          }\n        }\n      }\n    } }, { key: 'tweenToObjectView', value: function tweenToObjectView()\n\n    {var _this2 = this;\n      if (this.isEditingObject) {\n        var vec = new THREE.Vector3().subVectors(this.camera.threeCamera.position, this.activeObject.containerObject.position);\n        vec.y = this.activeObject.containerObject.position.y;\n        this.cameraDestination = this.activeObject.containerObject.position.clone().addScaledVector(vec.normalize(), 500);\n\n        new _tween2.default.Tween(this.camera.threeCamera.position).\n        to(this.cameraDestination, 800).\n        start();\n\n        new _tween2.default.Tween(this.controls.threeControls.center).\n        to(this.activeObject.containerObject.position, 800).\n        start();\n\n        /**\n                  * Edit Object View only applies to sound objects. A Sound Object in the scene\n                  * is represented with 4 elements: Raycast Sphere Mesh, AxisHelper,\n                  * AltitudeHelper Line, and the containerObject which holds the omniSphere\n                  * and the cones. To make only the activeObject and nothing else in the scene,\n                  * first we set every object after scene defaults (i.e. grid, collider plane,\n                  * lights, edit view light box and camera helper) invisible. Then we find the\n                  * index of the raycast sphere that belongs to the active object and make\n                  * this and the following 3 object visible to bring the activeObject back\n                  * in the scene.\n                  **/\n\n        if (this.head) {\n          this.head.visible = false;\n          //this.head.children[0].material.opacity = 0.05;\n          this.axisHelper.visible = false;\n        }\n        this.gui.disableGlobalParameters();\n        [].concat(this.soundObjects, this.soundZones).forEach(function (object) {\n          if (object !== _this2.activeObject) {\n            if (object.type === \"SoundObject\") {\n              object.axisHelper.visible = false;\n              object.altitudeHelper.visible = false;\n              object.cones.forEach(function (cone) {return cone.material.opacity = 0.1;});\n              object.omniSphere.material.opacity = 0.2;\n            } else\n            if (object.type === \"SoundZone\") {\n              object.shape.material.opacity = 0.05;\n              // object.shape.visible = false;\n            }\n          }\n\n          if (object.type === \"SoundObject\") {\n            object.pause();\n            if (object === _this2.activeObject) {\n              object.axisHelper.visible = true;\n              object.axisHelper.visible = true;\n              object.altitudeHelper.visible = true;\n              object.cones.forEach(function (cone) {return cone.material.opacity = 0.8;});\n              object.omniSphere.material.opacity = 0.8;\n            }\n          }\n        });\n\n        /* lightbox effect */\n        this.renderer.threeRenderer.setClearColor(0xbbeeff);\n      }\n    } }, { key: 'enterEditObjectView', value: function enterEditObjectView()\n\n    {\n      document.getElementById('camera-label').style.display = 'none';\n\n      // disable panning in object view\n      this.controls.disablePan();\n\n      // slightly hacky fix: orbit controls tween works poorly from top view\n      if (this.controls.threeControls.getPolarAngle() < 0.01) {\n        this.controls.threeControls.constraint.rotateUp(-0.02);\n        this.controls.threeControls.update();\n      }\n\n      if (!this.isEditingObject) {\n        this.isEditingObject = true;\n        this.isAddingObject = this.isAddingTrajectory = false;\n        this.originalCameraPosition = this.camera.threeCamera.position.clone();\n        this.originalCameraCenter = this.controls.threeControls.center.clone();\n      }\n\n      if (this.activeObject.type == 'SoundTrajectory') {\n        // return control to parent sound object\n        this.activeObject.deselectPoint();\n        this.activeObject = this.activeObject.parentSoundObject;\n      }\n\n      this.tweenToObjectView();\n    } }, { key: 'exitEditObjectView', value: function exitEditObjectView(\n\n    reset) {\n      document.getElementById('camera-label').style.display = 'block';\n      // re-enable panning\n      this.controls.enablePan();\n\n      if (this.gui.editor) {this.gui.exitEditorGui();}\n      this.isEditingObject = false;\n      if (this.head) {\n        this.head.visible = true;\n        // this.head.children[0].material.opacity = 1;\n        this.axisHelper.visible = true;\n      }\n      this.gui.enableGlobalParameters();\n      [].concat(this.soundObjects, this.soundZones).forEach(function (object) {\n        if (object.type === \"SoundObject\") {\n          object.axisHelper.visible = true;\n          object.altitudeHelper.visible = true;\n          object.cones.forEach(function (cone) {return cone.material.opacity = 0.8;});\n          object.omniSphere.material.opacity = 0.8;\n          object.unpause();\n        } else\n        if (object.type === \"SoundZone\") {\n          object.shape.material.opacity = _helpers2.default.mapRange(object.volume, 0, 2, 0.05, 0.35);\n          // object.shape.visible = true;\n        }\n      });\n\n      if (!this.isAddingTrajectory && !this.isAddingObject && !reset) {\n        new _tween2.default.Tween(this.camera.threeCamera.position).\n        to(this.originalCameraPosition, 800).\n        start();\n\n        new _tween2.default.Tween(this.controls.threeControls.center).\n        to(this.originalCameraCenter, 800).\n        start();\n      }\n      /* turn off lightbox effect */\n      this.renderer.threeRenderer.setClearColor(0xf0f0f0);\n    } }, { key: 'reset', value: function reset()\n\n    {\n      if (this.isEditingObject) {\n        this.exitEditObjectView(true);\n      }\n      this.controls.threeControls.reset();\n    } }, { key: 'toggleAddTrajectory',\n\n\n\n\n\n\n\n\n\n    /**\n                                        * Sets the trajectory adding state on. If the scene is in perspective view when\n                                        * this is called, it will be reset to bird's eye.\n                                        */value: function toggleAddTrajectory(\n    state) {\n      this.isAddingTrajectory = state === undefined ? !this.isAddingTrajectory : state;\n      this.reset();\n    }\n\n    /**\n       * Sets the object adding state on. If the scene is in perspective view when\n       * this is called, it will be reset to bird's eye.\n       */ }, { key: 'toggleAddObject', value: function toggleAddObject()\n    {\n      this.isAddingObject = !this.isAddingObject;\n      this.reset();\n\n      var btn = document.getElementById('add-object-button');\n      btn.classList.toggle('active', this.isAddingObject);\n      btn.innerHTML = this.isAddingObject ? '×' : '+';\n\n      document.getElementById('help-add').style.display = 'none';\n    }\n\n    /**\n       * Sets the the last clicked (active) object.\n       * Calls a \"secActive()\" function ob the selected object.\n       */ }, { key: 'setActiveObject', value: function setActiveObject(\n    obj) {\n      if (this.activeObject) {\n        this.activeObject.setInactive();\n      }\n\n      this.activeObject = obj;\n\n      if (obj) {\n        if (obj.cones && obj.cones.length > 0) {\n          this.interactiveCone = obj.cones[0];\n        }\n        obj.setActive(this);\n      }\n    }\n\n    /* Updates the head model's position and orientation in each frame. */ }, { key: 'updateDummyHead', value: function updateDummyHead()\n    {\n      this.head = this.scene.getObjectByName('dummyHead', true);\n\n      if (this.head && !this.isEditingObject) {\n        this.axisHelper.rotation.y += -this.yawLeft + this.yawRight;\n        this.head.rotation.y += -this.yawLeft + this.yawRight;\n        this.axisHelper.translateZ(-this.moveBackwards + this.moveForward);\n        this.head.translateZ(-this.moveBackwards + this.moveForward);\n        this.setListenerPosition(this.head);\n      }\n    } }, { key: 'setMousePosition', value: function setMousePosition(\n\n    event) {\n      var pointer = new THREE.Vector3();\n      pointer.set(event.clientX / window.innerWidth * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);\n\n      this.nonScaledMouse = pointer;\n\n      this.ray.setFromCamera(pointer, this.camera.threeCamera);\n\n      var intersects = this.ray.intersectObject(this.floor);\n      if (intersects.length > 0) {\n        this.mouse = intersects[0].point;\n      }\n    } }, { key: 'toggleGlobalMute', value: function toggleGlobalMute()\n\n    {var _this3 = this;\n      this.isMuted = !this.isMuted;\n      [].concat(this.soundObjects, this.soundZones).forEach(function (sound) {return sound.checkMuteState(_this3);});\n    } }, { key: 'muteAll', value: function muteAll(\n\n    excludedSounds) {var _this4 = this;\n      var sounds = [].concat(this.soundObjects, this.soundZones);\n\n      if (excludedSounds) {\n        excludedSounds = [].concat(excludedSounds);\n        sounds = sounds.filter(function (sound) {return excludedSounds.indexOf(sound) < 0;});\n      }\n\n      sounds.forEach(function (sound) {return sound.mute(_this4);});\n    } }, { key: 'unmuteAll', value: function unmuteAll(\n\n    excludedSounds) {var _this5 = this;\n      var sounds = [].concat(this.soundObjects, this.soundZones);\n\n      if (excludedSounds) {\n        excludedSounds = [].concat(excludedSounds);\n        sounds = sounds.filter(function (sound) {return excludedSounds.indexOf(sound) < 0;});\n      }\n\n      sounds.forEach(function (sound) {return sound.unmute(_this5);});\n    } }, { key: 'removeSoundZone', value: function removeSoundZone(\n\n    soundZone) {\n      var i = this.soundZones.indexOf(soundZone);\n      this.soundZones[i].notUnderUser(this.audio);\n      soundZone.removeFromScene(this.scene);\n      this.soundZones.splice(i, 1);\n    } }, { key: 'removeSoundObject', value: function removeSoundObject(\n\n    soundObject) {\n      soundObject.removeFromScene(this.scene);\n      var i = this.soundObjects.indexOf(soundObject);\n      this.soundObjects.splice(i, 1);\n    } }, { key: 'removeCone', value: function removeCone(\n\n    object, cone) {\n      object.removeCone(cone);\n      this.gui.removeCone(cone);\n    } }, { key: 'removeSoundTrajectory', value: function removeSoundTrajectory(\n\n    soundTrajectory) {\n      soundTrajectory.removeFromScene(this.scene);\n      var i = this.soundTrajectories.indexOf(soundTrajectory);\n      this.soundTrajectories.splice(i, 1);\n    }\n\n    /**\n      (didn't know where I should put this)\n       overrides three.js triangulate with libtess.js algorithm for the conversion of a curve to a filled (2D) path. still doesn't produce desired behavior with some non-simple paths\n       adapted from libtess example page https://brendankenny.github.io/libtess.js/examples/simple_triangulation/index.html\n      */ }, { key: 'overrideTriangulate', value: function overrideTriangulate()\n\n\n    {\n      var tessy = function initTesselator() {\n        // function called for each vertex of tesselator output\n        function vertexCallback(data, polyVertArray) {\n          // console.log(data[0], data[1]);\n          polyVertArray[polyVertArray.length] = data[0];\n          polyVertArray[polyVertArray.length] = data[1];\n        }\n        function begincallback(type) {\n          if (type !== libtess.primitiveType.GL_TRIANGLES) {\n            console.log('expected TRIANGLES but got type: ' + type);\n          }\n        }\n        function errorcallback(errno) {\n          console.log('error callback');\n          console.log('error number: ' + errno);\n        }\n        // callback for when segments intersect and must be split\n        function combinecallback(coords, data, weight) {\n          // console.log('combine callback');\n          return [coords[0], coords[1], coords[2]];\n        }\n        function edgeCallback(flag) {\n          // don't really care about the flag, but need no-strip/no-fan behavior\n          // console.log('edge flag: ' + flag);\n        }\n\n        var tessy = new libtess.GluTesselator();\n        tessy.gluTessProperty(libtess.gluEnum.GLU_TESS_WINDING_RULE, libtess.windingRule.GLU_TESS_WINDING_NONZERO);\n        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);\n        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, begincallback);\n        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, errorcallback);\n        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combinecallback);\n        tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);\n\n        return tessy;\n      }();\n\n      THREE.ShapeUtils.triangulate = function (contour, indices) {\n\n        if (contour.length < 3) return null;\n\n        var triangles = [];\n        var map = {};\n\n        var result = [];\n        var vertIndices = [];\n\n        // libtess will take 3d verts and flatten to a plane for tesselation\n        // since only doing 2d tesselation here, provide z=1 normal to skip\n        // iterating over verts only to get the same answer.\n        // comment out to test normal-generation code\n        tessy.gluTessNormal(0, 0, 1);\n\n        tessy.gluTessBeginPolygon(triangles);\n\n        // shape should be a single contour without holes anyway...\n        tessy.gluTessBeginContour();\n        contour.forEach(function (pt, i) {\n          var coord = [pt.x, pt.y, 0];\n          tessy.gluTessVertex(coord, coord);\n          map[coord[0] + ',' + coord[1]] = i; // store in map\n        });\n        tessy.gluTessEndContour();\n\n        // finish polygon\n        tessy.gluTessEndPolygon();\n\n        // use map to convert points back to triangles of contour\n        var nTri = triangles.length;\n\n        for (var i = 0; i < nTri; i += 6) {\n          var a = map[triangles[i] + ',' + triangles[i + 1]],\n          b = map[triangles[i + 2] + ',' + triangles[i + 3]],\n          c = map[triangles[i + 4] + ',' + triangles[i + 5]];\n\n          if (a == undefined || b == undefined || c == undefined) {continue;}\n          vertIndices.push([a, b, c]);\n          result.push([contour[a],\n          contour[b],\n          contour[c]]);\n        }\n\n        if (indices) return vertIndices;\n        return result;\n      };\n    } }, { key: 'export', value: function _export()\n\n    {\n      return JSON.stringify({\n        camera: this.camera.threeCamera.toJSON(),\n        soundObjects: this.soundObjects.map(function (obj) {return obj.toJSON();}),\n        soundZones: this.soundZones.map(function (obj) {return obj.toJSON();}) });\n\n    } }, { key: 'import', value: function _import(\n\n    data) {var _this6 = this;\n      var json = JSON.parse(data);\n      var loader = new THREE.ObjectLoader();\n      var cam = loader.parse(json.camera);\n\n      json.soundObjects.forEach(function (obj) {\n        var parsed = JSON.parse(obj);\n\n        var newObj = _this6.path.createObject(_this6, true);\n        newObj.fromJSON(obj);\n        _this6.setActiveObject(newObj);\n        _this6.isAddingObject = false;\n\n        // Trajectory\n        if (parsed.trajectory) {\n          _this6.path.points = parsed.trajectory.map(function (i) {return new THREE.Vector3(i.x, i.y, i.z);});\n          _this6.path.parentObject = newObj;\n          _this6.path.createObject(_this6, true);\n          newObj.calculateMovementSpeed();\n        }\n      });\n\n      json.soundZones.forEach(function (obj) {\n        var object = JSON.parse(obj);\n\n        // Fakes drawing for zone creation\n        _this6.path.points = object.points;\n\n        var newObj = _this6.path.createObject(_this6, true);\n        newObj.fromJSON(obj);\n        _this6.setActiveObject(newObj);\n        _this6.isAddingObject = false;\n      });\n\n      this.camera.threeCamera.copy(cam);\n      this.camera.threeCamera.updateProjectionMatrix();\n    } }, { key: 'audio', set: function set(audio) {this._audio = audio;}, get: function get() {return this._audio;} }]);return Main;}();exports.default = Main;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/main.js\n// module id = 5\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/main.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';var _typeof=typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};(function(global,factory){\n( false?'undefined':_typeof(exports))==='object'&&typeof module!=='undefined'?factory(exports):\n true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):\nfactory(global.THREE=global.THREE||{});\n})(undefined,function(exports){'use strict';\n\n// Polyfills\n\nif(Number.EPSILON===undefined){\n\nNumber.EPSILON=Math.pow(2,-52);\n\n}\n\n//\n\nif(Math.sign===undefined){\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\n\nMath.sign=function(x){\n\nreturn x<0?-1:x>0?1:+x;\n\n};\n\n}\n\nif(Function.prototype.name===undefined){\n\n// Missing in IE9-11.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\n\nObject.defineProperty(Function.prototype,'name',{\n\nget:function get(){\n\nreturn this.toString().match(/^\\s*function\\s*([^\\(\\s]*)/)[1];\n\n}});\n\n\n\n}\n\nif(Object.assign===undefined){\n\n// Missing in IE.\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\n(function(){\n\nObject.assign=function(target){\n\n'use strict';\n\nif(target===undefined||target===null){\n\nthrow new TypeError('Cannot convert undefined or null to object');\n\n}\n\nvar output=Object(target);\n\nfor(var index=1;index<arguments.length;index++){\n\nvar source=arguments[index];\n\nif(source!==undefined&&source!==null){\n\nfor(var nextKey in source){\n\nif(Object.prototype.hasOwnProperty.call(source,nextKey)){\n\noutput[nextKey]=source[nextKey];\n\n}\n\n}\n\n}\n\n}\n\nreturn output;\n\n};\n\n})();\n\n}\n\n/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\nfunction EventDispatcher(){}\n\nEventDispatcher.prototype={\n\naddEventListener:function addEventListener(type,listener){\n\nif(this._listeners===undefined)this._listeners={};\n\nvar listeners=this._listeners;\n\nif(listeners[type]===undefined){\n\nlisteners[type]=[];\n\n}\n\nif(listeners[type].indexOf(listener)===-1){\n\nlisteners[type].push(listener);\n\n}\n\n},\n\nhasEventListener:function hasEventListener(type,listener){\n\nif(this._listeners===undefined)return false;\n\nvar listeners=this._listeners;\n\nreturn listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;\n\n},\n\nremoveEventListener:function removeEventListener(type,listener){\n\nif(this._listeners===undefined)return;\n\nvar listeners=this._listeners;\nvar listenerArray=listeners[type];\n\nif(listenerArray!==undefined){\n\nvar index=listenerArray.indexOf(listener);\n\nif(index!==-1){\n\nlistenerArray.splice(index,1);\n\n}\n\n}\n\n},\n\ndispatchEvent:function dispatchEvent(event){\n\nif(this._listeners===undefined)return;\n\nvar listeners=this._listeners;\nvar listenerArray=listeners[event.type];\n\nif(listenerArray!==undefined){\n\nevent.target=this;\n\nvar array=[],i=0;\nvar length=listenerArray.length;\n\nfor(i=0;i<length;i++){\n\narray[i]=listenerArray[i];\n\n}\n\nfor(i=0;i<length;i++){\n\narray[i].call(this,event);\n\n}\n\n}\n\n}};\n\n\n\nvar REVISION='84';\nvar MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};\nvar CullFaceNone=0;\nvar CullFaceBack=1;\nvar CullFaceFront=2;\nvar CullFaceFrontBack=3;\nvar FrontFaceDirectionCW=0;\nvar FrontFaceDirectionCCW=1;\nvar BasicShadowMap=0;\nvar PCFShadowMap=1;\nvar PCFSoftShadowMap=2;\nvar FrontSide=0;\nvar BackSide=1;\nvar DoubleSide=2;\nvar FlatShading=1;\nvar SmoothShading=2;\nvar NoColors=0;\nvar FaceColors=1;\nvar VertexColors=2;\nvar NoBlending=0;\nvar NormalBlending=1;\nvar AdditiveBlending=2;\nvar SubtractiveBlending=3;\nvar MultiplyBlending=4;\nvar CustomBlending=5;\nvar AddEquation=100;\nvar SubtractEquation=101;\nvar ReverseSubtractEquation=102;\nvar MinEquation=103;\nvar MaxEquation=104;\nvar ZeroFactor=200;\nvar OneFactor=201;\nvar SrcColorFactor=202;\nvar OneMinusSrcColorFactor=203;\nvar SrcAlphaFactor=204;\nvar OneMinusSrcAlphaFactor=205;\nvar DstAlphaFactor=206;\nvar OneMinusDstAlphaFactor=207;\nvar DstColorFactor=208;\nvar OneMinusDstColorFactor=209;\nvar SrcAlphaSaturateFactor=210;\nvar NeverDepth=0;\nvar AlwaysDepth=1;\nvar LessDepth=2;\nvar LessEqualDepth=3;\nvar EqualDepth=4;\nvar GreaterEqualDepth=5;\nvar GreaterDepth=6;\nvar NotEqualDepth=7;\nvar MultiplyOperation=0;\nvar MixOperation=1;\nvar AddOperation=2;\nvar NoToneMapping=0;\nvar LinearToneMapping=1;\nvar ReinhardToneMapping=2;\nvar Uncharted2ToneMapping=3;\nvar CineonToneMapping=4;\nvar UVMapping=300;\nvar CubeReflectionMapping=301;\nvar CubeRefractionMapping=302;\nvar EquirectangularReflectionMapping=303;\nvar EquirectangularRefractionMapping=304;\nvar SphericalReflectionMapping=305;\nvar CubeUVReflectionMapping=306;\nvar CubeUVRefractionMapping=307;\nvar RepeatWrapping=1000;\nvar ClampToEdgeWrapping=1001;\nvar MirroredRepeatWrapping=1002;\nvar NearestFilter=1003;\nvar NearestMipMapNearestFilter=1004;\nvar NearestMipMapLinearFilter=1005;\nvar LinearFilter=1006;\nvar LinearMipMapNearestFilter=1007;\nvar LinearMipMapLinearFilter=1008;\nvar UnsignedByteType=1009;\nvar ByteType=1010;\nvar ShortType=1011;\nvar UnsignedShortType=1012;\nvar IntType=1013;\nvar UnsignedIntType=1014;\nvar FloatType=1015;\nvar HalfFloatType=1016;\nvar UnsignedShort4444Type=1017;\nvar UnsignedShort5551Type=1018;\nvar UnsignedShort565Type=1019;\nvar UnsignedInt248Type=1020;\nvar AlphaFormat=1021;\nvar RGBFormat=1022;\nvar RGBAFormat=1023;\nvar LuminanceFormat=1024;\nvar LuminanceAlphaFormat=1025;\nvar RGBEFormat=RGBAFormat;\nvar DepthFormat=1026;\nvar DepthStencilFormat=1027;\nvar RGB_S3TC_DXT1_Format=2001;\nvar RGBA_S3TC_DXT1_Format=2002;\nvar RGBA_S3TC_DXT3_Format=2003;\nvar RGBA_S3TC_DXT5_Format=2004;\nvar RGB_PVRTC_4BPPV1_Format=2100;\nvar RGB_PVRTC_2BPPV1_Format=2101;\nvar RGBA_PVRTC_4BPPV1_Format=2102;\nvar RGBA_PVRTC_2BPPV1_Format=2103;\nvar RGB_ETC1_Format=2151;\nvar LoopOnce=2200;\nvar LoopRepeat=2201;\nvar LoopPingPong=2202;\nvar InterpolateDiscrete=2300;\nvar InterpolateLinear=2301;\nvar InterpolateSmooth=2302;\nvar ZeroCurvatureEnding=2400;\nvar ZeroSlopeEnding=2401;\nvar WrapAroundEnding=2402;\nvar TrianglesDrawMode=0;\nvar TriangleStripDrawMode=1;\nvar TriangleFanDrawMode=2;\nvar LinearEncoding=3000;\nvar sRGBEncoding=3001;\nvar GammaEncoding=3007;\nvar RGBEEncoding=3002;\nvar LogLuvEncoding=3003;\nvar RGBM7Encoding=3004;\nvar RGBM16Encoding=3005;\nvar RGBDEncoding=3006;\nvar BasicDepthPacking=3200;\nvar RGBADepthPacking=3201;\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nvar _Math={\n\nDEG2RAD:Math.PI/180,\nRAD2DEG:180/Math.PI,\n\ngenerateUUID:function(){\n\n// http://www.broofa.com/Tools/Math.uuid.htm\n\nvar chars='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\nvar uuid=new Array(36);\nvar rnd=0,r;\n\nreturn function generateUUID(){\n\nfor(var i=0;i<36;i++){\n\nif(i===8||i===13||i===18||i===23){\n\nuuid[i]='-';\n\n}else if(i===14){\n\nuuid[i]='4';\n\n}else{\n\nif(rnd<=0x02)rnd=0x2000000+Math.random()*0x1000000|0;\nr=rnd&0xf;\nrnd=rnd>>4;\nuuid[i]=chars[i===19?r&0x3|0x8:r];\n\n}\n\n}\n\nreturn uuid.join('');\n\n};\n\n}(),\n\nclamp:function clamp(value,min,max){\n\nreturn Math.max(min,Math.min(max,value));\n\n},\n\n// compute euclidian modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\n\neuclideanModulo:function euclideanModulo(n,m){\n\nreturn(n%m+m)%m;\n\n},\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\n\nmapLinear:function mapLinear(x,a1,a2,b1,b2){\n\nreturn b1+(x-a1)*(b2-b1)/(a2-a1);\n\n},\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\n\nlerp:function lerp(x,y,t){\n\nreturn(1-t)*x+t*y;\n\n},\n\n// http://en.wikipedia.org/wiki/Smoothstep\n\nsmoothstep:function smoothstep(x,min,max){\n\nif(x<=min)return 0;\nif(x>=max)return 1;\n\nx=(x-min)/(max-min);\n\nreturn x*x*(3-2*x);\n\n},\n\nsmootherstep:function smootherstep(x,min,max){\n\nif(x<=min)return 0;\nif(x>=max)return 1;\n\nx=(x-min)/(max-min);\n\nreturn x*x*x*(x*(x*6-15)+10);\n\n},\n\n// Random integer from <low, high> interval\n\nrandInt:function randInt(low,high){\n\nreturn low+Math.floor(Math.random()*(high-low+1));\n\n},\n\n// Random float from <low, high> interval\n\nrandFloat:function randFloat(low,high){\n\nreturn low+Math.random()*(high-low);\n\n},\n\n// Random float from <-range/2, range/2> interval\n\nrandFloatSpread:function randFloatSpread(range){\n\nreturn range*(0.5-Math.random());\n\n},\n\ndegToRad:function degToRad(degrees){\n\nreturn degrees*_Math.DEG2RAD;\n\n},\n\nradToDeg:function radToDeg(radians){\n\nreturn radians*_Math.RAD2DEG;\n\n},\n\nisPowerOfTwo:function isPowerOfTwo(value){\n\nreturn(value&value-1)===0&&value!==0;\n\n},\n\nnearestPowerOfTwo:function nearestPowerOfTwo(value){\n\nreturn Math.pow(2,Math.round(Math.log(value)/Math.LN2));\n\n},\n\nnextPowerOfTwo:function nextPowerOfTwo(value){\n\nvalue--;\nvalue|=value>>1;\nvalue|=value>>2;\nvalue|=value>>4;\nvalue|=value>>8;\nvalue|=value>>16;\nvalue++;\n\nreturn value;\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author egraether / http://egraether.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\nfunction Vector2(x,y){\n\nthis.x=x||0;\nthis.y=y||0;\n\n}\n\nVector2.prototype={\n\nconstructor:Vector2,\n\nisVector2:true,\n\nget width(){\n\nreturn this.x;\n\n},\n\nset width(value){\n\nthis.x=value;\n\n},\n\nget height(){\n\nreturn this.y;\n\n},\n\nset height(value){\n\nthis.y=value;\n\n},\n\n//\n\nset:function set(x,y){\n\nthis.x=x;\nthis.y=y;\n\nreturn this;\n\n},\n\nsetScalar:function setScalar(scalar){\n\nthis.x=scalar;\nthis.y=scalar;\n\nreturn this;\n\n},\n\nsetX:function setX(x){\n\nthis.x=x;\n\nreturn this;\n\n},\n\nsetY:function setY(y){\n\nthis.y=y;\n\nreturn this;\n\n},\n\nsetComponent:function setComponent(index,value){\n\nswitch(index){\n\ncase 0:this.x=value;break;\ncase 1:this.y=value;break;\ndefault:throw new Error('index is out of range: '+index);}\n\n\n\nreturn this;\n\n},\n\ngetComponent:function getComponent(index){\n\nswitch(index){\n\ncase 0:return this.x;\ncase 1:return this.y;\ndefault:throw new Error('index is out of range: '+index);}\n\n\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor(this.x,this.y);\n\n},\n\ncopy:function copy(v){\n\nthis.x=v.x;\nthis.y=v.y;\n\nreturn this;\n\n},\n\nadd:function add(v,w){\n\nif(w!==undefined){\n\nconsole.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\nreturn this.addVectors(v,w);\n\n}\n\nthis.x+=v.x;\nthis.y+=v.y;\n\nreturn this;\n\n},\n\naddScalar:function addScalar(s){\n\nthis.x+=s;\nthis.y+=s;\n\nreturn this;\n\n},\n\naddVectors:function addVectors(a,b){\n\nthis.x=a.x+b.x;\nthis.y=a.y+b.y;\n\nreturn this;\n\n},\n\naddScaledVector:function addScaledVector(v,s){\n\nthis.x+=v.x*s;\nthis.y+=v.y*s;\n\nreturn this;\n\n},\n\nsub:function sub(v,w){\n\nif(w!==undefined){\n\nconsole.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\nreturn this.subVectors(v,w);\n\n}\n\nthis.x-=v.x;\nthis.y-=v.y;\n\nreturn this;\n\n},\n\nsubScalar:function subScalar(s){\n\nthis.x-=s;\nthis.y-=s;\n\nreturn this;\n\n},\n\nsubVectors:function subVectors(a,b){\n\nthis.x=a.x-b.x;\nthis.y=a.y-b.y;\n\nreturn this;\n\n},\n\nmultiply:function multiply(v){\n\nthis.x*=v.x;\nthis.y*=v.y;\n\nreturn this;\n\n},\n\nmultiplyScalar:function multiplyScalar(scalar){\n\nif(isFinite(scalar)){\n\nthis.x*=scalar;\nthis.y*=scalar;\n\n}else{\n\nthis.x=0;\nthis.y=0;\n\n}\n\nreturn this;\n\n},\n\ndivide:function divide(v){\n\nthis.x/=v.x;\nthis.y/=v.y;\n\nreturn this;\n\n},\n\ndivideScalar:function divideScalar(scalar){\n\nreturn this.multiplyScalar(1/scalar);\n\n},\n\nmin:function min(v){\n\nthis.x=Math.min(this.x,v.x);\nthis.y=Math.min(this.y,v.y);\n\nreturn this;\n\n},\n\nmax:function max(v){\n\nthis.x=Math.max(this.x,v.x);\nthis.y=Math.max(this.y,v.y);\n\nreturn this;\n\n},\n\nclamp:function clamp(min,max){\n\n// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\nthis.x=Math.max(min.x,Math.min(max.x,this.x));\nthis.y=Math.max(min.y,Math.min(max.y,this.y));\n\nreturn this;\n\n},\n\nclampScalar:function(){\n\nvar min,max;\n\nreturn function clampScalar(minVal,maxVal){\n\nif(min===undefined){\n\nmin=new Vector2();\nmax=new Vector2();\n\n}\n\nmin.set(minVal,minVal);\nmax.set(maxVal,maxVal);\n\nreturn this.clamp(min,max);\n\n};\n\n}(),\n\nclampLength:function clampLength(min,max){\n\nvar length=this.length();\n\nreturn this.multiplyScalar(Math.max(min,Math.min(max,length))/length);\n\n},\n\nfloor:function floor(){\n\nthis.x=Math.floor(this.x);\nthis.y=Math.floor(this.y);\n\nreturn this;\n\n},\n\nceil:function ceil(){\n\nthis.x=Math.ceil(this.x);\nthis.y=Math.ceil(this.y);\n\nreturn this;\n\n},\n\nround:function round(){\n\nthis.x=Math.round(this.x);\nthis.y=Math.round(this.y);\n\nreturn this;\n\n},\n\nroundToZero:function roundToZero(){\n\nthis.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);\nthis.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);\n\nreturn this;\n\n},\n\nnegate:function negate(){\n\nthis.x=-this.x;\nthis.y=-this.y;\n\nreturn this;\n\n},\n\ndot:function dot(v){\n\nreturn this.x*v.x+this.y*v.y;\n\n},\n\nlengthSq:function lengthSq(){\n\nreturn this.x*this.x+this.y*this.y;\n\n},\n\nlength:function length(){\n\nreturn Math.sqrt(this.x*this.x+this.y*this.y);\n\n},\n\nlengthManhattan:function lengthManhattan(){\n\nreturn Math.abs(this.x)+Math.abs(this.y);\n\n},\n\nnormalize:function normalize(){\n\nreturn this.divideScalar(this.length());\n\n},\n\nangle:function angle(){\n\n// computes the angle in radians with respect to the positive x-axis\n\nvar angle=Math.atan2(this.y,this.x);\n\nif(angle<0)angle+=2*Math.PI;\n\nreturn angle;\n\n},\n\ndistanceTo:function distanceTo(v){\n\nreturn Math.sqrt(this.distanceToSquared(v));\n\n},\n\ndistanceToSquared:function distanceToSquared(v){\n\nvar dx=this.x-v.x,dy=this.y-v.y;\nreturn dx*dx+dy*dy;\n\n},\n\ndistanceToManhattan:function distanceToManhattan(v){\n\nreturn Math.abs(this.x-v.x)+Math.abs(this.y-v.y);\n\n},\n\nsetLength:function setLength(length){\n\nreturn this.multiplyScalar(length/this.length());\n\n},\n\nlerp:function lerp(v,alpha){\n\nthis.x+=(v.x-this.x)*alpha;\nthis.y+=(v.y-this.y)*alpha;\n\nreturn this;\n\n},\n\nlerpVectors:function lerpVectors(v1,v2,alpha){\n\nreturn this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);\n\n},\n\nequals:function equals(v){\n\nreturn v.x===this.x&&v.y===this.y;\n\n},\n\nfromArray:function fromArray(array,offset){\n\nif(offset===undefined)offset=0;\n\nthis.x=array[offset];\nthis.y=array[offset+1];\n\nreturn this;\n\n},\n\ntoArray:function toArray(array,offset){\n\nif(array===undefined)array=[];\nif(offset===undefined)offset=0;\n\narray[offset]=this.x;\narray[offset+1]=this.y;\n\nreturn array;\n\n},\n\nfromBufferAttribute:function fromBufferAttribute(attribute,index,offset){\n\nif(offset!==undefined){\n\nconsole.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');\n\n}\n\nthis.x=attribute.getX(index);\nthis.y=attribute.getY(index);\n\nreturn this;\n\n},\n\nrotateAround:function rotateAround(center,angle){\n\nvar c=Math.cos(angle),s=Math.sin(angle);\n\nvar x=this.x-center.x;\nvar y=this.y-center.y;\n\nthis.x=x*c-y*s+center.x;\nthis.y=x*s+y*c+center.y;\n\nreturn this;\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t */\n\nvar textureId=0;\n\nfunction Texture(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){\n\nObject.defineProperty(this,'id',{value:textureId++});\n\nthis.uuid=_Math.generateUUID();\n\nthis.name='';\n\nthis.image=image!==undefined?image:Texture.DEFAULT_IMAGE;\nthis.mipmaps=[];\n\nthis.mapping=mapping!==undefined?mapping:Texture.DEFAULT_MAPPING;\n\nthis.wrapS=wrapS!==undefined?wrapS:ClampToEdgeWrapping;\nthis.wrapT=wrapT!==undefined?wrapT:ClampToEdgeWrapping;\n\nthis.magFilter=magFilter!==undefined?magFilter:LinearFilter;\nthis.minFilter=minFilter!==undefined?minFilter:LinearMipMapLinearFilter;\n\nthis.anisotropy=anisotropy!==undefined?anisotropy:1;\n\nthis.format=format!==undefined?format:RGBAFormat;\nthis.type=type!==undefined?type:UnsignedByteType;\n\nthis.offset=new Vector2(0,0);\nthis.repeat=new Vector2(1,1);\n\nthis.generateMipmaps=true;\nthis.premultiplyAlpha=false;\nthis.flipY=true;\nthis.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\n// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n//\n// Also changing the encoding after already used by a Material will not automatically make the Material\n// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\nthis.encoding=encoding!==undefined?encoding:LinearEncoding;\n\nthis.version=0;\nthis.onUpdate=null;\n\n}\n\nTexture.DEFAULT_IMAGE=undefined;\nTexture.DEFAULT_MAPPING=UVMapping;\n\nTexture.prototype={\n\nconstructor:Texture,\n\nisTexture:true,\n\nset needsUpdate(value){\n\nif(value===true)this.version++;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(source){\n\nthis.image=source.image;\nthis.mipmaps=source.mipmaps.slice(0);\n\nthis.mapping=source.mapping;\n\nthis.wrapS=source.wrapS;\nthis.wrapT=source.wrapT;\n\nthis.magFilter=source.magFilter;\nthis.minFilter=source.minFilter;\n\nthis.anisotropy=source.anisotropy;\n\nthis.format=source.format;\nthis.type=source.type;\n\nthis.offset.copy(source.offset);\nthis.repeat.copy(source.repeat);\n\nthis.generateMipmaps=source.generateMipmaps;\nthis.premultiplyAlpha=source.premultiplyAlpha;\nthis.flipY=source.flipY;\nthis.unpackAlignment=source.unpackAlignment;\nthis.encoding=source.encoding;\n\nreturn this;\n\n},\n\ntoJSON:function toJSON(meta){\n\nif(meta.textures[this.uuid]!==undefined){\n\nreturn meta.textures[this.uuid];\n\n}\n\nfunction getDataURL(image){\n\nvar canvas;\n\nif(image.toDataURL!==undefined){\n\ncanvas=image;\n\n}else{\n\ncanvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');\ncanvas.width=image.width;\ncanvas.height=image.height;\n\ncanvas.getContext('2d').drawImage(image,0,0,image.width,image.height);\n\n}\n\nif(canvas.width>2048||canvas.height>2048){\n\nreturn canvas.toDataURL('image/jpeg',0.6);\n\n}else{\n\nreturn canvas.toDataURL('image/png');\n\n}\n\n}\n\nvar output={\nmetadata:{\nversion:4.4,\ntype:'Texture',\ngenerator:'Texture.toJSON'},\n\n\nuuid:this.uuid,\nname:this.name,\n\nmapping:this.mapping,\n\nrepeat:[this.repeat.x,this.repeat.y],\noffset:[this.offset.x,this.offset.y],\nwrap:[this.wrapS,this.wrapT],\n\nminFilter:this.minFilter,\nmagFilter:this.magFilter,\nanisotropy:this.anisotropy,\n\nflipY:this.flipY};\n\n\nif(this.image!==undefined){\n\n// TODO: Move to THREE.Image\n\nvar image=this.image;\n\nif(image.uuid===undefined){\n\nimage.uuid=_Math.generateUUID();// UGH\n\n}\n\nif(meta.images[image.uuid]===undefined){\n\nmeta.images[image.uuid]={\nuuid:image.uuid,\nurl:getDataURL(image)};\n\n\n}\n\noutput.image=image.uuid;\n\n}\n\nmeta.textures[this.uuid]=output;\n\nreturn output;\n\n},\n\ndispose:function dispose(){\n\nthis.dispatchEvent({type:'dispose'});\n\n},\n\ntransformUv:function transformUv(uv){\n\nif(this.mapping!==UVMapping)return;\n\nuv.multiply(this.repeat);\nuv.add(this.offset);\n\nif(uv.x<0||uv.x>1){\n\nswitch(this.wrapS){\n\ncase RepeatWrapping:\n\nuv.x=uv.x-Math.floor(uv.x);\nbreak;\n\ncase ClampToEdgeWrapping:\n\nuv.x=uv.x<0?0:1;\nbreak;\n\ncase MirroredRepeatWrapping:\n\nif(Math.abs(Math.floor(uv.x)%2)===1){\n\nuv.x=Math.ceil(uv.x)-uv.x;\n\n}else{\n\nuv.x=uv.x-Math.floor(uv.x);\n\n}\nbreak;}\n\n\n\n}\n\nif(uv.y<0||uv.y>1){\n\nswitch(this.wrapT){\n\ncase RepeatWrapping:\n\nuv.y=uv.y-Math.floor(uv.y);\nbreak;\n\ncase ClampToEdgeWrapping:\n\nuv.y=uv.y<0?0:1;\nbreak;\n\ncase MirroredRepeatWrapping:\n\nif(Math.abs(Math.floor(uv.y)%2)===1){\n\nuv.y=Math.ceil(uv.y)-uv.y;\n\n}else{\n\nuv.y=uv.y-Math.floor(uv.y);\n\n}\nbreak;}\n\n\n\n}\n\nif(this.flipY){\n\nuv.y=1-uv.y;\n\n}\n\n}};\n\n\n\nObject.assign(Texture.prototype,EventDispatcher.prototype);\n\n/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\nfunction Vector4(x,y,z,w){\n\nthis.x=x||0;\nthis.y=y||0;\nthis.z=z||0;\nthis.w=w!==undefined?w:1;\n\n}\n\nVector4.prototype={\n\nconstructor:Vector4,\n\nisVector4:true,\n\nset:function set(x,y,z,w){\n\nthis.x=x;\nthis.y=y;\nthis.z=z;\nthis.w=w;\n\nreturn this;\n\n},\n\nsetScalar:function setScalar(scalar){\n\nthis.x=scalar;\nthis.y=scalar;\nthis.z=scalar;\nthis.w=scalar;\n\nreturn this;\n\n},\n\nsetX:function setX(x){\n\nthis.x=x;\n\nreturn this;\n\n},\n\nsetY:function setY(y){\n\nthis.y=y;\n\nreturn this;\n\n},\n\nsetZ:function setZ(z){\n\nthis.z=z;\n\nreturn this;\n\n},\n\nsetW:function setW(w){\n\nthis.w=w;\n\nreturn this;\n\n},\n\nsetComponent:function setComponent(index,value){\n\nswitch(index){\n\ncase 0:this.x=value;break;\ncase 1:this.y=value;break;\ncase 2:this.z=value;break;\ncase 3:this.w=value;break;\ndefault:throw new Error('index is out of range: '+index);}\n\n\n\nreturn this;\n\n},\n\ngetComponent:function getComponent(index){\n\nswitch(index){\n\ncase 0:return this.x;\ncase 1:return this.y;\ncase 2:return this.z;\ncase 3:return this.w;\ndefault:throw new Error('index is out of range: '+index);}\n\n\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor(this.x,this.y,this.z,this.w);\n\n},\n\ncopy:function copy(v){\n\nthis.x=v.x;\nthis.y=v.y;\nthis.z=v.z;\nthis.w=v.w!==undefined?v.w:1;\n\nreturn this;\n\n},\n\nadd:function add(v,w){\n\nif(w!==undefined){\n\nconsole.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\nreturn this.addVectors(v,w);\n\n}\n\nthis.x+=v.x;\nthis.y+=v.y;\nthis.z+=v.z;\nthis.w+=v.w;\n\nreturn this;\n\n},\n\naddScalar:function addScalar(s){\n\nthis.x+=s;\nthis.y+=s;\nthis.z+=s;\nthis.w+=s;\n\nreturn this;\n\n},\n\naddVectors:function addVectors(a,b){\n\nthis.x=a.x+b.x;\nthis.y=a.y+b.y;\nthis.z=a.z+b.z;\nthis.w=a.w+b.w;\n\nreturn this;\n\n},\n\naddScaledVector:function addScaledVector(v,s){\n\nthis.x+=v.x*s;\nthis.y+=v.y*s;\nthis.z+=v.z*s;\nthis.w+=v.w*s;\n\nreturn this;\n\n},\n\nsub:function sub(v,w){\n\nif(w!==undefined){\n\nconsole.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\nreturn this.subVectors(v,w);\n\n}\n\nthis.x-=v.x;\nthis.y-=v.y;\nthis.z-=v.z;\nthis.w-=v.w;\n\nreturn this;\n\n},\n\nsubScalar:function subScalar(s){\n\nthis.x-=s;\nthis.y-=s;\nthis.z-=s;\nthis.w-=s;\n\nreturn this;\n\n},\n\nsubVectors:function subVectors(a,b){\n\nthis.x=a.x-b.x;\nthis.y=a.y-b.y;\nthis.z=a.z-b.z;\nthis.w=a.w-b.w;\n\nreturn this;\n\n},\n\nmultiplyScalar:function multiplyScalar(scalar){\n\nif(isFinite(scalar)){\n\nthis.x*=scalar;\nthis.y*=scalar;\nthis.z*=scalar;\nthis.w*=scalar;\n\n}else{\n\nthis.x=0;\nthis.y=0;\nthis.z=0;\nthis.w=0;\n\n}\n\nreturn this;\n\n},\n\napplyMatrix4:function applyMatrix4(m){\n\nvar x=this.x,y=this.y,z=this.z,w=this.w;\nvar e=m.elements;\n\nthis.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;\nthis.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;\nthis.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;\nthis.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;\n\nreturn this;\n\n},\n\ndivideScalar:function divideScalar(scalar){\n\nreturn this.multiplyScalar(1/scalar);\n\n},\n\nsetAxisAngleFromQuaternion:function setAxisAngleFromQuaternion(q){\n\n// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n// q is assumed to be normalized\n\nthis.w=2*Math.acos(q.w);\n\nvar s=Math.sqrt(1-q.w*q.w);\n\nif(s<0.0001){\n\nthis.x=1;\nthis.y=0;\nthis.z=0;\n\n}else{\n\nthis.x=q.x/s;\nthis.y=q.y/s;\nthis.z=q.z/s;\n\n}\n\nreturn this;\n\n},\n\nsetAxisAngleFromRotationMatrix:function setAxisAngleFromRotationMatrix(m){\n\n// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\nvar angle,x,y,z,// variables for result\nepsilon=0.01,// margin to allow for rounding errors\nepsilon2=0.1,// margin to distinguish between 0 and 180 degrees\n\nte=m.elements,\n\nm11=te[0],m12=te[4],m13=te[8],\nm21=te[1],m22=te[5],m23=te[9],\nm31=te[2],m32=te[6],m33=te[10];\n\nif(Math.abs(m12-m21)<epsilon&&\nMath.abs(m13-m31)<epsilon&&\nMath.abs(m23-m32)<epsilon){\n\n// singularity found\n// first check for identity matrix which must have +1 for all terms\n// in leading diagonal and zero in other terms\n\nif(Math.abs(m12+m21)<epsilon2&&\nMath.abs(m13+m31)<epsilon2&&\nMath.abs(m23+m32)<epsilon2&&\nMath.abs(m11+m22+m33-3)<epsilon2){\n\n// this singularity is identity matrix so angle = 0\n\nthis.set(1,0,0,0);\n\nreturn this;// zero angle, arbitrary axis\n\n}\n\n// otherwise this singularity is angle = 180\n\nangle=Math.PI;\n\nvar xx=(m11+1)/2;\nvar yy=(m22+1)/2;\nvar zz=(m33+1)/2;\nvar xy=(m12+m21)/4;\nvar xz=(m13+m31)/4;\nvar yz=(m23+m32)/4;\n\nif(xx>yy&&xx>zz){\n\n// m11 is the largest diagonal term\n\nif(xx<epsilon){\n\nx=0;\ny=0.707106781;\nz=0.707106781;\n\n}else{\n\nx=Math.sqrt(xx);\ny=xy/x;\nz=xz/x;\n\n}\n\n}else if(yy>zz){\n\n// m22 is the largest diagonal term\n\nif(yy<epsilon){\n\nx=0.707106781;\ny=0;\nz=0.707106781;\n\n}else{\n\ny=Math.sqrt(yy);\nx=xy/y;\nz=yz/y;\n\n}\n\n}else{\n\n// m33 is the largest diagonal term so base result on this\n\nif(zz<epsilon){\n\nx=0.707106781;\ny=0.707106781;\nz=0;\n\n}else{\n\nz=Math.sqrt(zz);\nx=xz/z;\ny=yz/z;\n\n}\n\n}\n\nthis.set(x,y,z,angle);\n\nreturn this;// return 180 deg rotation\n\n}\n\n// as we have reached here there are no singularities so we can handle normally\n\nvar s=Math.sqrt((m32-m23)*(m32-m23)+\n(m13-m31)*(m13-m31)+\n(m21-m12)*(m21-m12));// used to normalize\n\nif(Math.abs(s)<0.001)s=1;\n\n// prevent divide by zero, should not happen if matrix is orthogonal and should be\n// caught by singularity test above, but I've left it in just in case\n\nthis.x=(m32-m23)/s;\nthis.y=(m13-m31)/s;\nthis.z=(m21-m12)/s;\nthis.w=Math.acos((m11+m22+m33-1)/2);\n\nreturn this;\n\n},\n\nmin:function min(v){\n\nthis.x=Math.min(this.x,v.x);\nthis.y=Math.min(this.y,v.y);\nthis.z=Math.min(this.z,v.z);\nthis.w=Math.min(this.w,v.w);\n\nreturn this;\n\n},\n\nmax:function max(v){\n\nthis.x=Math.max(this.x,v.x);\nthis.y=Math.max(this.y,v.y);\nthis.z=Math.max(this.z,v.z);\nthis.w=Math.max(this.w,v.w);\n\nreturn this;\n\n},\n\nclamp:function clamp(min,max){\n\n// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\nthis.x=Math.max(min.x,Math.min(max.x,this.x));\nthis.y=Math.max(min.y,Math.min(max.y,this.y));\nthis.z=Math.max(min.z,Math.min(max.z,this.z));\nthis.w=Math.max(min.w,Math.min(max.w,this.w));\n\nreturn this;\n\n},\n\nclampScalar:function(){\n\nvar min,max;\n\nreturn function clampScalar(minVal,maxVal){\n\nif(min===undefined){\n\nmin=new Vector4();\nmax=new Vector4();\n\n}\n\nmin.set(minVal,minVal,minVal,minVal);\nmax.set(maxVal,maxVal,maxVal,maxVal);\n\nreturn this.clamp(min,max);\n\n};\n\n}(),\n\nfloor:function floor(){\n\nthis.x=Math.floor(this.x);\nthis.y=Math.floor(this.y);\nthis.z=Math.floor(this.z);\nthis.w=Math.floor(this.w);\n\nreturn this;\n\n},\n\nceil:function ceil(){\n\nthis.x=Math.ceil(this.x);\nthis.y=Math.ceil(this.y);\nthis.z=Math.ceil(this.z);\nthis.w=Math.ceil(this.w);\n\nreturn this;\n\n},\n\nround:function round(){\n\nthis.x=Math.round(this.x);\nthis.y=Math.round(this.y);\nthis.z=Math.round(this.z);\nthis.w=Math.round(this.w);\n\nreturn this;\n\n},\n\nroundToZero:function roundToZero(){\n\nthis.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);\nthis.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);\nthis.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);\nthis.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);\n\nreturn this;\n\n},\n\nnegate:function negate(){\n\nthis.x=-this.x;\nthis.y=-this.y;\nthis.z=-this.z;\nthis.w=-this.w;\n\nreturn this;\n\n},\n\ndot:function dot(v){\n\nreturn this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;\n\n},\n\nlengthSq:function lengthSq(){\n\nreturn this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;\n\n},\n\nlength:function length(){\n\nreturn Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);\n\n},\n\nlengthManhattan:function lengthManhattan(){\n\nreturn Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);\n\n},\n\nnormalize:function normalize(){\n\nreturn this.divideScalar(this.length());\n\n},\n\nsetLength:function setLength(length){\n\nreturn this.multiplyScalar(length/this.length());\n\n},\n\nlerp:function lerp(v,alpha){\n\nthis.x+=(v.x-this.x)*alpha;\nthis.y+=(v.y-this.y)*alpha;\nthis.z+=(v.z-this.z)*alpha;\nthis.w+=(v.w-this.w)*alpha;\n\nreturn this;\n\n},\n\nlerpVectors:function lerpVectors(v1,v2,alpha){\n\nreturn this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);\n\n},\n\nequals:function equals(v){\n\nreturn v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;\n\n},\n\nfromArray:function fromArray(array,offset){\n\nif(offset===undefined)offset=0;\n\nthis.x=array[offset];\nthis.y=array[offset+1];\nthis.z=array[offset+2];\nthis.w=array[offset+3];\n\nreturn this;\n\n},\n\ntoArray:function toArray(array,offset){\n\nif(array===undefined)array=[];\nif(offset===undefined)offset=0;\n\narray[offset]=this.x;\narray[offset+1]=this.y;\narray[offset+2]=this.z;\narray[offset+3]=this.w;\n\nreturn array;\n\n},\n\nfromBufferAttribute:function fromBufferAttribute(attribute,index,offset){\n\nif(offset!==undefined){\n\nconsole.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');\n\n}\n\nthis.x=attribute.getX(index);\nthis.y=attribute.getY(index);\nthis.z=attribute.getZ(index);\nthis.w=attribute.getW(index);\n\nreturn this;\n\n}};\n\n\n\n/**\n\t * @author szimek / https://github.com/szimek/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Marius Kintel / https://github.com/kintel\n\t */\n\n/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\nfunction WebGLRenderTarget(width,height,options){\n\nthis.uuid=_Math.generateUUID();\n\nthis.width=width;\nthis.height=height;\n\nthis.scissor=new Vector4(0,0,width,height);\nthis.scissorTest=false;\n\nthis.viewport=new Vector4(0,0,width,height);\n\noptions=options||{};\n\nif(options.minFilter===undefined)options.minFilter=LinearFilter;\n\nthis.texture=new Texture(undefined,undefined,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);\n\nthis.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;\nthis.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:true;\nthis.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;\n\n}\n\nWebGLRenderTarget.prototype={\n\nconstructor:WebGLRenderTarget,\n\nisWebGLRenderTarget:true,\n\nsetSize:function setSize(width,height){\n\nif(this.width!==width||this.height!==height){\n\nthis.width=width;\nthis.height=height;\n\nthis.dispose();\n\n}\n\nthis.viewport.set(0,0,width,height);\nthis.scissor.set(0,0,width,height);\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(source){\n\nthis.width=source.width;\nthis.height=source.height;\n\nthis.viewport.copy(source.viewport);\n\nthis.texture=source.texture.clone();\n\nthis.depthBuffer=source.depthBuffer;\nthis.stencilBuffer=source.stencilBuffer;\nthis.depthTexture=source.depthTexture;\n\nreturn this;\n\n},\n\ndispose:function dispose(){\n\nthis.dispatchEvent({type:'dispose'});\n\n}};\n\n\n\nObject.assign(WebGLRenderTarget.prototype,EventDispatcher.prototype);\n\n/**\n\t * @author alteredq / http://alteredqualia.com\n\t */\n\nfunction WebGLRenderTargetCube(width,height,options){\n\nWebGLRenderTarget.call(this,width,height,options);\n\nthis.activeCubeFace=0;// PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\nthis.activeMipMapLevel=0;\n\n}\n\nWebGLRenderTargetCube.prototype=Object.create(WebGLRenderTarget.prototype);\nWebGLRenderTargetCube.prototype.constructor=WebGLRenderTargetCube;\n\nWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube=true;\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\nfunction Quaternion(x,y,z,w){\n\nthis._x=x||0;\nthis._y=y||0;\nthis._z=z||0;\nthis._w=w!==undefined?w:1;\n\n}\n\nQuaternion.prototype={\n\nconstructor:Quaternion,\n\nget x(){\n\nreturn this._x;\n\n},\n\nset x(value){\n\nthis._x=value;\nthis.onChangeCallback();\n\n},\n\nget y(){\n\nreturn this._y;\n\n},\n\nset y(value){\n\nthis._y=value;\nthis.onChangeCallback();\n\n},\n\nget z(){\n\nreturn this._z;\n\n},\n\nset z(value){\n\nthis._z=value;\nthis.onChangeCallback();\n\n},\n\nget w(){\n\nreturn this._w;\n\n},\n\nset w(value){\n\nthis._w=value;\nthis.onChangeCallback();\n\n},\n\nset:function set(x,y,z,w){\n\nthis._x=x;\nthis._y=y;\nthis._z=z;\nthis._w=w;\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor(this._x,this._y,this._z,this._w);\n\n},\n\ncopy:function copy(quaternion){\n\nthis._x=quaternion.x;\nthis._y=quaternion.y;\nthis._z=quaternion.z;\nthis._w=quaternion.w;\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nsetFromEuler:function setFromEuler(euler,update){\n\nif((euler&&euler.isEuler)===false){\n\nthrow new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\n}\n\n// http://www.mathworks.com/matlabcentral/fileexchange/\n// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n//\tcontent/SpinCalc.m\n\nvar c1=Math.cos(euler._x/2);\nvar c2=Math.cos(euler._y/2);\nvar c3=Math.cos(euler._z/2);\nvar s1=Math.sin(euler._x/2);\nvar s2=Math.sin(euler._y/2);\nvar s3=Math.sin(euler._z/2);\n\nvar order=euler.order;\n\nif(order==='XYZ'){\n\nthis._x=s1*c2*c3+c1*s2*s3;\nthis._y=c1*s2*c3-s1*c2*s3;\nthis._z=c1*c2*s3+s1*s2*c3;\nthis._w=c1*c2*c3-s1*s2*s3;\n\n}else if(order==='YXZ'){\n\nthis._x=s1*c2*c3+c1*s2*s3;\nthis._y=c1*s2*c3-s1*c2*s3;\nthis._z=c1*c2*s3-s1*s2*c3;\nthis._w=c1*c2*c3+s1*s2*s3;\n\n}else if(order==='ZXY'){\n\nthis._x=s1*c2*c3-c1*s2*s3;\nthis._y=c1*s2*c3+s1*c2*s3;\nthis._z=c1*c2*s3+s1*s2*c3;\nthis._w=c1*c2*c3-s1*s2*s3;\n\n}else if(order==='ZYX'){\n\nthis._x=s1*c2*c3-c1*s2*s3;\nthis._y=c1*s2*c3+s1*c2*s3;\nthis._z=c1*c2*s3-s1*s2*c3;\nthis._w=c1*c2*c3+s1*s2*s3;\n\n}else if(order==='YZX'){\n\nthis._x=s1*c2*c3+c1*s2*s3;\nthis._y=c1*s2*c3+s1*c2*s3;\nthis._z=c1*c2*s3-s1*s2*c3;\nthis._w=c1*c2*c3-s1*s2*s3;\n\n}else if(order==='XZY'){\n\nthis._x=s1*c2*c3-c1*s2*s3;\nthis._y=c1*s2*c3-s1*c2*s3;\nthis._z=c1*c2*s3+s1*s2*c3;\nthis._w=c1*c2*c3+s1*s2*s3;\n\n}\n\nif(update!==false)this.onChangeCallback();\n\nreturn this;\n\n},\n\nsetFromAxisAngle:function setFromAxisAngle(axis,angle){\n\n// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n// assumes axis is normalized\n\nvar halfAngle=angle/2,s=Math.sin(halfAngle);\n\nthis._x=axis.x*s;\nthis._y=axis.y*s;\nthis._z=axis.z*s;\nthis._w=Math.cos(halfAngle);\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nsetFromRotationMatrix:function setFromRotationMatrix(m){\n\n// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\nvar te=m.elements,\n\nm11=te[0],m12=te[4],m13=te[8],\nm21=te[1],m22=te[5],m23=te[9],\nm31=te[2],m32=te[6],m33=te[10],\n\ntrace=m11+m22+m33,\ns;\n\nif(trace>0){\n\ns=0.5/Math.sqrt(trace+1.0);\n\nthis._w=0.25/s;\nthis._x=(m32-m23)*s;\nthis._y=(m13-m31)*s;\nthis._z=(m21-m12)*s;\n\n}else if(m11>m22&&m11>m33){\n\ns=2.0*Math.sqrt(1.0+m11-m22-m33);\n\nthis._w=(m32-m23)/s;\nthis._x=0.25*s;\nthis._y=(m12+m21)/s;\nthis._z=(m13+m31)/s;\n\n}else if(m22>m33){\n\ns=2.0*Math.sqrt(1.0+m22-m11-m33);\n\nthis._w=(m13-m31)/s;\nthis._x=(m12+m21)/s;\nthis._y=0.25*s;\nthis._z=(m23+m32)/s;\n\n}else{\n\ns=2.0*Math.sqrt(1.0+m33-m11-m22);\n\nthis._w=(m21-m12)/s;\nthis._x=(m13+m31)/s;\nthis._y=(m23+m32)/s;\nthis._z=0.25*s;\n\n}\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nsetFromUnitVectors:function(){\n\n// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\n\n// assumes direction vectors vFrom and vTo are normalized\n\nvar v1,r;\n\nvar EPS=0.000001;\n\nreturn function setFromUnitVectors(vFrom,vTo){\n\nif(v1===undefined)v1=new Vector3();\n\nr=vFrom.dot(vTo)+1;\n\nif(r<EPS){\n\nr=0;\n\nif(Math.abs(vFrom.x)>Math.abs(vFrom.z)){\n\nv1.set(-vFrom.y,vFrom.x,0);\n\n}else{\n\nv1.set(0,-vFrom.z,vFrom.y);\n\n}\n\n}else{\n\nv1.crossVectors(vFrom,vTo);\n\n}\n\nthis._x=v1.x;\nthis._y=v1.y;\nthis._z=v1.z;\nthis._w=r;\n\nreturn this.normalize();\n\n};\n\n}(),\n\ninverse:function inverse(){\n\nreturn this.conjugate().normalize();\n\n},\n\nconjugate:function conjugate(){\n\nthis._x*=-1;\nthis._y*=-1;\nthis._z*=-1;\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\ndot:function dot(v){\n\nreturn this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;\n\n},\n\nlengthSq:function lengthSq(){\n\nreturn this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;\n\n},\n\nlength:function length(){\n\nreturn Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);\n\n},\n\nnormalize:function normalize(){\n\nvar l=this.length();\n\nif(l===0){\n\nthis._x=0;\nthis._y=0;\nthis._z=0;\nthis._w=1;\n\n}else{\n\nl=1/l;\n\nthis._x=this._x*l;\nthis._y=this._y*l;\nthis._z=this._z*l;\nthis._w=this._w*l;\n\n}\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nmultiply:function multiply(q,p){\n\nif(p!==undefined){\n\nconsole.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\nreturn this.multiplyQuaternions(q,p);\n\n}\n\nreturn this.multiplyQuaternions(this,q);\n\n},\n\npremultiply:function premultiply(q){\n\nreturn this.multiplyQuaternions(q,this);\n\n},\n\nmultiplyQuaternions:function multiplyQuaternions(a,b){\n\n// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\nvar qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;\nvar qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;\n\nthis._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;\nthis._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;\nthis._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;\nthis._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nslerp:function slerp(qb,t){\n\nif(t===0)return this;\nif(t===1)return this.copy(qb);\n\nvar x=this._x,y=this._y,z=this._z,w=this._w;\n\n// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\nvar cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;\n\nif(cosHalfTheta<0){\n\nthis._w=-qb._w;\nthis._x=-qb._x;\nthis._y=-qb._y;\nthis._z=-qb._z;\n\ncosHalfTheta=-cosHalfTheta;\n\n}else{\n\nthis.copy(qb);\n\n}\n\nif(cosHalfTheta>=1.0){\n\nthis._w=w;\nthis._x=x;\nthis._y=y;\nthis._z=z;\n\nreturn this;\n\n}\n\nvar sinHalfTheta=Math.sqrt(1.0-cosHalfTheta*cosHalfTheta);\n\nif(Math.abs(sinHalfTheta)<0.001){\n\nthis._w=0.5*(w+this._w);\nthis._x=0.5*(x+this._x);\nthis._y=0.5*(y+this._y);\nthis._z=0.5*(z+this._z);\n\nreturn this;\n\n}\n\nvar halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);\nvar ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,\nratioB=Math.sin(t*halfTheta)/sinHalfTheta;\n\nthis._w=w*ratioA+this._w*ratioB;\nthis._x=x*ratioA+this._x*ratioB;\nthis._y=y*ratioA+this._y*ratioB;\nthis._z=z*ratioA+this._z*ratioB;\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nequals:function equals(quaternion){\n\nreturn quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;\n\n},\n\nfromArray:function fromArray(array,offset){\n\nif(offset===undefined)offset=0;\n\nthis._x=array[offset];\nthis._y=array[offset+1];\nthis._z=array[offset+2];\nthis._w=array[offset+3];\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\ntoArray:function toArray(array,offset){\n\nif(array===undefined)array=[];\nif(offset===undefined)offset=0;\n\narray[offset]=this._x;\narray[offset+1]=this._y;\narray[offset+2]=this._z;\narray[offset+3]=this._w;\n\nreturn array;\n\n},\n\nonChange:function onChange(callback){\n\nthis.onChangeCallback=callback;\n\nreturn this;\n\n},\n\nonChangeCallback:function onChangeCallback(){}};\n\n\n\nObject.assign(Quaternion,{\n\nslerp:function slerp(qa,qb,qm,t){\n\nreturn qm.copy(qa).slerp(qb,t);\n\n},\n\nslerpFlat:function slerpFlat(\ndst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){\n\n// fuzz-free, array-based Quaternion SLERP operation\n\nvar x0=src0[srcOffset0+0],\ny0=src0[srcOffset0+1],\nz0=src0[srcOffset0+2],\nw0=src0[srcOffset0+3],\n\nx1=src1[srcOffset1+0],\ny1=src1[srcOffset1+1],\nz1=src1[srcOffset1+2],\nw1=src1[srcOffset1+3];\n\nif(w0!==w1||x0!==x1||y0!==y1||z0!==z1){\n\nvar s=1-t,\n\ncos=x0*x1+y0*y1+z0*z1+w0*w1,\n\ndir=cos>=0?1:-1,\nsqrSin=1-cos*cos;\n\n// Skip the Slerp for tiny steps to avoid numeric problems:\nif(sqrSin>Number.EPSILON){\n\nvar sin=Math.sqrt(sqrSin),\nlen=Math.atan2(sin,cos*dir);\n\ns=Math.sin(s*len)/sin;\nt=Math.sin(t*len)/sin;\n\n}\n\nvar tDir=t*dir;\n\nx0=x0*s+x1*tDir;\ny0=y0*s+y1*tDir;\nz0=z0*s+z1*tDir;\nw0=w0*s+w1*tDir;\n\n// Normalize in case we just did a lerp:\nif(s===1-t){\n\nvar f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);\n\nx0*=f;\ny0*=f;\nz0*=f;\nw0*=f;\n\n}\n\n}\n\ndst[dstOffset]=x0;\ndst[dstOffset+1]=y0;\ndst[dstOffset+2]=z0;\ndst[dstOffset+3]=w0;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author *kile / http://kile.stravaganza.org/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author egraether / http://egraether.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\nfunction Vector3(x,y,z){\n\nthis.x=x||0;\nthis.y=y||0;\nthis.z=z||0;\n\n}\n\nVector3.prototype={\n\nconstructor:Vector3,\n\nisVector3:true,\n\nset:function set(x,y,z){\n\nthis.x=x;\nthis.y=y;\nthis.z=z;\n\nreturn this;\n\n},\n\nsetScalar:function setScalar(scalar){\n\nthis.x=scalar;\nthis.y=scalar;\nthis.z=scalar;\n\nreturn this;\n\n},\n\nsetX:function setX(x){\n\nthis.x=x;\n\nreturn this;\n\n},\n\nsetY:function setY(y){\n\nthis.y=y;\n\nreturn this;\n\n},\n\nsetZ:function setZ(z){\n\nthis.z=z;\n\nreturn this;\n\n},\n\nsetComponent:function setComponent(index,value){\n\nswitch(index){\n\ncase 0:this.x=value;break;\ncase 1:this.y=value;break;\ncase 2:this.z=value;break;\ndefault:throw new Error('index is out of range: '+index);}\n\n\n\nreturn this;\n\n},\n\ngetComponent:function getComponent(index){\n\nswitch(index){\n\ncase 0:return this.x;\ncase 1:return this.y;\ncase 2:return this.z;\ndefault:throw new Error('index is out of range: '+index);}\n\n\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor(this.x,this.y,this.z);\n\n},\n\ncopy:function copy(v){\n\nthis.x=v.x;\nthis.y=v.y;\nthis.z=v.z;\n\nreturn this;\n\n},\n\nadd:function add(v,w){\n\nif(w!==undefined){\n\nconsole.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\nreturn this.addVectors(v,w);\n\n}\n\nthis.x+=v.x;\nthis.y+=v.y;\nthis.z+=v.z;\n\nreturn this;\n\n},\n\naddScalar:function addScalar(s){\n\nthis.x+=s;\nthis.y+=s;\nthis.z+=s;\n\nreturn this;\n\n},\n\naddVectors:function addVectors(a,b){\n\nthis.x=a.x+b.x;\nthis.y=a.y+b.y;\nthis.z=a.z+b.z;\n\nreturn this;\n\n},\n\naddScaledVector:function addScaledVector(v,s){\n\nthis.x+=v.x*s;\nthis.y+=v.y*s;\nthis.z+=v.z*s;\n\nreturn this;\n\n},\n\nsub:function sub(v,w){\n\nif(w!==undefined){\n\nconsole.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\nreturn this.subVectors(v,w);\n\n}\n\nthis.x-=v.x;\nthis.y-=v.y;\nthis.z-=v.z;\n\nreturn this;\n\n},\n\nsubScalar:function subScalar(s){\n\nthis.x-=s;\nthis.y-=s;\nthis.z-=s;\n\nreturn this;\n\n},\n\nsubVectors:function subVectors(a,b){\n\nthis.x=a.x-b.x;\nthis.y=a.y-b.y;\nthis.z=a.z-b.z;\n\nreturn this;\n\n},\n\nmultiply:function multiply(v,w){\n\nif(w!==undefined){\n\nconsole.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\nreturn this.multiplyVectors(v,w);\n\n}\n\nthis.x*=v.x;\nthis.y*=v.y;\nthis.z*=v.z;\n\nreturn this;\n\n},\n\nmultiplyScalar:function multiplyScalar(scalar){\n\nif(isFinite(scalar)){\n\nthis.x*=scalar;\nthis.y*=scalar;\nthis.z*=scalar;\n\n}else{\n\nthis.x=0;\nthis.y=0;\nthis.z=0;\n\n}\n\nreturn this;\n\n},\n\nmultiplyVectors:function multiplyVectors(a,b){\n\nthis.x=a.x*b.x;\nthis.y=a.y*b.y;\nthis.z=a.z*b.z;\n\nreturn this;\n\n},\n\napplyEuler:function(){\n\nvar quaternion;\n\nreturn function applyEuler(euler){\n\nif((euler&&euler.isEuler)===false){\n\nconsole.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\n}\n\nif(quaternion===undefined)quaternion=new Quaternion();\n\nreturn this.applyQuaternion(quaternion.setFromEuler(euler));\n\n};\n\n}(),\n\napplyAxisAngle:function(){\n\nvar quaternion;\n\nreturn function applyAxisAngle(axis,angle){\n\nif(quaternion===undefined)quaternion=new Quaternion();\n\nreturn this.applyQuaternion(quaternion.setFromAxisAngle(axis,angle));\n\n};\n\n}(),\n\napplyMatrix3:function applyMatrix3(m){\n\nvar x=this.x,y=this.y,z=this.z;\nvar e=m.elements;\n\nthis.x=e[0]*x+e[3]*y+e[6]*z;\nthis.y=e[1]*x+e[4]*y+e[7]*z;\nthis.z=e[2]*x+e[5]*y+e[8]*z;\n\nreturn this;\n\n},\n\napplyMatrix4:function applyMatrix4(m){\n\nvar x=this.x,y=this.y,z=this.z;\nvar e=m.elements;\n\nthis.x=e[0]*x+e[4]*y+e[8]*z+e[12];\nthis.y=e[1]*x+e[5]*y+e[9]*z+e[13];\nthis.z=e[2]*x+e[6]*y+e[10]*z+e[14];\nvar w=e[3]*x+e[7]*y+e[11]*z+e[15];\n\nreturn this.divideScalar(w);\n\n},\n\napplyQuaternion:function applyQuaternion(q){\n\nvar x=this.x,y=this.y,z=this.z;\nvar qx=q.x,qy=q.y,qz=q.z,qw=q.w;\n\n// calculate quat * vector\n\nvar ix=qw*x+qy*z-qz*y;\nvar iy=qw*y+qz*x-qx*z;\nvar iz=qw*z+qx*y-qy*x;\nvar iw=-qx*x-qy*y-qz*z;\n\n// calculate result * inverse quat\n\nthis.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;\nthis.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;\nthis.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;\n\nreturn this;\n\n},\n\nproject:function(){\n\nvar matrix;\n\nreturn function project(camera){\n\nif(matrix===undefined)matrix=new Matrix4();\n\nmatrix.multiplyMatrices(camera.projectionMatrix,matrix.getInverse(camera.matrixWorld));\nreturn this.applyMatrix4(matrix);\n\n};\n\n}(),\n\nunproject:function(){\n\nvar matrix;\n\nreturn function unproject(camera){\n\nif(matrix===undefined)matrix=new Matrix4();\n\nmatrix.multiplyMatrices(camera.matrixWorld,matrix.getInverse(camera.projectionMatrix));\nreturn this.applyMatrix4(matrix);\n\n};\n\n}(),\n\ntransformDirection:function transformDirection(m){\n\n// input: THREE.Matrix4 affine matrix\n// vector interpreted as a direction\n\nvar x=this.x,y=this.y,z=this.z;\nvar e=m.elements;\n\nthis.x=e[0]*x+e[4]*y+e[8]*z;\nthis.y=e[1]*x+e[5]*y+e[9]*z;\nthis.z=e[2]*x+e[6]*y+e[10]*z;\n\nreturn this.normalize();\n\n},\n\ndivide:function divide(v){\n\nthis.x/=v.x;\nthis.y/=v.y;\nthis.z/=v.z;\n\nreturn this;\n\n},\n\ndivideScalar:function divideScalar(scalar){\n\nreturn this.multiplyScalar(1/scalar);\n\n},\n\nmin:function min(v){\n\nthis.x=Math.min(this.x,v.x);\nthis.y=Math.min(this.y,v.y);\nthis.z=Math.min(this.z,v.z);\n\nreturn this;\n\n},\n\nmax:function max(v){\n\nthis.x=Math.max(this.x,v.x);\nthis.y=Math.max(this.y,v.y);\nthis.z=Math.max(this.z,v.z);\n\nreturn this;\n\n},\n\nclamp:function clamp(min,max){\n\n// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\nthis.x=Math.max(min.x,Math.min(max.x,this.x));\nthis.y=Math.max(min.y,Math.min(max.y,this.y));\nthis.z=Math.max(min.z,Math.min(max.z,this.z));\n\nreturn this;\n\n},\n\nclampScalar:function(){\n\nvar min,max;\n\nreturn function clampScalar(minVal,maxVal){\n\nif(min===undefined){\n\nmin=new Vector3();\nmax=new Vector3();\n\n}\n\nmin.set(minVal,minVal,minVal);\nmax.set(maxVal,maxVal,maxVal);\n\nreturn this.clamp(min,max);\n\n};\n\n}(),\n\nclampLength:function clampLength(min,max){\n\nvar length=this.length();\n\nreturn this.multiplyScalar(Math.max(min,Math.min(max,length))/length);\n\n},\n\nfloor:function floor(){\n\nthis.x=Math.floor(this.x);\nthis.y=Math.floor(this.y);\nthis.z=Math.floor(this.z);\n\nreturn this;\n\n},\n\nceil:function ceil(){\n\nthis.x=Math.ceil(this.x);\nthis.y=Math.ceil(this.y);\nthis.z=Math.ceil(this.z);\n\nreturn this;\n\n},\n\nround:function round(){\n\nthis.x=Math.round(this.x);\nthis.y=Math.round(this.y);\nthis.z=Math.round(this.z);\n\nreturn this;\n\n},\n\nroundToZero:function roundToZero(){\n\nthis.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);\nthis.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);\nthis.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);\n\nreturn this;\n\n},\n\nnegate:function negate(){\n\nthis.x=-this.x;\nthis.y=-this.y;\nthis.z=-this.z;\n\nreturn this;\n\n},\n\ndot:function dot(v){\n\nreturn this.x*v.x+this.y*v.y+this.z*v.z;\n\n},\n\nlengthSq:function lengthSq(){\n\nreturn this.x*this.x+this.y*this.y+this.z*this.z;\n\n},\n\nlength:function length(){\n\nreturn Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);\n\n},\n\nlengthManhattan:function lengthManhattan(){\n\nreturn Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);\n\n},\n\nnormalize:function normalize(){\n\nreturn this.divideScalar(this.length());\n\n},\n\nsetLength:function setLength(length){\n\nreturn this.multiplyScalar(length/this.length());\n\n},\n\nlerp:function lerp(v,alpha){\n\nthis.x+=(v.x-this.x)*alpha;\nthis.y+=(v.y-this.y)*alpha;\nthis.z+=(v.z-this.z)*alpha;\n\nreturn this;\n\n},\n\nlerpVectors:function lerpVectors(v1,v2,alpha){\n\nreturn this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);\n\n},\n\ncross:function cross(v,w){\n\nif(w!==undefined){\n\nconsole.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\nreturn this.crossVectors(v,w);\n\n}\n\nvar x=this.x,y=this.y,z=this.z;\n\nthis.x=y*v.z-z*v.y;\nthis.y=z*v.x-x*v.z;\nthis.z=x*v.y-y*v.x;\n\nreturn this;\n\n},\n\ncrossVectors:function crossVectors(a,b){\n\nvar ax=a.x,ay=a.y,az=a.z;\nvar bx=b.x,by=b.y,bz=b.z;\n\nthis.x=ay*bz-az*by;\nthis.y=az*bx-ax*bz;\nthis.z=ax*by-ay*bx;\n\nreturn this;\n\n},\n\nprojectOnVector:function projectOnVector(vector){\n\nvar scalar=vector.dot(this)/vector.lengthSq();\n\nreturn this.copy(vector).multiplyScalar(scalar);\n\n},\n\nprojectOnPlane:function(){\n\nvar v1;\n\nreturn function projectOnPlane(planeNormal){\n\nif(v1===undefined)v1=new Vector3();\n\nv1.copy(this).projectOnVector(planeNormal);\n\nreturn this.sub(v1);\n\n};\n\n}(),\n\nreflect:function(){\n\n// reflect incident vector off plane orthogonal to normal\n// normal is assumed to have unit length\n\nvar v1;\n\nreturn function reflect(normal){\n\nif(v1===undefined)v1=new Vector3();\n\nreturn this.sub(v1.copy(normal).multiplyScalar(2*this.dot(normal)));\n\n};\n\n}(),\n\nangleTo:function angleTo(v){\n\nvar theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());\n\n// clamp, to handle numerical problems\n\nreturn Math.acos(_Math.clamp(theta,-1,1));\n\n},\n\ndistanceTo:function distanceTo(v){\n\nreturn Math.sqrt(this.distanceToSquared(v));\n\n},\n\ndistanceToSquared:function distanceToSquared(v){\n\nvar dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;\n\nreturn dx*dx+dy*dy+dz*dz;\n\n},\n\ndistanceToManhattan:function distanceToManhattan(v){\n\nreturn Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);\n\n},\n\nsetFromSpherical:function setFromSpherical(s){\n\nvar sinPhiRadius=Math.sin(s.phi)*s.radius;\n\nthis.x=sinPhiRadius*Math.sin(s.theta);\nthis.y=Math.cos(s.phi)*s.radius;\nthis.z=sinPhiRadius*Math.cos(s.theta);\n\nreturn this;\n\n},\n\nsetFromCylindrical:function setFromCylindrical(c){\n\nthis.x=c.radius*Math.sin(c.theta);\nthis.y=c.y;\nthis.z=c.radius*Math.cos(c.theta);\n\nreturn this;\n\n},\n\nsetFromMatrixPosition:function setFromMatrixPosition(m){\n\nreturn this.setFromMatrixColumn(m,3);\n\n},\n\nsetFromMatrixScale:function setFromMatrixScale(m){\n\nvar sx=this.setFromMatrixColumn(m,0).length();\nvar sy=this.setFromMatrixColumn(m,1).length();\nvar sz=this.setFromMatrixColumn(m,2).length();\n\nthis.x=sx;\nthis.y=sy;\nthis.z=sz;\n\nreturn this;\n\n},\n\nsetFromMatrixColumn:function setFromMatrixColumn(m,index){\n\nif(typeof m==='number'){\n\nconsole.warn('THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).');\nvar temp=m;\nm=index;\nindex=temp;\n\n}\n\nreturn this.fromArray(m.elements,index*4);\n\n},\n\nequals:function equals(v){\n\nreturn v.x===this.x&&v.y===this.y&&v.z===this.z;\n\n},\n\nfromArray:function fromArray(array,offset){\n\nif(offset===undefined)offset=0;\n\nthis.x=array[offset];\nthis.y=array[offset+1];\nthis.z=array[offset+2];\n\nreturn this;\n\n},\n\ntoArray:function toArray(array,offset){\n\nif(array===undefined)array=[];\nif(offset===undefined)offset=0;\n\narray[offset]=this.x;\narray[offset+1]=this.y;\narray[offset+2]=this.z;\n\nreturn array;\n\n},\n\nfromBufferAttribute:function fromBufferAttribute(attribute,index,offset){\n\nif(offset!==undefined){\n\nconsole.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\n\n}\n\nthis.x=attribute.getX(index);\nthis.y=attribute.getY(index);\nthis.z=attribute.getZ(index);\n\nreturn this;\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author philogb / http://blog.thejit.org/\n\t * @author jordi_ros / http://plattsoft.com\n\t * @author D1plo1d / http://github.com/D1plo1d\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author timknip / http://www.floorplanner.com/\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\nfunction Matrix4(){\n\nthis.elements=new Float32Array([\n\n1,0,0,0,\n0,1,0,0,\n0,0,1,0,\n0,0,0,1]);\n\n\n\nif(arguments.length>0){\n\nconsole.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\n\n}\n\n}\n\nMatrix4.prototype={\n\nconstructor:Matrix4,\n\nisMatrix4:true,\n\nset:function set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){\n\nvar te=this.elements;\n\nte[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;\nte[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;\nte[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;\nte[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;\n\nreturn this;\n\n},\n\nidentity:function identity(){\n\nthis.set(\n\n1,0,0,0,\n0,1,0,0,\n0,0,1,0,\n0,0,0,1);\n\n\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new Matrix4().fromArray(this.elements);\n\n},\n\ncopy:function copy(m){\n\nthis.elements.set(m.elements);\n\nreturn this;\n\n},\n\ncopyPosition:function copyPosition(m){\n\nvar te=this.elements;\nvar me=m.elements;\n\nte[12]=me[12];\nte[13]=me[13];\nte[14]=me[14];\n\nreturn this;\n\n},\n\nextractBasis:function extractBasis(xAxis,yAxis,zAxis){\n\nxAxis.setFromMatrixColumn(this,0);\nyAxis.setFromMatrixColumn(this,1);\nzAxis.setFromMatrixColumn(this,2);\n\nreturn this;\n\n},\n\nmakeBasis:function makeBasis(xAxis,yAxis,zAxis){\n\nthis.set(\nxAxis.x,yAxis.x,zAxis.x,0,\nxAxis.y,yAxis.y,zAxis.y,0,\nxAxis.z,yAxis.z,zAxis.z,0,\n0,0,0,1);\n\n\nreturn this;\n\n},\n\nextractRotation:function(){\n\nvar v1;\n\nreturn function extractRotation(m){\n\nif(v1===undefined)v1=new Vector3();\n\nvar te=this.elements;\nvar me=m.elements;\n\nvar scaleX=1/v1.setFromMatrixColumn(m,0).length();\nvar scaleY=1/v1.setFromMatrixColumn(m,1).length();\nvar scaleZ=1/v1.setFromMatrixColumn(m,2).length();\n\nte[0]=me[0]*scaleX;\nte[1]=me[1]*scaleX;\nte[2]=me[2]*scaleX;\n\nte[4]=me[4]*scaleY;\nte[5]=me[5]*scaleY;\nte[6]=me[6]*scaleY;\n\nte[8]=me[8]*scaleZ;\nte[9]=me[9]*scaleZ;\nte[10]=me[10]*scaleZ;\n\nreturn this;\n\n};\n\n}(),\n\nmakeRotationFromEuler:function makeRotationFromEuler(euler){\n\nif((euler&&euler.isEuler)===false){\n\nconsole.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n\n}\n\nvar te=this.elements;\n\nvar x=euler.x,y=euler.y,z=euler.z;\nvar a=Math.cos(x),b=Math.sin(x);\nvar c=Math.cos(y),d=Math.sin(y);\nvar e=Math.cos(z),f=Math.sin(z);\n\nif(euler.order==='XYZ'){\n\nvar ae=a*e,af=a*f,be=b*e,bf=b*f;\n\nte[0]=c*e;\nte[4]=-c*f;\nte[8]=d;\n\nte[1]=af+be*d;\nte[5]=ae-bf*d;\nte[9]=-b*c;\n\nte[2]=bf-ae*d;\nte[6]=be+af*d;\nte[10]=a*c;\n\n}else if(euler.order==='YXZ'){\n\nvar ce=c*e,cf=c*f,de=d*e,df=d*f;\n\nte[0]=ce+df*b;\nte[4]=de*b-cf;\nte[8]=a*d;\n\nte[1]=a*f;\nte[5]=a*e;\nte[9]=-b;\n\nte[2]=cf*b-de;\nte[6]=df+ce*b;\nte[10]=a*c;\n\n}else if(euler.order==='ZXY'){\n\nvar ce=c*e,cf=c*f,de=d*e,df=d*f;\n\nte[0]=ce-df*b;\nte[4]=-a*f;\nte[8]=de+cf*b;\n\nte[1]=cf+de*b;\nte[5]=a*e;\nte[9]=df-ce*b;\n\nte[2]=-a*d;\nte[6]=b;\nte[10]=a*c;\n\n}else if(euler.order==='ZYX'){\n\nvar ae=a*e,af=a*f,be=b*e,bf=b*f;\n\nte[0]=c*e;\nte[4]=be*d-af;\nte[8]=ae*d+bf;\n\nte[1]=c*f;\nte[5]=bf*d+ae;\nte[9]=af*d-be;\n\nte[2]=-d;\nte[6]=b*c;\nte[10]=a*c;\n\n}else if(euler.order==='YZX'){\n\nvar ac=a*c,ad=a*d,bc=b*c,bd=b*d;\n\nte[0]=c*e;\nte[4]=bd-ac*f;\nte[8]=bc*f+ad;\n\nte[1]=f;\nte[5]=a*e;\nte[9]=-b*e;\n\nte[2]=-d*e;\nte[6]=ad*f+bc;\nte[10]=ac-bd*f;\n\n}else if(euler.order==='XZY'){\n\nvar ac=a*c,ad=a*d,bc=b*c,bd=b*d;\n\nte[0]=c*e;\nte[4]=-f;\nte[8]=d*e;\n\nte[1]=ac*f+bd;\nte[5]=a*e;\nte[9]=ad*f-bc;\n\nte[2]=bc*f-ad;\nte[6]=b*e;\nte[10]=bd*f+ac;\n\n}\n\n// last column\nte[3]=0;\nte[7]=0;\nte[11]=0;\n\n// bottom row\nte[12]=0;\nte[13]=0;\nte[14]=0;\nte[15]=1;\n\nreturn this;\n\n},\n\nmakeRotationFromQuaternion:function makeRotationFromQuaternion(q){\n\nvar te=this.elements;\n\nvar x=q.x,y=q.y,z=q.z,w=q.w;\nvar x2=x+x,y2=y+y,z2=z+z;\nvar xx=x*x2,xy=x*y2,xz=x*z2;\nvar yy=y*y2,yz=y*z2,zz=z*z2;\nvar wx=w*x2,wy=w*y2,wz=w*z2;\n\nte[0]=1-(yy+zz);\nte[4]=xy-wz;\nte[8]=xz+wy;\n\nte[1]=xy+wz;\nte[5]=1-(xx+zz);\nte[9]=yz-wx;\n\nte[2]=xz-wy;\nte[6]=yz+wx;\nte[10]=1-(xx+yy);\n\n// last column\nte[3]=0;\nte[7]=0;\nte[11]=0;\n\n// bottom row\nte[12]=0;\nte[13]=0;\nte[14]=0;\nte[15]=1;\n\nreturn this;\n\n},\n\nlookAt:function(){\n\nvar x,y,z;\n\nreturn function lookAt(eye,target,up){\n\nif(x===undefined){\n\nx=new Vector3();\ny=new Vector3();\nz=new Vector3();\n\n}\n\nvar te=this.elements;\n\nz.subVectors(eye,target).normalize();\n\nif(z.lengthSq()===0){\n\nz.z=1;\n\n}\n\nx.crossVectors(up,z).normalize();\n\nif(x.lengthSq()===0){\n\nz.z+=0.0001;\nx.crossVectors(up,z).normalize();\n\n}\n\ny.crossVectors(z,x);\n\n\nte[0]=x.x;te[4]=y.x;te[8]=z.x;\nte[1]=x.y;te[5]=y.y;te[9]=z.y;\nte[2]=x.z;te[6]=y.z;te[10]=z.z;\n\nreturn this;\n\n};\n\n}(),\n\nmultiply:function multiply(m,n){\n\nif(n!==undefined){\n\nconsole.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\nreturn this.multiplyMatrices(m,n);\n\n}\n\nreturn this.multiplyMatrices(this,m);\n\n},\n\npremultiply:function premultiply(m){\n\nreturn this.multiplyMatrices(m,this);\n\n},\n\nmultiplyMatrices:function multiplyMatrices(a,b){\n\nvar ae=a.elements;\nvar be=b.elements;\nvar te=this.elements;\n\nvar a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];\nvar a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];\nvar a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];\nvar a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];\n\nvar b11=be[0],b12=be[4],b13=be[8],b14=be[12];\nvar b21=be[1],b22=be[5],b23=be[9],b24=be[13];\nvar b31=be[2],b32=be[6],b33=be[10],b34=be[14];\nvar b41=be[3],b42=be[7],b43=be[11],b44=be[15];\n\nte[0]=a11*b11+a12*b21+a13*b31+a14*b41;\nte[4]=a11*b12+a12*b22+a13*b32+a14*b42;\nte[8]=a11*b13+a12*b23+a13*b33+a14*b43;\nte[12]=a11*b14+a12*b24+a13*b34+a14*b44;\n\nte[1]=a21*b11+a22*b21+a23*b31+a24*b41;\nte[5]=a21*b12+a22*b22+a23*b32+a24*b42;\nte[9]=a21*b13+a22*b23+a23*b33+a24*b43;\nte[13]=a21*b14+a22*b24+a23*b34+a24*b44;\n\nte[2]=a31*b11+a32*b21+a33*b31+a34*b41;\nte[6]=a31*b12+a32*b22+a33*b32+a34*b42;\nte[10]=a31*b13+a32*b23+a33*b33+a34*b43;\nte[14]=a31*b14+a32*b24+a33*b34+a34*b44;\n\nte[3]=a41*b11+a42*b21+a43*b31+a44*b41;\nte[7]=a41*b12+a42*b22+a43*b32+a44*b42;\nte[11]=a41*b13+a42*b23+a43*b33+a44*b43;\nte[15]=a41*b14+a42*b24+a43*b34+a44*b44;\n\nreturn this;\n\n},\n\nmultiplyToArray:function multiplyToArray(a,b,r){\n\nvar te=this.elements;\n\nthis.multiplyMatrices(a,b);\n\nr[0]=te[0];r[1]=te[1];r[2]=te[2];r[3]=te[3];\nr[4]=te[4];r[5]=te[5];r[6]=te[6];r[7]=te[7];\nr[8]=te[8];r[9]=te[9];r[10]=te[10];r[11]=te[11];\nr[12]=te[12];r[13]=te[13];r[14]=te[14];r[15]=te[15];\n\nreturn this;\n\n},\n\nmultiplyScalar:function multiplyScalar(s){\n\nvar te=this.elements;\n\nte[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;\nte[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;\nte[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;\nte[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;\n\nreturn this;\n\n},\n\napplyToBufferAttribute:function(){\n\nvar v1;\n\nreturn function applyToBufferAttribute(attribute){\n\nif(v1===undefined)v1=new Vector3();\n\nfor(var i=0,l=attribute.count;i<l;i++){\n\nv1.x=attribute.getX(i);\nv1.y=attribute.getY(i);\nv1.z=attribute.getZ(i);\n\nv1.applyMatrix4(this);\n\nattribute.setXYZ(i,v1.x,v1.y,v1.z);\n\n}\n\nreturn attribute;\n\n};\n\n}(),\n\ndeterminant:function determinant(){\n\nvar te=this.elements;\n\nvar n11=te[0],n12=te[4],n13=te[8],n14=te[12];\nvar n21=te[1],n22=te[5],n23=te[9],n24=te[13];\nvar n31=te[2],n32=te[6],n33=te[10],n34=te[14];\nvar n41=te[3],n42=te[7],n43=te[11],n44=te[15];\n\n//TODO: make this more efficient\n//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\nreturn(\nn41*(\n+n14*n23*n32-\nn13*n24*n32-\nn14*n22*n33+\nn12*n24*n33+\nn13*n22*n34-\nn12*n23*n34)+\n\nn42*(\n+n11*n23*n34-\nn11*n24*n33+\nn14*n21*n33-\nn13*n21*n34+\nn13*n24*n31-\nn14*n23*n31)+\n\nn43*(\n+n11*n24*n32-\nn11*n22*n34-\nn14*n21*n32+\nn12*n21*n34+\nn14*n22*n31-\nn12*n24*n31)+\n\nn44*(\n-n13*n22*n31-\nn11*n23*n32+\nn11*n22*n33+\nn13*n21*n32-\nn12*n21*n33+\nn12*n23*n31));\n\n\n\n\n},\n\ntranspose:function transpose(){\n\nvar te=this.elements;\nvar tmp;\n\ntmp=te[1];te[1]=te[4];te[4]=tmp;\ntmp=te[2];te[2]=te[8];te[8]=tmp;\ntmp=te[6];te[6]=te[9];te[9]=tmp;\n\ntmp=te[3];te[3]=te[12];te[12]=tmp;\ntmp=te[7];te[7]=te[13];te[13]=tmp;\ntmp=te[11];te[11]=te[14];te[14]=tmp;\n\nreturn this;\n\n},\n\nsetPosition:function setPosition(v){\n\nvar te=this.elements;\n\nte[12]=v.x;\nte[13]=v.y;\nte[14]=v.z;\n\nreturn this;\n\n},\n\ngetInverse:function getInverse(m,throwOnDegenerate){\n\n// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\nvar te=this.elements,\nme=m.elements,\n\nn11=me[0],n21=me[1],n31=me[2],n41=me[3],\nn12=me[4],n22=me[5],n32=me[6],n42=me[7],\nn13=me[8],n23=me[9],n33=me[10],n43=me[11],\nn14=me[12],n24=me[13],n34=me[14],n44=me[15],\n\nt11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,\nt12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,\nt13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,\nt14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;\n\nvar det=n11*t11+n21*t12+n31*t13+n41*t14;\n\nif(det===0){\n\nvar msg=\"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\nif(throwOnDegenerate===true){\n\nthrow new Error(msg);\n\n}else{\n\nconsole.warn(msg);\n\n}\n\nreturn this.identity();\n\n}\n\nvar detInv=1/det;\n\nte[0]=t11*detInv;\nte[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;\nte[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;\nte[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;\n\nte[4]=t12*detInv;\nte[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;\nte[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;\nte[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;\n\nte[8]=t13*detInv;\nte[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;\nte[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;\nte[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;\n\nte[12]=t14*detInv;\nte[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;\nte[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;\nte[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;\n\nreturn this;\n\n},\n\nscale:function scale(v){\n\nvar te=this.elements;\nvar x=v.x,y=v.y,z=v.z;\n\nte[0]*=x;te[4]*=y;te[8]*=z;\nte[1]*=x;te[5]*=y;te[9]*=z;\nte[2]*=x;te[6]*=y;te[10]*=z;\nte[3]*=x;te[7]*=y;te[11]*=z;\n\nreturn this;\n\n},\n\ngetMaxScaleOnAxis:function getMaxScaleOnAxis(){\n\nvar te=this.elements;\n\nvar scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];\nvar scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];\nvar scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];\n\nreturn Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));\n\n},\n\nmakeTranslation:function makeTranslation(x,y,z){\n\nthis.set(\n\n1,0,0,x,\n0,1,0,y,\n0,0,1,z,\n0,0,0,1);\n\n\n\nreturn this;\n\n},\n\nmakeRotationX:function makeRotationX(theta){\n\nvar c=Math.cos(theta),s=Math.sin(theta);\n\nthis.set(\n\n1,0,0,0,\n0,c,-s,0,\n0,s,c,0,\n0,0,0,1);\n\n\n\nreturn this;\n\n},\n\nmakeRotationY:function makeRotationY(theta){\n\nvar c=Math.cos(theta),s=Math.sin(theta);\n\nthis.set(\n\nc,0,s,0,\n0,1,0,0,\n-s,0,c,0,\n0,0,0,1);\n\n\n\nreturn this;\n\n},\n\nmakeRotationZ:function makeRotationZ(theta){\n\nvar c=Math.cos(theta),s=Math.sin(theta);\n\nthis.set(\n\nc,-s,0,0,\ns,c,0,0,\n0,0,1,0,\n0,0,0,1);\n\n\n\nreturn this;\n\n},\n\nmakeRotationAxis:function makeRotationAxis(axis,angle){\n\n// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\nvar c=Math.cos(angle);\nvar s=Math.sin(angle);\nvar t=1-c;\nvar x=axis.x,y=axis.y,z=axis.z;\nvar tx=t*x,ty=t*y;\n\nthis.set(\n\ntx*x+c,tx*y-s*z,tx*z+s*y,0,\ntx*y+s*z,ty*y+c,ty*z-s*x,0,\ntx*z-s*y,ty*z+s*x,t*z*z+c,0,\n0,0,0,1);\n\n\n\nreturn this;\n\n},\n\nmakeScale:function makeScale(x,y,z){\n\nthis.set(\n\nx,0,0,0,\n0,y,0,0,\n0,0,z,0,\n0,0,0,1);\n\n\n\nreturn this;\n\n},\n\nmakeShear:function makeShear(x,y,z){\n\nthis.set(\n\n1,y,z,0,\nx,1,z,0,\nx,y,1,0,\n0,0,0,1);\n\n\n\nreturn this;\n\n},\n\ncompose:function compose(position,quaternion,scale){\n\nthis.makeRotationFromQuaternion(quaternion);\nthis.scale(scale);\nthis.setPosition(position);\n\nreturn this;\n\n},\n\ndecompose:function(){\n\nvar vector,matrix;\n\nreturn function decompose(position,quaternion,scale){\n\nif(vector===undefined){\n\nvector=new Vector3();\nmatrix=new Matrix4();\n\n}\n\nvar te=this.elements;\n\nvar sx=vector.set(te[0],te[1],te[2]).length();\nvar sy=vector.set(te[4],te[5],te[6]).length();\nvar sz=vector.set(te[8],te[9],te[10]).length();\n\n// if determine is negative, we need to invert one scale\nvar det=this.determinant();\nif(det<0){\n\nsx=-sx;\n\n}\n\nposition.x=te[12];\nposition.y=te[13];\nposition.z=te[14];\n\n// scale the rotation part\n\nmatrix.elements.set(this.elements);// at this point matrix is incomplete so we can't use .copy()\n\nvar invSX=1/sx;\nvar invSY=1/sy;\nvar invSZ=1/sz;\n\nmatrix.elements[0]*=invSX;\nmatrix.elements[1]*=invSX;\nmatrix.elements[2]*=invSX;\n\nmatrix.elements[4]*=invSY;\nmatrix.elements[5]*=invSY;\nmatrix.elements[6]*=invSY;\n\nmatrix.elements[8]*=invSZ;\nmatrix.elements[9]*=invSZ;\nmatrix.elements[10]*=invSZ;\n\nquaternion.setFromRotationMatrix(matrix);\n\nscale.x=sx;\nscale.y=sy;\nscale.z=sz;\n\nreturn this;\n\n};\n\n}(),\n\nmakePerspective:function makePerspective(left,right,top,bottom,near,far){\n\nif(far===undefined){\n\nconsole.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');\n\n}\n\nvar te=this.elements;\nvar x=2*near/(right-left);\nvar y=2*near/(top-bottom);\n\nvar a=(right+left)/(right-left);\nvar b=(top+bottom)/(top-bottom);\nvar c=-(far+near)/(far-near);\nvar d=-2*far*near/(far-near);\n\nte[0]=x;te[4]=0;te[8]=a;te[12]=0;\nte[1]=0;te[5]=y;te[9]=b;te[13]=0;\nte[2]=0;te[6]=0;te[10]=c;te[14]=d;\nte[3]=0;te[7]=0;te[11]=-1;te[15]=0;\n\nreturn this;\n\n},\n\nmakeOrthographic:function makeOrthographic(left,right,top,bottom,near,far){\n\nvar te=this.elements;\nvar w=1.0/(right-left);\nvar h=1.0/(top-bottom);\nvar p=1.0/(far-near);\n\nvar x=(right+left)*w;\nvar y=(top+bottom)*h;\nvar z=(far+near)*p;\n\nte[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;\nte[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;\nte[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;\nte[3]=0;te[7]=0;te[11]=0;te[15]=1;\n\nreturn this;\n\n},\n\nequals:function equals(matrix){\n\nvar te=this.elements;\nvar me=matrix.elements;\n\nfor(var i=0;i<16;i++){\n\nif(te[i]!==me[i])return false;\n\n}\n\nreturn true;\n\n},\n\nfromArray:function fromArray(array,offset){\n\nif(offset===undefined)offset=0;\n\nfor(var i=0;i<16;i++){\n\nthis.elements[i]=array[i+offset];\n\n}\n\nreturn this;\n\n},\n\ntoArray:function toArray(array,offset){\n\nif(array===undefined)array=[];\nif(offset===undefined)offset=0;\n\nvar te=this.elements;\n\narray[offset]=te[0];\narray[offset+1]=te[1];\narray[offset+2]=te[2];\narray[offset+3]=te[3];\n\narray[offset+4]=te[4];\narray[offset+5]=te[5];\narray[offset+6]=te[6];\narray[offset+7]=te[7];\n\narray[offset+8]=te[8];\narray[offset+9]=te[9];\narray[offset+10]=te[10];\narray[offset+11]=te[11];\n\narray[offset+12]=te[12];\narray[offset+13]=te[13];\narray[offset+14]=te[14];\narray[offset+15]=te[15];\n\nreturn array;\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){\n\nimages=images!==undefined?images:[];\nmapping=mapping!==undefined?mapping:CubeReflectionMapping;\n\nTexture.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);\n\nthis.flipY=false;\n\n}\n\nCubeTexture.prototype=Object.create(Texture.prototype);\nCubeTexture.prototype.constructor=CubeTexture;\n\nCubeTexture.prototype.isCubeTexture=true;\n\nObject.defineProperty(CubeTexture.prototype,'images',{\n\nget:function get(){\n\nreturn this.image;\n\n},\n\nset:function set(value){\n\nthis.image=value;\n\n}});\n\n\n\n/**\n\t * @author tschw\n\t *\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [renderer] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (renderer factorizations):\n\t *\n\t * .upload( gl, seq, values, renderer )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (renderer factorizations):\n\t *\n\t * .setValue( gl, name, value )\n\t *\n\t * \t\tsets uniform with  name 'name' to 'value'\n\t *\n\t * .set( gl, obj, prop )\n\t *\n\t * \t\tsets uniform from object and property with same name than uniform\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\nvar emptyTexture=new Texture();\nvar emptyCubeTexture=new CubeTexture();\n\n// --- Base for inner nodes (including the root) ---\n\nfunction UniformContainer(){\n\nthis.seq=[];\nthis.map={};\n\n}\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nvar arrayCacheF32=[];\nvar arrayCacheI32=[];\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten(array,nBlocks,blockSize){\n\nvar firstElem=array[0];\n\nif(firstElem<=0||firstElem>0)return array;\n// unoptimized: ! isNaN( firstElem )\n// see http://jacksondunstan.com/articles/983\n\nvar n=nBlocks*blockSize,\nr=arrayCacheF32[n];\n\nif(r===undefined){\n\nr=new Float32Array(n);\narrayCacheF32[n]=r;\n\n}\n\nif(nBlocks!==0){\n\nfirstElem.toArray(r,0);\n\nfor(var i=1,offset=0;i!==nBlocks;++i){\n\noffset+=blockSize;\narray[i].toArray(r,offset);\n\n}\n\n}\n\nreturn r;\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits(renderer,n){\n\nvar r=arrayCacheI32[n];\n\nif(r===undefined){\n\nr=new Int32Array(n);\narrayCacheI32[n]=r;\n\n}\n\nfor(var i=0;i!==n;++i){\nr[i]=renderer.allocTextureUnit();}\n\nreturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValue1f(gl,v){gl.uniform1f(this.addr,v);}\nfunction setValue1i(gl,v){gl.uniform1i(this.addr,v);}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValue2fv(gl,v){\n\nif(v.x===undefined)gl.uniform2fv(this.addr,v);else\ngl.uniform2f(this.addr,v.x,v.y);\n\n}\n\nfunction setValue3fv(gl,v){\n\nif(v.x!==undefined)\ngl.uniform3f(this.addr,v.x,v.y,v.z);else\nif(v.r!==undefined)\ngl.uniform3f(this.addr,v.r,v.g,v.b);else\n\ngl.uniform3fv(this.addr,v);\n\n}\n\nfunction setValue4fv(gl,v){\n\nif(v.x===undefined)gl.uniform4fv(this.addr,v);else\ngl.uniform4f(this.addr,v.x,v.y,v.z,v.w);\n\n}\n\n// Single matrix (from flat array or MatrixN)\n\nfunction setValue2fm(gl,v){\n\ngl.uniformMatrix2fv(this.addr,false,v.elements||v);\n\n}\n\nfunction setValue3fm(gl,v){\n\ngl.uniformMatrix3fv(this.addr,false,v.elements||v);\n\n}\n\nfunction setValue4fm(gl,v){\n\ngl.uniformMatrix4fv(this.addr,false,v.elements||v);\n\n}\n\n// Single texture (2D / Cube)\n\nfunction setValueT1(gl,v,renderer){\n\nvar unit=renderer.allocTextureUnit();\ngl.uniform1i(this.addr,unit);\nrenderer.setTexture2D(v||emptyTexture,unit);\n\n}\n\nfunction setValueT6(gl,v,renderer){\n\nvar unit=renderer.allocTextureUnit();\ngl.uniform1i(this.addr,unit);\nrenderer.setTextureCube(v||emptyCubeTexture,unit);\n\n}\n\n// Integer / Boolean vectors or arrays thereof (always flat arrays)\n\nfunction setValue2iv(gl,v){gl.uniform2iv(this.addr,v);}\nfunction setValue3iv(gl,v){gl.uniform3iv(this.addr,v);}\nfunction setValue4iv(gl,v){gl.uniform4iv(this.addr,v);}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter(type){\n\nswitch(type){\n\ncase 0x1406:return setValue1f;// FLOAT\ncase 0x8b50:return setValue2fv;// _VEC2\ncase 0x8b51:return setValue3fv;// _VEC3\ncase 0x8b52:return setValue4fv;// _VEC4\n\ncase 0x8b5a:return setValue2fm;// _MAT2\ncase 0x8b5b:return setValue3fm;// _MAT3\ncase 0x8b5c:return setValue4fm;// _MAT4\n\ncase 0x8b5e:return setValueT1;// SAMPLER_2D\ncase 0x8b60:return setValueT6;// SAMPLER_CUBE\n\ncase 0x1404:case 0x8b56:return setValue1i;// INT, BOOL\ncase 0x8b53:case 0x8b57:return setValue2iv;// _VEC2\ncase 0x8b54:case 0x8b58:return setValue3iv;// _VEC3\ncase 0x8b55:case 0x8b59:return setValue4iv;// _VEC4\n}\n\n\n}\n\n// Array of scalars\n\nfunction setValue1fv(gl,v){gl.uniform1fv(this.addr,v);}\nfunction setValue1iv(gl,v){gl.uniform1iv(this.addr,v);}\n\n// Array of vectors (flat or from THREE classes)\n\nfunction setValueV2a(gl,v){\n\ngl.uniform2fv(this.addr,flatten(v,this.size,2));\n\n}\n\nfunction setValueV3a(gl,v){\n\ngl.uniform3fv(this.addr,flatten(v,this.size,3));\n\n}\n\nfunction setValueV4a(gl,v){\n\ngl.uniform4fv(this.addr,flatten(v,this.size,4));\n\n}\n\n// Array of matrices (flat or from THREE clases)\n\nfunction setValueM2a(gl,v){\n\ngl.uniformMatrix2fv(this.addr,false,flatten(v,this.size,4));\n\n}\n\nfunction setValueM3a(gl,v){\n\ngl.uniformMatrix3fv(this.addr,false,flatten(v,this.size,9));\n\n}\n\nfunction setValueM4a(gl,v){\n\ngl.uniformMatrix4fv(this.addr,false,flatten(v,this.size,16));\n\n}\n\n// Array of textures (2D / Cube)\n\nfunction setValueT1a(gl,v,renderer){\n\nvar n=v.length,\nunits=allocTexUnits(renderer,n);\n\ngl.uniform1iv(this.addr,units);\n\nfor(var i=0;i!==n;++i){\n\nrenderer.setTexture2D(v[i]||emptyTexture,units[i]);\n\n}\n\n}\n\nfunction setValueT6a(gl,v,renderer){\n\nvar n=v.length,\nunits=allocTexUnits(renderer,n);\n\ngl.uniform1iv(this.addr,units);\n\nfor(var i=0;i!==n;++i){\n\nrenderer.setTextureCube(v[i]||emptyCubeTexture,units[i]);\n\n}\n\n}\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter(type){\n\nswitch(type){\n\ncase 0x1406:return setValue1fv;// FLOAT\ncase 0x8b50:return setValueV2a;// _VEC2\ncase 0x8b51:return setValueV3a;// _VEC3\ncase 0x8b52:return setValueV4a;// _VEC4\n\ncase 0x8b5a:return setValueM2a;// _MAT2\ncase 0x8b5b:return setValueM3a;// _MAT3\ncase 0x8b5c:return setValueM4a;// _MAT4\n\ncase 0x8b5e:return setValueT1a;// SAMPLER_2D\ncase 0x8b60:return setValueT6a;// SAMPLER_CUBE\n\ncase 0x1404:case 0x8b56:return setValue1iv;// INT, BOOL\ncase 0x8b53:case 0x8b57:return setValue2iv;// _VEC2\ncase 0x8b54:case 0x8b58:return setValue3iv;// _VEC3\ncase 0x8b55:case 0x8b59:return setValue4iv;// _VEC4\n}\n\n\n}\n\n// --- Uniform Classes ---\n\nfunction SingleUniform(id,activeInfo,addr){\n\nthis.id=id;\nthis.addr=addr;\nthis.setValue=getSingularSetter(activeInfo.type);\n\n// this.path = activeInfo.name; // DEBUG\n\n}\n\nfunction PureArrayUniform(id,activeInfo,addr){\n\nthis.id=id;\nthis.addr=addr;\nthis.size=activeInfo.size;\nthis.setValue=getPureArraySetter(activeInfo.type);\n\n// this.path = activeInfo.name; // DEBUG\n\n}\n\nfunction StructuredUniform(id){\n\nthis.id=id;\n\nUniformContainer.call(this);// mix-in\n\n}\n\nStructuredUniform.prototype.setValue=function(gl,value){\n\n// Note: Don't need an extra 'renderer' parameter, since samplers\n// are not allowed in structured uniforms.\n\nvar seq=this.seq;\n\nfor(var i=0,n=seq.length;i!==n;++i){\n\nvar u=seq[i];\nu.setValue(gl,value[u.id]);\n\n}\n\n};\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nvar RePathPart=/([\\w\\d_]+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform(container,uniformObject){\n\ncontainer.seq.push(uniformObject);\ncontainer.map[uniformObject.id]=uniformObject;\n\n}\n\nfunction parseUniform(activeInfo,addr,container){\n\nvar path=activeInfo.name,\npathLength=path.length;\n\n// reset RegExp object, because of the early exit of a previous run\nRePathPart.lastIndex=0;\n\nfor(;;){\n\nvar match=RePathPart.exec(path),\nmatchEnd=RePathPart.lastIndex,\n\nid=match[1],\nidIsIndex=match[2]===']',\nsubscript=match[3];\n\nif(idIsIndex)id=id|0;// convert to integer\n\nif(subscript===undefined||\nsubscript==='['&&matchEnd+2===pathLength){\n// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\naddUniform(container,subscript===undefined?\nnew SingleUniform(id,activeInfo,addr):\nnew PureArrayUniform(id,activeInfo,addr));\n\nbreak;\n\n}else{\n// step into inner node / create it in case it doesn't exist\n\nvar map=container.map,\nnext=map[id];\n\nif(next===undefined){\n\nnext=new StructuredUniform(id);\naddUniform(container,next);\n\n}\n\ncontainer=next;\n\n}\n\n}\n\n}\n\n// Root Container\n\nfunction WebGLUniforms(gl,program,renderer){\n\nUniformContainer.call(this);\n\nthis.renderer=renderer;\n\nvar n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);\n\nfor(var i=0;i<n;++i){\n\nvar info=gl.getActiveUniform(program,i),\npath=info.name,\naddr=gl.getUniformLocation(program,path);\n\nparseUniform(info,addr,this);\n\n}\n\n}\n\nWebGLUniforms.prototype.setValue=function(gl,name,value){\n\nvar u=this.map[name];\n\nif(u!==undefined)u.setValue(gl,value,this.renderer);\n\n};\n\nWebGLUniforms.prototype.set=function(gl,object,name){\n\nvar u=this.map[name];\n\nif(u!==undefined)u.setValue(gl,object[name],this.renderer);\n\n};\n\nWebGLUniforms.prototype.setOptional=function(gl,object,name){\n\nvar v=object[name];\n\nif(v!==undefined)this.setValue(gl,name,v);\n\n};\n\n\n// Static interface\n\nWebGLUniforms.upload=function(gl,seq,values,renderer){\n\nfor(var i=0,n=seq.length;i!==n;++i){\n\nvar u=seq[i],\nv=values[u.id];\n\nif(v.needsUpdate!==false){\n// note: always updating when .needsUpdate is undefined\n\nu.setValue(gl,v.value,renderer);\n\n}\n\n}\n\n};\n\nWebGLUniforms.seqWithValue=function(seq,values){\n\nvar r=[];\n\nfor(var i=0,n=seq.length;i!==n;++i){\n\nvar u=seq[i];\nif(u.id in values)r.push(u);\n\n}\n\nreturn r;\n\n};\n\n/**\n\t * Uniform Utilities\n\t */\n\nvar UniformsUtils={\n\nmerge:function merge(uniforms){\n\nvar merged={};\n\nfor(var u=0;u<uniforms.length;u++){\n\nvar tmp=this.clone(uniforms[u]);\n\nfor(var p in tmp){\n\nmerged[p]=tmp[p];\n\n}\n\n}\n\nreturn merged;\n\n},\n\nclone:function clone(uniforms_src){\n\nvar uniforms_dst={};\n\nfor(var u in uniforms_src){\n\nuniforms_dst[u]={};\n\nfor(var p in uniforms_src[u]){\n\nvar parameter_src=uniforms_src[u][p];\n\nif(parameter_src&&(parameter_src.isColor||\nparameter_src.isMatrix3||parameter_src.isMatrix4||\nparameter_src.isVector2||parameter_src.isVector3||parameter_src.isVector4||\nparameter_src.isTexture)){\n\nuniforms_dst[u][p]=parameter_src.clone();\n\n}else if(Array.isArray(parameter_src)){\n\nuniforms_dst[u][p]=parameter_src.slice();\n\n}else{\n\nuniforms_dst[u][p]=parameter_src;\n\n}\n\n}\n\n}\n\nreturn uniforms_dst;\n\n}};\n\n\n\nvar alphamap_fragment=\"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\n\nvar alphamap_pars_fragment=\"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\\n\";\n\nvar alphatest_fragment=\"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\n\nvar aomap_fragment=\"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\\n\";\n\nvar aomap_pars_fragment=\"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar begin_vertex=\"\\nvec3 transformed = vec3( position );\\n\";\n\nvar beginnormal_vertex=\"\\nvec3 objectNormal = vec3( normal );\\n\";\n\nvar bsdfs=\"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 P = geometry.position;\\n\\tfloat theta = acos( dot( N, V ) );\\n\\tvec2 uv = vec2(\\n\\t\\tsqrt( saturate( roughness ) ),\\n\\t\\tsaturate( theta / ( 0.5 * PI ) ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\\n\\tint config = 0;\\n\\tif ( L[0].z > 0.0 ) config += 1;\\n\\tif ( L[1].z > 0.0 ) config += 2;\\n\\tif ( L[2].z > 0.0 ) config += 4;\\n\\tif ( L[3].z > 0.0 ) config += 8;\\n\\tn = 0;\\n\\tif ( config == 0 ) {\\n\\t} else if ( config == 1 ) {\\n\\t\\tn = 3;\\n\\t\\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\\n\\t\\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\\n\\t} else if ( config == 2 ) {\\n\\t\\tn = 3;\\n\\t\\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\\n\\t\\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\\n\\t} else if ( config == 3 ) {\\n\\t\\tn = 4;\\n\\t\\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\\n\\t\\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\\n\\t} else if ( config == 4 ) {\\n\\t\\tn = 3;\\n\\t\\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\\n\\t\\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\\n\\t} else if ( config == 5 ) {\\n\\t\\tn = 0;\\n\\t} else if ( config == 6 ) {\\n\\t\\tn = 4;\\n\\t\\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\\n\\t\\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\\n\\t} else if ( config == 7 ) {\\n\\t\\tn = 5;\\n\\t\\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\\n\\t\\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\\n\\t} else if ( config == 8 ) {\\n\\t\\tn = 3;\\n\\t\\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\\n\\t\\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\\n\\t\\tL[2] =  L[3];\\n\\t} else if ( config == 9 ) {\\n\\t\\tn = 4;\\n\\t\\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\\n\\t\\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\\n\\t} else if ( config == 10 ) {\\n\\t\\tn = 0;\\n\\t} else if ( config == 11 ) {\\n\\t\\tn = 5;\\n\\t\\tL[4] = L[3];\\n\\t\\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\\n\\t\\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\\n\\t} else if ( config == 12 ) {\\n\\t\\tn = 4;\\n\\t\\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\\n\\t\\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\\n\\t} else if ( config == 13 ) {\\n\\t\\tn = 5;\\n\\t\\tL[4] = L[3];\\n\\t\\tL[3] = L[2];\\n\\t\\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\\n\\t\\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\\n\\t} else if ( config == 14 ) {\\n\\t\\tn = 5;\\n\\t\\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\\n\\t\\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\\n\\t} else if ( config == 15 ) {\\n\\t\\tn = 4;\\n\\t}\\n\\tif ( n == 3 )\\n\\t\\tL[3] = L[0];\\n\\tif ( n == 4 )\\n\\t\\tL[4] = L[0];\\n}\\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\\n\\tfloat cosTheta = dot( v1, v2 );\\n\\tfloat theta = acos( cosTheta );\\n\\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\\n\\treturn res;\\n}\\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\\n\\trectPoints[0] = pos - halfWidth - halfHeight;\\n\\trectPoints[1] = pos + halfWidth - halfHeight;\\n\\trectPoints[2] = pos + halfWidth + halfHeight;\\n\\trectPoints[3] = pos - halfWidth + halfHeight;\\n}\\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 P = geometry.position;\\n\\tvec3 T1, T2;\\n\\tT1 = normalize(V - N * dot( V, N ));\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\\n\\tvec3 clippedRect[5];\\n\\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\\n\\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\\n\\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\\n\\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\\n\\tint n;\\n\\tclipQuadToHorizon(clippedRect, n);\\n\\tif ( n == 0 )\\n\\t\\treturn vec3( 0, 0, 0 );\\n\\tclippedRect[0] = normalize( clippedRect[0] );\\n\\tclippedRect[1] = normalize( clippedRect[1] );\\n\\tclippedRect[2] = normalize( clippedRect[2] );\\n\\tclippedRect[3] = normalize( clippedRect[3] );\\n\\tclippedRect[4] = normalize( clippedRect[4] );\\n\\tfloat sum = 0.0;\\n\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\\n\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\\n\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\\n\\tif (n >= 4)\\n\\t\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\\n\\tif (n == 5)\\n\\t\\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\\n\\tsum = max( 0.0, sum );\\n\\tvec3 Lo_i = vec3( sum, sum, sum );\\n\\treturn Lo_i;\\n}\\nvec3 Rect_Area_Light_Specular_Reflectance(\\n\\t\\tconst in GeometricContext geometry,\\n\\t\\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\\n\\t\\tconst in float roughness,\\n\\t\\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\\n\\tvec3 rectPoints[4];\\n\\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\\n\\tvec2 uv = ltcTextureCoords( geometry, roughness );\\n\\tvec4 brdfLtcApproxParams, t;\\n\\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\\n\\tt = texture2D( ltcMat, uv );\\n\\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\\n\\tmat3 brdfLtcApproxMat = mat3(\\n\\t\\tvec3(   1,   0, t.y ),\\n\\t\\tvec3(   0, t.z,   0 ),\\n\\t\\tvec3( t.w,   0, t.x )\\n\\t);\\n\\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\\n\\tspecularReflectance *= brdfLtcScalar;\\n\\treturn specularReflectance;\\n}\\nvec3 Rect_Area_Light_Diffuse_Reflectance(\\n\\t\\tconst in GeometricContext geometry,\\n\\t\\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\\n\\tvec3 rectPoints[4];\\n\\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\\n\\tmat3 diffuseBrdfMat = mat3(1);\\n\\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\\n\\treturn diffuseReflectance;\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\n\nvar bumpmap_pars_fragment=\"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n\";\n\nvar clipping_planes_fragment=\"#if NUM_CLIPPING_PLANES > 0\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\n\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t\\t\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\\t\\t\\tvec4 plane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\tif ( clipped ) discard;\\n\\t\\n\\t#endif\\n#endif\\n\";\n\nvar clipping_planes_pars_fragment=\"#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\n\nvar clipping_planes_pars_vertex=\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\";\n\nvar clipping_planes_vertex=\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\n\nvar color_fragment=\"#ifdef USE_COLOR\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment=\"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n\";\n\nvar color_pars_vertex=\"#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex=\"#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif\";\n\nvar common=\"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transpose( const in mat3 v ) {\\n\\tmat3 tmp;\\n\\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\\n\\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\\n\\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\\n\\treturn tmp;\\n}\\n\";\n\nvar cube_uv_reflection_fragment=\"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\\tvec3 absDirection = abs(direction);\\n\\tint face = -1;\\n\\tif( absDirection.x > absDirection.z ) {\\n\\t\\tif(absDirection.x > absDirection.y )\\n\\t\\t\\tface = direction.x > 0.0 ? 0 : 3;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\telse {\\n\\t\\tif(absDirection.z > absDirection.y )\\n\\t\\t\\tface = direction.z > 0.0 ? 2 : 5;\\n\\t\\telse\\n\\t\\t\\tface = direction.y > 0.0 ? 1 : 4;\\n\\t}\\n\\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\tfloat dxRoughness = dFdx(roughness);\\n\\tfloat dyRoughness = dFdy(roughness);\\n\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\tfloat mipLevel = 0.5 * log2(d);\\n\\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\tbool bRes = mipLevel == 0.0;\\n\\tscale =  bRes && (scale < a) ? a : scale;\\n\\tvec3 r;\\n\\tvec2 offset;\\n\\tint face = getFaceFromDirection(direction);\\n\\tfloat rcpPowScale = 1.0 / powScale;\\n\\tif( face == 0) {\\n\\t\\tr = vec3(direction.x, -direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 1) {\\n\\t\\tr = vec3(direction.y, direction.x, direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 2) {\\n\\t\\tr = vec3(direction.z, direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\n\\t}\\n\\telse if( face == 3) {\\n\\t\\tr = vec3(direction.x, direction.z, direction.y);\\n\\t\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse if( face == 4) {\\n\\t\\tr = vec3(direction.y, direction.x, -direction.z);\\n\\t\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\telse {\\n\\t\\tr = vec3(direction.z, -direction.x, direction.y);\\n\\t\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\\t\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\n\\t}\\n\\tr = normalize(r);\\n\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\\tvec2 base = offset + vec2( texelOffset );\\n\\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\\tfloat r1 = floor(roughnessVal);\\n\\tfloat r2 = r1 + 1.0;\\n\\tfloat t = fract(roughnessVal);\\n\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\tfloat s = mipInfo.y;\\n\\tfloat level0 = mipInfo.x;\\n\\tfloat level1 = level0 + 1.0;\\n\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\tvec4 result = mix(color10, color20, t);\\n\\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\n\nvar defaultnormal_vertex=\"#ifdef FLIP_SIDED\\n\\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\n\nvar displacementmap_pars_vertex=\"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n\";\n\nvar displacementmap_vertex=\"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\n\nvar emissivemap_fragment=\"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\n\nvar emissivemap_pars_fragment=\"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\\n\";\n\nvar encodings_fragment=\"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\n\nvar encodings_pars_fragment=\"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM            = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\n\\tD            = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract(Le);\\n\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n\\treturn vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\n\nvar envmap_fragment=\"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n\";\n\nvar envmap_pars_fragment=\"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\\tuniform float reflectivity;\\n\\tuniform float envMapIntensity;\\n#endif\\n#ifdef USE_ENVMAP\\n\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\tuniform float flipEnvMap;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\\n\";\n\nvar envmap_pars_vertex=\"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n\";\n\nvar envmap_vertex=\"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n\";\n\nvar fog_vertex=\"\\n#ifdef USE_FOG\\nfogDepth = -mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex=\"#ifdef USE_FOG\\n  varying float fogDepth;\\n#endif\\n\";\n\nvar fog_fragment=\"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\n\nvar fog_pars_fragment=\"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\\n\";\n\nvar gradientmap_pars_fragment=\"#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\nvar lightmap_fragment=\"#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\n\nvar lightmap_pars_fragment=\"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_vertex=\"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\nvar lights_pars=\"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t\\tint shadow;\\n\\t\\tfloat shadowBias;\\n\\t\\tfloat shadowRadius;\\n\\t\\tvec2 shadowMapSize;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltcMat;\\tuniform sampler2D ltcMag;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\t\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\t\\tvec2 sampleUV;\\n\\t\\t\\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\\n\\t\\t\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\t\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\\n\";\n\nvar lights_phong_fragment=\"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\n\nvar lights_phong_pars_fragment=\"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 matDiffColor = material.diffuseColor;\\n\\t\\tvec3 matSpecColor = material.specularColor;\\n\\t\\tvec3 lightColor   = rectAreaLight.color;\\n\\t\\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\\n\\t\\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\\n\\t\\t\\t\\troughness,\\n\\t\\t\\t\\tltcMat, ltcMag );\\n\\t\\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\\n\\t\\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\\n\\t\\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\\n\\t}\\n#endif\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n\";\n\nvar lights_physical_fragment=\"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.clearCoat = saturate( clearCoat );\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\n#endif\\n\";\n\nvar lights_physical_pars_fragment=\"struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 matDiffColor = material.diffuseColor;\\n\\t\\tvec3 matSpecColor = material.specularColor;\\n\\t\\tvec3 lightColor   = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\\n\\t\\t\\t\\troughness,\\n\\t\\t\\t\\tltcMat, ltcMag );\\n\\t\\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\\n\\t\\t\\t\\tgeometry,\\n\\t\\t\\t\\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\\n\\t\\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\\n\\t\\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\n\nvar lights_template=\"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#ifdef USE_SHADOWMAP\\n\\t\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\\t#endif\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\\t#ifndef STANDARD\\n\\t\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\n\\t#else\\n\\t\\tvec3 clearCoatRadiance = vec3( 0.0 );\\n\\t#endif\\n\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\n#endif\\n\";\n\nvar logdepthbuf_fragment=\"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment=\"#ifdef USE_LOGDEPTHBUF\\n\\tuniform float logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n#endif\\n\";\n\nvar logdepthbuf_pars_vertex=\"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t#endif\\n\\tuniform float logDepthBufFC;\\n#endif\";\n\nvar logdepthbuf_vertex=\"#ifdef USE_LOGDEPTHBUF\\n\\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t#else\\n\\t\\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\t#endif\\n#endif\\n\";\n\nvar map_fragment=\"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\\n\";\n\nvar map_pars_fragment=\"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\nvar map_particle_fragment=\"#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\n\nvar map_particle_pars_fragment=\"#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n\";\n\nvar metalnessmap_fragment=\"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\n\nvar metalnessmap_pars_fragment=\"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphnormal_vertex=\"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\n\nvar morphtarget_pars_vertex=\"#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\nvar morphtarget_vertex=\"#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n\";\n\nvar normal_flip=\"#ifdef DOUBLE_SIDED\\n\\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n#else\\n\\tfloat flipNormal = 1.0;\\n#endif\\n\";\n\nvar normal_fragment=\"#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal ) * flipNormal;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\n\nvar normalmap_pars_fragment=\"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\\t\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\\t\\tvec3 N = normalize( surf_norm );\\n\\t\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t\\tmapN.xy = normalScale * mapN.xy;\\n\\t\\tmat3 tsn = mat3( S, T, N );\\n\\t\\treturn normalize( tsn * mapN );\\n\\t}\\n#endif\\n\";\n\nvar packing=\"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\n\nvar premultiplied_alpha_fragment=\"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\n\nvar project_vertex=\"#ifdef USE_SKINNING\\n\\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\n\nvar roughnessmap_fragment=\"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\n\nvar roughnessmap_pars_fragment=\"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment=\"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n\";\n\nvar shadowmap_pars_vertex=\"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n\";\n\nvar shadowmap_vertex=\"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\\t}\\n\\t#endif\\n#endif\\n\";\n\nvar shadowmask_pars_fragment=\"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n\";\n\nvar skinbase_vertex=\"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex=\"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform sampler2D boneTexture;\\n\\t\\tuniform int boneTextureWidth;\\n\\t\\tuniform int boneTextureHeight;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureWidth ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureWidth );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\\n\";\n\nvar skinning_vertex=\"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\n\nvar skinnormal_vertex=\"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\n\nvar specularmap_fragment=\"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment=\"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment=\"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\n\nvar tonemapping_pars_fragment=\"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\n\nvar uv_pars_fragment=\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif\";\n\nvar uv_pars_vertex=\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n\";\n\nvar uv_vertex=\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\n\nvar uv2_pars_fragment=\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_pars_vertex=\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif\";\n\nvar uv2_vertex=\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif\";\n\nvar worldpos_vertex=\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\t#ifdef USE_SKINNING\\n\\t\\tvec4 worldPosition = modelMatrix * skinned;\\n\\t#else\\n\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t#endif\\n#endif\\n\";\n\nvar cube_frag=\"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n\";\n\nvar cube_vert=\"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\nvar depth_frag=\"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\\t#endif\\n}\\n\";\n\nvar depth_vert=\"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n\";\n\nvar distanceRGBA_frag=\"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\n\nvar distanceRGBA_vert=\"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n\";\n\nvar equirect_frag=\"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n\";\n\nvar equirect_vert=\"varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n\";\n\nvar linedashed_frag=\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar linedashed_vert=\"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\tvLineDistance = scale * lineDistance;\\n\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar meshbasic_frag=\"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar meshbasic_vert=\"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar meshlambert_frag=\"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar meshlambert_vert=\"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar meshphong_frag=\"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar meshphong_vert=\"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar meshphysical_frag=\"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar meshphysical_vert=\"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar normal_frag=\"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\\n\";\n\nvar normal_vert=\"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\\n\";\n\nvar points_frag=\"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n\";\n\nvar points_vert=\"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\\t#else\\n\\t\\tgl_PointSize = size;\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n\";\n\nvar shadow_frag=\"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\\n}\\n\";\n\nvar shadow_vert=\"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n}\\n\";\n\nvar ShaderChunk={\nalphamap_fragment:alphamap_fragment,\nalphamap_pars_fragment:alphamap_pars_fragment,\nalphatest_fragment:alphatest_fragment,\naomap_fragment:aomap_fragment,\naomap_pars_fragment:aomap_pars_fragment,\nbegin_vertex:begin_vertex,\nbeginnormal_vertex:beginnormal_vertex,\nbsdfs:bsdfs,\nbumpmap_pars_fragment:bumpmap_pars_fragment,\nclipping_planes_fragment:clipping_planes_fragment,\nclipping_planes_pars_fragment:clipping_planes_pars_fragment,\nclipping_planes_pars_vertex:clipping_planes_pars_vertex,\nclipping_planes_vertex:clipping_planes_vertex,\ncolor_fragment:color_fragment,\ncolor_pars_fragment:color_pars_fragment,\ncolor_pars_vertex:color_pars_vertex,\ncolor_vertex:color_vertex,\ncommon:common,\ncube_uv_reflection_fragment:cube_uv_reflection_fragment,\ndefaultnormal_vertex:defaultnormal_vertex,\ndisplacementmap_pars_vertex:displacementmap_pars_vertex,\ndisplacementmap_vertex:displacementmap_vertex,\nemissivemap_fragment:emissivemap_fragment,\nemissivemap_pars_fragment:emissivemap_pars_fragment,\nencodings_fragment:encodings_fragment,\nencodings_pars_fragment:encodings_pars_fragment,\nenvmap_fragment:envmap_fragment,\nenvmap_pars_fragment:envmap_pars_fragment,\nenvmap_pars_vertex:envmap_pars_vertex,\nenvmap_vertex:envmap_vertex,\nfog_vertex:fog_vertex,\nfog_pars_vertex:fog_pars_vertex,\nfog_fragment:fog_fragment,\nfog_pars_fragment:fog_pars_fragment,\ngradientmap_pars_fragment:gradientmap_pars_fragment,\nlightmap_fragment:lightmap_fragment,\nlightmap_pars_fragment:lightmap_pars_fragment,\nlights_lambert_vertex:lights_lambert_vertex,\nlights_pars:lights_pars,\nlights_phong_fragment:lights_phong_fragment,\nlights_phong_pars_fragment:lights_phong_pars_fragment,\nlights_physical_fragment:lights_physical_fragment,\nlights_physical_pars_fragment:lights_physical_pars_fragment,\nlights_template:lights_template,\nlogdepthbuf_fragment:logdepthbuf_fragment,\nlogdepthbuf_pars_fragment:logdepthbuf_pars_fragment,\nlogdepthbuf_pars_vertex:logdepthbuf_pars_vertex,\nlogdepthbuf_vertex:logdepthbuf_vertex,\nmap_fragment:map_fragment,\nmap_pars_fragment:map_pars_fragment,\nmap_particle_fragment:map_particle_fragment,\nmap_particle_pars_fragment:map_particle_pars_fragment,\nmetalnessmap_fragment:metalnessmap_fragment,\nmetalnessmap_pars_fragment:metalnessmap_pars_fragment,\nmorphnormal_vertex:morphnormal_vertex,\nmorphtarget_pars_vertex:morphtarget_pars_vertex,\nmorphtarget_vertex:morphtarget_vertex,\nnormal_flip:normal_flip,\nnormal_fragment:normal_fragment,\nnormalmap_pars_fragment:normalmap_pars_fragment,\npacking:packing,\npremultiplied_alpha_fragment:premultiplied_alpha_fragment,\nproject_vertex:project_vertex,\nroughnessmap_fragment:roughnessmap_fragment,\nroughnessmap_pars_fragment:roughnessmap_pars_fragment,\nshadowmap_pars_fragment:shadowmap_pars_fragment,\nshadowmap_pars_vertex:shadowmap_pars_vertex,\nshadowmap_vertex:shadowmap_vertex,\nshadowmask_pars_fragment:shadowmask_pars_fragment,\nskinbase_vertex:skinbase_vertex,\nskinning_pars_vertex:skinning_pars_vertex,\nskinning_vertex:skinning_vertex,\nskinnormal_vertex:skinnormal_vertex,\nspecularmap_fragment:specularmap_fragment,\nspecularmap_pars_fragment:specularmap_pars_fragment,\ntonemapping_fragment:tonemapping_fragment,\ntonemapping_pars_fragment:tonemapping_pars_fragment,\nuv_pars_fragment:uv_pars_fragment,\nuv_pars_vertex:uv_pars_vertex,\nuv_vertex:uv_vertex,\nuv2_pars_fragment:uv2_pars_fragment,\nuv2_pars_vertex:uv2_pars_vertex,\nuv2_vertex:uv2_vertex,\nworldpos_vertex:worldpos_vertex,\n\ncube_frag:cube_frag,\ncube_vert:cube_vert,\ndepth_frag:depth_frag,\ndepth_vert:depth_vert,\ndistanceRGBA_frag:distanceRGBA_frag,\ndistanceRGBA_vert:distanceRGBA_vert,\nequirect_frag:equirect_frag,\nequirect_vert:equirect_vert,\nlinedashed_frag:linedashed_frag,\nlinedashed_vert:linedashed_vert,\nmeshbasic_frag:meshbasic_frag,\nmeshbasic_vert:meshbasic_vert,\nmeshlambert_frag:meshlambert_frag,\nmeshlambert_vert:meshlambert_vert,\nmeshphong_frag:meshphong_frag,\nmeshphong_vert:meshphong_vert,\nmeshphysical_frag:meshphysical_frag,\nmeshphysical_vert:meshphysical_vert,\nnormal_frag:normal_frag,\nnormal_vert:normal_vert,\npoints_frag:points_frag,\npoints_vert:points_vert,\nshadow_frag:shadow_frag,\nshadow_vert:shadow_vert};\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Color(r,g,b){\n\nif(g===undefined&&b===undefined){\n\n// r is THREE.Color, hex or string\nreturn this.set(r);\n\n}\n\nreturn this.setRGB(r,g,b);\n\n}\n\nColor.prototype={\n\nconstructor:Color,\n\nisColor:true,\n\nr:1,g:1,b:1,\n\nset:function set(value){\n\nif(value&&value.isColor){\n\nthis.copy(value);\n\n}else if(typeof value==='number'){\n\nthis.setHex(value);\n\n}else if(typeof value==='string'){\n\nthis.setStyle(value);\n\n}\n\nreturn this;\n\n},\n\nsetScalar:function setScalar(scalar){\n\nthis.r=scalar;\nthis.g=scalar;\nthis.b=scalar;\n\nreturn this;\n\n},\n\nsetHex:function setHex(hex){\n\nhex=Math.floor(hex);\n\nthis.r=(hex>>16&255)/255;\nthis.g=(hex>>8&255)/255;\nthis.b=(hex&255)/255;\n\nreturn this;\n\n},\n\nsetRGB:function setRGB(r,g,b){\n\nthis.r=r;\nthis.g=g;\nthis.b=b;\n\nreturn this;\n\n},\n\nsetHSL:function(){\n\nfunction hue2rgb(p,q,t){\n\nif(t<0)t+=1;\nif(t>1)t-=1;\nif(t<1/6)return p+(q-p)*6*t;\nif(t<1/2)return q;\nif(t<2/3)return p+(q-p)*6*(2/3-t);\nreturn p;\n\n}\n\nreturn function setHSL(h,s,l){\n\n// h,s,l ranges are in 0.0 - 1.0\nh=_Math.euclideanModulo(h,1);\ns=_Math.clamp(s,0,1);\nl=_Math.clamp(l,0,1);\n\nif(s===0){\n\nthis.r=this.g=this.b=l;\n\n}else{\n\nvar p=l<=0.5?l*(1+s):l+s-l*s;\nvar q=2*l-p;\n\nthis.r=hue2rgb(q,p,h+1/3);\nthis.g=hue2rgb(q,p,h);\nthis.b=hue2rgb(q,p,h-1/3);\n\n}\n\nreturn this;\n\n};\n\n}(),\n\nsetStyle:function setStyle(style){\n\nfunction handleAlpha(string){\n\nif(string===undefined)return;\n\nif(parseFloat(string)<1){\n\nconsole.warn('THREE.Color: Alpha component of '+style+' will be ignored.');\n\n}\n\n}\n\n\nvar m;\n\nif(m=/^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(style)){\n\n// rgb / hsl\n\nvar color;\nvar name=m[1];\nvar components=m[2];\n\nswitch(name){\n\ncase'rgb':\ncase'rgba':\n\nif(color=/^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)){\n\n// rgb(255,0,0) rgba(255,0,0,0.5)\nthis.r=Math.min(255,parseInt(color[1],10))/255;\nthis.g=Math.min(255,parseInt(color[2],10))/255;\nthis.b=Math.min(255,parseInt(color[3],10))/255;\n\nhandleAlpha(color[5]);\n\nreturn this;\n\n}\n\nif(color=/^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)){\n\n// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\nthis.r=Math.min(100,parseInt(color[1],10))/100;\nthis.g=Math.min(100,parseInt(color[2],10))/100;\nthis.b=Math.min(100,parseInt(color[3],10))/100;\n\nhandleAlpha(color[5]);\n\nreturn this;\n\n}\n\nbreak;\n\ncase'hsl':\ncase'hsla':\n\nif(color=/^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components)){\n\n// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\nvar h=parseFloat(color[1])/360;\nvar s=parseInt(color[2],10)/100;\nvar l=parseInt(color[3],10)/100;\n\nhandleAlpha(color[5]);\n\nreturn this.setHSL(h,s,l);\n\n}\n\nbreak;}\n\n\n\n}else if(m=/^\\#([A-Fa-f0-9]+)$/.exec(style)){\n\n// hex color\n\nvar hex=m[1];\nvar size=hex.length;\n\nif(size===3){\n\n// #ff0\nthis.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;\nthis.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;\nthis.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;\n\nreturn this;\n\n}else if(size===6){\n\n// #ff0000\nthis.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;\nthis.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;\nthis.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;\n\nreturn this;\n\n}\n\n}\n\nif(style&&style.length>0){\n\n// color keywords\nvar hex=ColorKeywords[style];\n\nif(hex!==undefined){\n\n// red\nthis.setHex(hex);\n\n}else{\n\n// unknown color\nconsole.warn('THREE.Color: Unknown color '+style);\n\n}\n\n}\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor(this.r,this.g,this.b);\n\n},\n\ncopy:function copy(color){\n\nthis.r=color.r;\nthis.g=color.g;\nthis.b=color.b;\n\nreturn this;\n\n},\n\ncopyGammaToLinear:function copyGammaToLinear(color,gammaFactor){\n\nif(gammaFactor===undefined)gammaFactor=2.0;\n\nthis.r=Math.pow(color.r,gammaFactor);\nthis.g=Math.pow(color.g,gammaFactor);\nthis.b=Math.pow(color.b,gammaFactor);\n\nreturn this;\n\n},\n\ncopyLinearToGamma:function copyLinearToGamma(color,gammaFactor){\n\nif(gammaFactor===undefined)gammaFactor=2.0;\n\nvar safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;\n\nthis.r=Math.pow(color.r,safeInverse);\nthis.g=Math.pow(color.g,safeInverse);\nthis.b=Math.pow(color.b,safeInverse);\n\nreturn this;\n\n},\n\nconvertGammaToLinear:function convertGammaToLinear(){\n\nvar r=this.r,g=this.g,b=this.b;\n\nthis.r=r*r;\nthis.g=g*g;\nthis.b=b*b;\n\nreturn this;\n\n},\n\nconvertLinearToGamma:function convertLinearToGamma(){\n\nthis.r=Math.sqrt(this.r);\nthis.g=Math.sqrt(this.g);\nthis.b=Math.sqrt(this.b);\n\nreturn this;\n\n},\n\ngetHex:function getHex(){\n\nreturn this.r*255<<16^this.g*255<<8^this.b*255<<0;\n\n},\n\ngetHexString:function getHexString(){\n\nreturn('000000'+this.getHex().toString(16)).slice(-6);\n\n},\n\ngetHSL:function getHSL(optionalTarget){\n\n// h,s,l ranges are in 0.0 - 1.0\n\nvar hsl=optionalTarget||{h:0,s:0,l:0};\n\nvar r=this.r,g=this.g,b=this.b;\n\nvar max=Math.max(r,g,b);\nvar min=Math.min(r,g,b);\n\nvar hue,saturation;\nvar lightness=(min+max)/2.0;\n\nif(min===max){\n\nhue=0;\nsaturation=0;\n\n}else{\n\nvar delta=max-min;\n\nsaturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);\n\nswitch(max){\n\ncase r:hue=(g-b)/delta+(g<b?6:0);break;\ncase g:hue=(b-r)/delta+2;break;\ncase b:hue=(r-g)/delta+4;break;}\n\n\n\nhue/=6;\n\n}\n\nhsl.h=hue;\nhsl.s=saturation;\nhsl.l=lightness;\n\nreturn hsl;\n\n},\n\ngetStyle:function getStyle(){\n\nreturn'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';\n\n},\n\noffsetHSL:function offsetHSL(h,s,l){\n\nvar hsl=this.getHSL();\n\nhsl.h+=h;hsl.s+=s;hsl.l+=l;\n\nthis.setHSL(hsl.h,hsl.s,hsl.l);\n\nreturn this;\n\n},\n\nadd:function add(color){\n\nthis.r+=color.r;\nthis.g+=color.g;\nthis.b+=color.b;\n\nreturn this;\n\n},\n\naddColors:function addColors(color1,color2){\n\nthis.r=color1.r+color2.r;\nthis.g=color1.g+color2.g;\nthis.b=color1.b+color2.b;\n\nreturn this;\n\n},\n\naddScalar:function addScalar(s){\n\nthis.r+=s;\nthis.g+=s;\nthis.b+=s;\n\nreturn this;\n\n},\n\nsub:function sub(color){\n\nthis.r=Math.max(0,this.r-color.r);\nthis.g=Math.max(0,this.g-color.g);\nthis.b=Math.max(0,this.b-color.b);\n\nreturn this;\n\n},\n\nmultiply:function multiply(color){\n\nthis.r*=color.r;\nthis.g*=color.g;\nthis.b*=color.b;\n\nreturn this;\n\n},\n\nmultiplyScalar:function multiplyScalar(s){\n\nthis.r*=s;\nthis.g*=s;\nthis.b*=s;\n\nreturn this;\n\n},\n\nlerp:function lerp(color,alpha){\n\nthis.r+=(color.r-this.r)*alpha;\nthis.g+=(color.g-this.g)*alpha;\nthis.b+=(color.b-this.b)*alpha;\n\nreturn this;\n\n},\n\nequals:function equals(c){\n\nreturn c.r===this.r&&c.g===this.g&&c.b===this.b;\n\n},\n\nfromArray:function fromArray(array,offset){\n\nif(offset===undefined)offset=0;\n\nthis.r=array[offset];\nthis.g=array[offset+1];\nthis.b=array[offset+2];\n\nreturn this;\n\n},\n\ntoArray:function toArray(array,offset){\n\nif(array===undefined)array=[];\nif(offset===undefined)offset=0;\n\narray[offset]=this.r;\narray[offset+1]=this.g;\narray[offset+2]=this.b;\n\nreturn array;\n\n},\n\ntoJSON:function toJSON(){\n\nreturn this.getHex();\n\n}};\n\n\n\nvar ColorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,\n'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,\n'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,\n'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,\n'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,\n'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,\n'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,\n'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,\n'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,\n'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,\n'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,\n'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,\n'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,\n'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,\n'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,\n'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,\n'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,\n'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,\n'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,\n'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'red':0xFF0000,'rosybrown':0xBC8F8F,\n'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,\n'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,\n'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,\n'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction DataTexture(data,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){\n\nTexture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);\n\nthis.image={data:data,width:width,height:height};\n\nthis.magFilter=magFilter!==undefined?magFilter:NearestFilter;\nthis.minFilter=minFilter!==undefined?minFilter:NearestFilter;\n\nthis.generateMipmaps=false;\nthis.flipY=false;\nthis.unpackAlignment=1;\n\n}\n\nDataTexture.prototype=Object.create(Texture.prototype);\nDataTexture.prototype.constructor=DataTexture;\n\nDataTexture.prototype.isDataTexture=true;\n\n/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\nvar UniformsLib={\n\ncommon:{\n\ndiffuse:{value:new Color(0xeeeeee)},\nopacity:{value:1.0},\n\nmap:{value:null},\noffsetRepeat:{value:new Vector4(0,0,1,1)},\n\nspecularMap:{value:null},\nalphaMap:{value:null},\n\nenvMap:{value:null},\nflipEnvMap:{value:-1},\nreflectivity:{value:1.0},\nrefractionRatio:{value:0.98}},\n\n\n\naomap:{\n\naoMap:{value:null},\naoMapIntensity:{value:1}},\n\n\n\nlightmap:{\n\nlightMap:{value:null},\nlightMapIntensity:{value:1}},\n\n\n\nemissivemap:{\n\nemissiveMap:{value:null}},\n\n\n\nbumpmap:{\n\nbumpMap:{value:null},\nbumpScale:{value:1}},\n\n\n\nnormalmap:{\n\nnormalMap:{value:null},\nnormalScale:{value:new Vector2(1,1)}},\n\n\n\ndisplacementmap:{\n\ndisplacementMap:{value:null},\ndisplacementScale:{value:1},\ndisplacementBias:{value:0}},\n\n\n\nroughnessmap:{\n\nroughnessMap:{value:null}},\n\n\n\nmetalnessmap:{\n\nmetalnessMap:{value:null}},\n\n\n\ngradientmap:{\n\ngradientMap:{value:null}},\n\n\n\nfog:{\n\nfogDensity:{value:0.00025},\nfogNear:{value:1},\nfogFar:{value:2000},\nfogColor:{value:new Color(0xffffff)}},\n\n\n\nlights:{\n\nambientLightColor:{value:[]},\n\ndirectionalLights:{value:[],properties:{\ndirection:{},\ncolor:{},\n\nshadow:{},\nshadowBias:{},\nshadowRadius:{},\nshadowMapSize:{}}},\n\n\ndirectionalShadowMap:{value:[]},\ndirectionalShadowMatrix:{value:[]},\n\nspotLights:{value:[],properties:{\ncolor:{},\nposition:{},\ndirection:{},\ndistance:{},\nconeCos:{},\npenumbraCos:{},\ndecay:{},\n\nshadow:{},\nshadowBias:{},\nshadowRadius:{},\nshadowMapSize:{}}},\n\n\nspotShadowMap:{value:[]},\nspotShadowMatrix:{value:[]},\n\npointLights:{value:[],properties:{\ncolor:{},\nposition:{},\ndecay:{},\ndistance:{},\n\nshadow:{},\nshadowBias:{},\nshadowRadius:{},\nshadowMapSize:{}}},\n\n\npointShadowMap:{value:[]},\npointShadowMatrix:{value:[]},\n\nhemisphereLights:{value:[],properties:{\ndirection:{},\nskyColor:{},\ngroundColor:{}}},\n\n\n// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\nrectAreaLights:{value:[],properties:{\ncolor:{},\nposition:{},\nwidth:{},\nheight:{}}}},\n\n\n\n\npoints:{\n\ndiffuse:{value:new Color(0xeeeeee)},\nopacity:{value:1.0},\nsize:{value:1.0},\nscale:{value:1.0},\nmap:{value:null},\noffsetRepeat:{value:new Vector4(0,0,1,1)}}};\n\n\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t */\n\nvar ShaderLib={\n\nbasic:{\n\nuniforms:UniformsUtils.merge([\nUniformsLib.common,\nUniformsLib.aomap,\nUniformsLib.lightmap,\nUniformsLib.fog]),\n\n\nvertexShader:ShaderChunk.meshbasic_vert,\nfragmentShader:ShaderChunk.meshbasic_frag},\n\n\n\nlambert:{\n\nuniforms:UniformsUtils.merge([\nUniformsLib.common,\nUniformsLib.aomap,\nUniformsLib.lightmap,\nUniformsLib.emissivemap,\nUniformsLib.fog,\nUniformsLib.lights,\n{\nemissive:{value:new Color(0x000000)}}]),\n\n\n\nvertexShader:ShaderChunk.meshlambert_vert,\nfragmentShader:ShaderChunk.meshlambert_frag},\n\n\n\nphong:{\n\nuniforms:UniformsUtils.merge([\nUniformsLib.common,\nUniformsLib.aomap,\nUniformsLib.lightmap,\nUniformsLib.emissivemap,\nUniformsLib.bumpmap,\nUniformsLib.normalmap,\nUniformsLib.displacementmap,\nUniformsLib.gradientmap,\nUniformsLib.fog,\nUniformsLib.lights,\n{\nemissive:{value:new Color(0x000000)},\nspecular:{value:new Color(0x111111)},\nshininess:{value:30}}]),\n\n\n\nvertexShader:ShaderChunk.meshphong_vert,\nfragmentShader:ShaderChunk.meshphong_frag},\n\n\n\nstandard:{\n\nuniforms:UniformsUtils.merge([\nUniformsLib.common,\nUniformsLib.aomap,\nUniformsLib.lightmap,\nUniformsLib.emissivemap,\nUniformsLib.bumpmap,\nUniformsLib.normalmap,\nUniformsLib.displacementmap,\nUniformsLib.roughnessmap,\nUniformsLib.metalnessmap,\nUniformsLib.fog,\nUniformsLib.lights,\n{\nemissive:{value:new Color(0x000000)},\nroughness:{value:0.5},\nmetalness:{value:0},\nenvMapIntensity:{value:1}// temporary\n}]),\n\n\nvertexShader:ShaderChunk.meshphysical_vert,\nfragmentShader:ShaderChunk.meshphysical_frag},\n\n\n\npoints:{\n\nuniforms:UniformsUtils.merge([\nUniformsLib.points,\nUniformsLib.fog]),\n\n\nvertexShader:ShaderChunk.points_vert,\nfragmentShader:ShaderChunk.points_frag},\n\n\n\ndashed:{\n\nuniforms:UniformsUtils.merge([\nUniformsLib.common,\nUniformsLib.fog,\n{\nscale:{value:1},\ndashSize:{value:1},\ntotalSize:{value:2}}]),\n\n\n\nvertexShader:ShaderChunk.linedashed_vert,\nfragmentShader:ShaderChunk.linedashed_frag},\n\n\n\ndepth:{\n\nuniforms:UniformsUtils.merge([\nUniformsLib.common,\nUniformsLib.displacementmap]),\n\n\nvertexShader:ShaderChunk.depth_vert,\nfragmentShader:ShaderChunk.depth_frag},\n\n\n\nnormal:{\n\nuniforms:UniformsUtils.merge([\nUniformsLib.common,\nUniformsLib.bumpmap,\nUniformsLib.normalmap,\nUniformsLib.displacementmap,\n{\nopacity:{value:1.0}}]),\n\n\n\nvertexShader:ShaderChunk.normal_vert,\nfragmentShader:ShaderChunk.normal_frag},\n\n\n\n/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\ncube:{\n\nuniforms:{\ntCube:{value:null},\ntFlip:{value:-1},\nopacity:{value:1.0}},\n\n\nvertexShader:ShaderChunk.cube_vert,\nfragmentShader:ShaderChunk.cube_frag},\n\n\n\n/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\nequirect:{\n\nuniforms:{\ntEquirect:{value:null},\ntFlip:{value:-1}},\n\n\nvertexShader:ShaderChunk.equirect_vert,\nfragmentShader:ShaderChunk.equirect_frag},\n\n\n\ndistanceRGBA:{\n\nuniforms:{\nlightPos:{value:new Vector3()}},\n\n\nvertexShader:ShaderChunk.distanceRGBA_vert,\nfragmentShader:ShaderChunk.distanceRGBA_frag}};\n\n\n\n\n\nShaderLib.physical={\n\nuniforms:UniformsUtils.merge([\nShaderLib.standard.uniforms,\n{\nclearCoat:{value:0},\nclearCoatRoughness:{value:0}}]),\n\n\n\nvertexShader:ShaderChunk.meshphysical_vert,\nfragmentShader:ShaderChunk.meshphysical_frag};\n\n\n\n/**\n\t * @author bhouston / http://clara.io\n\t */\n\nfunction Box2(min,max){\n\nthis.min=min!==undefined?min:new Vector2(+Infinity,+Infinity);\nthis.max=max!==undefined?max:new Vector2(-Infinity,-Infinity);\n\n}\n\nBox2.prototype={\n\nconstructor:Box2,\n\nset:function set(min,max){\n\nthis.min.copy(min);\nthis.max.copy(max);\n\nreturn this;\n\n},\n\nsetFromPoints:function setFromPoints(points){\n\nthis.makeEmpty();\n\nfor(var i=0,il=points.length;i<il;i++){\n\nthis.expandByPoint(points[i]);\n\n}\n\nreturn this;\n\n},\n\nsetFromCenterAndSize:function(){\n\nvar v1=new Vector2();\n\nreturn function setFromCenterAndSize(center,size){\n\nvar halfSize=v1.copy(size).multiplyScalar(0.5);\nthis.min.copy(center).sub(halfSize);\nthis.max.copy(center).add(halfSize);\n\nreturn this;\n\n};\n\n}(),\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(box){\n\nthis.min.copy(box.min);\nthis.max.copy(box.max);\n\nreturn this;\n\n},\n\nmakeEmpty:function makeEmpty(){\n\nthis.min.x=this.min.y=+Infinity;\nthis.max.x=this.max.y=-Infinity;\n\nreturn this;\n\n},\n\nisEmpty:function isEmpty(){\n\n// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\nreturn this.max.x<this.min.x||this.max.y<this.min.y;\n\n},\n\ngetCenter:function getCenter(optionalTarget){\n\nvar result=optionalTarget||new Vector2();\nreturn this.isEmpty()?result.set(0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);\n\n},\n\ngetSize:function getSize(optionalTarget){\n\nvar result=optionalTarget||new Vector2();\nreturn this.isEmpty()?result.set(0,0):result.subVectors(this.max,this.min);\n\n},\n\nexpandByPoint:function expandByPoint(point){\n\nthis.min.min(point);\nthis.max.max(point);\n\nreturn this;\n\n},\n\nexpandByVector:function expandByVector(vector){\n\nthis.min.sub(vector);\nthis.max.add(vector);\n\nreturn this;\n\n},\n\nexpandByScalar:function expandByScalar(scalar){\n\nthis.min.addScalar(-scalar);\nthis.max.addScalar(scalar);\n\nreturn this;\n\n},\n\ncontainsPoint:function containsPoint(point){\n\nreturn point.x<this.min.x||point.x>this.max.x||\npoint.y<this.min.y||point.y>this.max.y?false:true;\n\n},\n\ncontainsBox:function containsBox(box){\n\nreturn this.min.x<=box.min.x&&box.max.x<=this.max.x&&\nthis.min.y<=box.min.y&&box.max.y<=this.max.y;\n\n},\n\ngetParameter:function getParameter(point,optionalTarget){\n\n// This can potentially have a divide by zero if the box\n// has a size dimension of 0.\n\nvar result=optionalTarget||new Vector2();\n\nreturn result.set(\n(point.x-this.min.x)/(this.max.x-this.min.x),\n(point.y-this.min.y)/(this.max.y-this.min.y));\n\n\n},\n\nintersectsBox:function intersectsBox(box){\n\n// using 6 splitting planes to rule out intersections.\nreturn box.max.x<this.min.x||box.min.x>this.max.x||\nbox.max.y<this.min.y||box.min.y>this.max.y?false:true;\n\n},\n\nclampPoint:function clampPoint(point,optionalTarget){\n\nvar result=optionalTarget||new Vector2();\nreturn result.copy(point).clamp(this.min,this.max);\n\n},\n\ndistanceToPoint:function(){\n\nvar v1=new Vector2();\n\nreturn function distanceToPoint(point){\n\nvar clampedPoint=v1.copy(point).clamp(this.min,this.max);\nreturn clampedPoint.sub(point).length();\n\n};\n\n}(),\n\nintersect:function intersect(box){\n\nthis.min.max(box.min);\nthis.max.min(box.max);\n\nreturn this;\n\n},\n\nunion:function union(box){\n\nthis.min.min(box.min);\nthis.max.max(box.max);\n\nreturn this;\n\n},\n\ntranslate:function translate(offset){\n\nthis.min.add(offset);\nthis.max.add(offset);\n\nreturn this;\n\n},\n\nequals:function equals(box){\n\nreturn box.min.equals(this.min)&&box.max.equals(this.max);\n\n}};\n\n\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction LensFlarePlugin(renderer,flares){\n\nvar gl=renderer.context;\nvar state=renderer.state;\n\nvar vertexBuffer,elementBuffer;\nvar shader,program,attributes,uniforms;\n\nvar tempTexture,occlusionTexture;\n\nfunction init(){\n\nvar vertices=new Float32Array([\n-1,-1,0,0,\n1,-1,1,0,\n1,1,1,1,\n-1,1,0,1]);\n\n\nvar faces=new Uint16Array([\n0,1,2,\n0,2,3]);\n\n\n// buffers\n\nvertexBuffer=gl.createBuffer();\nelementBuffer=gl.createBuffer();\n\ngl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);\ngl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);\n\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);\n\n// textures\n\ntempTexture=gl.createTexture();\nocclusionTexture=gl.createTexture();\n\nstate.bindTexture(gl.TEXTURE_2D,tempTexture);\ngl.texImage2D(gl.TEXTURE_2D,0,gl.RGB,16,16,0,gl.RGB,gl.UNSIGNED_BYTE,null);\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);\n\nstate.bindTexture(gl.TEXTURE_2D,occlusionTexture);\ngl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,16,16,0,gl.RGBA,gl.UNSIGNED_BYTE,null);\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);\n\nshader={\n\nvertexShader:[\n\n\"uniform lowp int renderType;\",\n\n\"uniform vec3 screenPosition;\",\n\"uniform vec2 scale;\",\n\"uniform float rotation;\",\n\n\"uniform sampler2D occlusionMap;\",\n\n\"attribute vec2 position;\",\n\"attribute vec2 uv;\",\n\n\"varying vec2 vUV;\",\n\"varying float vVisibility;\",\n\n\"void main() {\",\n\n\"vUV = uv;\",\n\n\"vec2 pos = position;\",\n\n\"if ( renderType == 2 ) {\",\n\n\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\"vVisibility =        visibility.r / 9.0;\",\n\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\"vVisibility *=       visibility.b / 9.0;\",\n\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\"}\",\n\n\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\"}\"].\n\njoin(\"\\n\"),\n\nfragmentShader:[\n\n\"uniform lowp int renderType;\",\n\n\"uniform sampler2D map;\",\n\"uniform float opacity;\",\n\"uniform vec3 color;\",\n\n\"varying vec2 vUV;\",\n\"varying float vVisibility;\",\n\n\"void main() {\",\n\n// pink square\n\n\"if ( renderType == 0 ) {\",\n\n\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n// restore\n\n\"} else if ( renderType == 1 ) {\",\n\n\"gl_FragColor = texture2D( map, vUV );\",\n\n// flare\n\n\"} else {\",\n\n\"vec4 texture = texture2D( map, vUV );\",\n\"texture.a *= opacity * vVisibility;\",\n\"gl_FragColor = texture;\",\n\"gl_FragColor.rgb *= color;\",\n\n\"}\",\n\n\"}\"].\n\njoin(\"\\n\")};\n\n\n\nprogram=createProgram(shader);\n\nattributes={\nvertex:gl.getAttribLocation(program,\"position\"),\nuv:gl.getAttribLocation(program,\"uv\")};\n\n\nuniforms={\nrenderType:gl.getUniformLocation(program,\"renderType\"),\nmap:gl.getUniformLocation(program,\"map\"),\nocclusionMap:gl.getUniformLocation(program,\"occlusionMap\"),\nopacity:gl.getUniformLocation(program,\"opacity\"),\ncolor:gl.getUniformLocation(program,\"color\"),\nscale:gl.getUniformLocation(program,\"scale\"),\nrotation:gl.getUniformLocation(program,\"rotation\"),\nscreenPosition:gl.getUniformLocation(program,\"screenPosition\")};\n\n\n}\n\n/*\n\t\t * Render lens flares\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t\t *         reads these back and calculates occlusion.\n\t\t */\n\nthis.render=function(scene,camera,viewport){\n\nif(flares.length===0)return;\n\nvar tempPosition=new Vector3();\n\nvar invAspect=viewport.w/viewport.z,\nhalfViewportWidth=viewport.z*0.5,\nhalfViewportHeight=viewport.w*0.5;\n\nvar size=16/viewport.w,\nscale=new Vector2(size*invAspect,size);\n\nvar screenPosition=new Vector3(1,1,0),\nscreenPositionPixels=new Vector2(1,1);\n\nvar validArea=new Box2();\n\nvalidArea.min.set(viewport.x,viewport.y);\nvalidArea.max.set(viewport.x+(viewport.z-16),viewport.y+(viewport.w-16));\n\nif(program===undefined){\n\ninit();\n\n}\n\ngl.useProgram(program);\n\nstate.initAttributes();\nstate.enableAttribute(attributes.vertex);\nstate.enableAttribute(attributes.uv);\nstate.disableUnusedAttributes();\n\n// loop through all lens flares to update their occlusion and positions\n// setup gl and common used attribs/uniforms\n\ngl.uniform1i(uniforms.occlusionMap,0);\ngl.uniform1i(uniforms.map,1);\n\ngl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);\ngl.vertexAttribPointer(attributes.vertex,2,gl.FLOAT,false,2*8,0);\ngl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);\n\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);\n\nstate.disable(gl.CULL_FACE);\nstate.setDepthWrite(false);\n\nfor(var i=0,l=flares.length;i<l;i++){\n\nsize=16/viewport.w;\nscale.set(size*invAspect,size);\n\n// calc object screen position\n\nvar flare=flares[i];\n\ntempPosition.set(flare.matrixWorld.elements[12],flare.matrixWorld.elements[13],flare.matrixWorld.elements[14]);\n\ntempPosition.applyMatrix4(camera.matrixWorldInverse);\ntempPosition.applyMatrix4(camera.projectionMatrix);\n\n// setup arrays for gl programs\n\nscreenPosition.copy(tempPosition);\n\n// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\nscreenPositionPixels.x=viewport.x+screenPosition.x*halfViewportWidth+halfViewportWidth-8;\nscreenPositionPixels.y=viewport.y+screenPosition.y*halfViewportHeight+halfViewportHeight-8;\n\n// screen cull\n\nif(validArea.containsPoint(screenPositionPixels)===true){\n\n// save current RGB to temp texture\n\nstate.activeTexture(gl.TEXTURE0);\nstate.bindTexture(gl.TEXTURE_2D,null);\nstate.activeTexture(gl.TEXTURE1);\nstate.bindTexture(gl.TEXTURE_2D,tempTexture);\ngl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGB,screenPositionPixels.x,screenPositionPixels.y,16,16,0);\n\n\n// render pink quad\n\ngl.uniform1i(uniforms.renderType,0);\ngl.uniform2f(uniforms.scale,scale.x,scale.y);\ngl.uniform3f(uniforms.screenPosition,screenPosition.x,screenPosition.y,screenPosition.z);\n\nstate.disable(gl.BLEND);\nstate.enable(gl.DEPTH_TEST);\n\ngl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);\n\n\n// copy result to occlusionMap\n\nstate.activeTexture(gl.TEXTURE0);\nstate.bindTexture(gl.TEXTURE_2D,occlusionTexture);\ngl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGBA,screenPositionPixels.x,screenPositionPixels.y,16,16,0);\n\n\n// restore graphics\n\ngl.uniform1i(uniforms.renderType,1);\nstate.disable(gl.DEPTH_TEST);\n\nstate.activeTexture(gl.TEXTURE1);\nstate.bindTexture(gl.TEXTURE_2D,tempTexture);\ngl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);\n\n\n// update object positions\n\nflare.positionScreen.copy(screenPosition);\n\nif(flare.customUpdateCallback){\n\nflare.customUpdateCallback(flare);\n\n}else{\n\nflare.updateLensFlares();\n\n}\n\n// render flares\n\ngl.uniform1i(uniforms.renderType,2);\nstate.enable(gl.BLEND);\n\nfor(var j=0,jl=flare.lensFlares.length;j<jl;j++){\n\nvar sprite=flare.lensFlares[j];\n\nif(sprite.opacity>0.001&&sprite.scale>0.001){\n\nscreenPosition.x=sprite.x;\nscreenPosition.y=sprite.y;\nscreenPosition.z=sprite.z;\n\nsize=sprite.size*sprite.scale/viewport.w;\n\nscale.x=size*invAspect;\nscale.y=size;\n\ngl.uniform3f(uniforms.screenPosition,screenPosition.x,screenPosition.y,screenPosition.z);\ngl.uniform2f(uniforms.scale,scale.x,scale.y);\ngl.uniform1f(uniforms.rotation,sprite.rotation);\n\ngl.uniform1f(uniforms.opacity,sprite.opacity);\ngl.uniform3f(uniforms.color,sprite.color.r,sprite.color.g,sprite.color.b);\n\nstate.setBlending(sprite.blending,sprite.blendEquation,sprite.blendSrc,sprite.blendDst);\nrenderer.setTexture2D(sprite.texture,1);\n\ngl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);\n\n}\n\n}\n\n}\n\n}\n\n// restore gl\n\nstate.enable(gl.CULL_FACE);\nstate.enable(gl.DEPTH_TEST);\nstate.setDepthWrite(true);\n\nrenderer.resetGLState();\n\n};\n\nfunction createProgram(shader){\n\nvar program=gl.createProgram();\n\nvar fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);\nvar vertexShader=gl.createShader(gl.VERTEX_SHADER);\n\nvar prefix=\"precision \"+renderer.getPrecision()+\" float;\\n\";\n\ngl.shaderSource(fragmentShader,prefix+shader.fragmentShader);\ngl.shaderSource(vertexShader,prefix+shader.vertexShader);\n\ngl.compileShader(fragmentShader);\ngl.compileShader(vertexShader);\n\ngl.attachShader(program,fragmentShader);\ngl.attachShader(program,vertexShader);\n\ngl.linkProgram(program);\n\nreturn program;\n\n}\n\n}\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction SpritePlugin(renderer,sprites){\n\nvar gl=renderer.context;\nvar state=renderer.state;\n\nvar vertexBuffer,elementBuffer;\nvar program,attributes,uniforms;\n\nvar texture;\n\n// decompose matrixWorld\n\nvar spritePosition=new Vector3();\nvar spriteRotation=new Quaternion();\nvar spriteScale=new Vector3();\n\nfunction init(){\n\nvar vertices=new Float32Array([\n-0.5,-0.5,0,0,\n0.5,-0.5,1,0,\n0.5,0.5,1,1,\n-0.5,0.5,0,1]);\n\n\nvar faces=new Uint16Array([\n0,1,2,\n0,2,3]);\n\n\nvertexBuffer=gl.createBuffer();\nelementBuffer=gl.createBuffer();\n\ngl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);\ngl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);\n\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);\n\nprogram=createProgram();\n\nattributes={\nposition:gl.getAttribLocation(program,'position'),\nuv:gl.getAttribLocation(program,'uv')};\n\n\nuniforms={\nuvOffset:gl.getUniformLocation(program,'uvOffset'),\nuvScale:gl.getUniformLocation(program,'uvScale'),\n\nrotation:gl.getUniformLocation(program,'rotation'),\nscale:gl.getUniformLocation(program,'scale'),\n\ncolor:gl.getUniformLocation(program,'color'),\nmap:gl.getUniformLocation(program,'map'),\nopacity:gl.getUniformLocation(program,'opacity'),\n\nmodelViewMatrix:gl.getUniformLocation(program,'modelViewMatrix'),\nprojectionMatrix:gl.getUniformLocation(program,'projectionMatrix'),\n\nfogType:gl.getUniformLocation(program,'fogType'),\nfogDensity:gl.getUniformLocation(program,'fogDensity'),\nfogNear:gl.getUniformLocation(program,'fogNear'),\nfogFar:gl.getUniformLocation(program,'fogFar'),\nfogColor:gl.getUniformLocation(program,'fogColor'),\n\nalphaTest:gl.getUniformLocation(program,'alphaTest')};\n\n\nvar canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');\ncanvas.width=8;\ncanvas.height=8;\n\nvar context=canvas.getContext('2d');\ncontext.fillStyle='white';\ncontext.fillRect(0,0,8,8);\n\ntexture=new Texture(canvas);\ntexture.needsUpdate=true;\n\n}\n\nthis.render=function(scene,camera){\n\nif(sprites.length===0)return;\n\n// setup gl\n\nif(program===undefined){\n\ninit();\n\n}\n\ngl.useProgram(program);\n\nstate.initAttributes();\nstate.enableAttribute(attributes.position);\nstate.enableAttribute(attributes.uv);\nstate.disableUnusedAttributes();\n\nstate.disable(gl.CULL_FACE);\nstate.enable(gl.BLEND);\n\ngl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);\ngl.vertexAttribPointer(attributes.position,2,gl.FLOAT,false,2*8,0);\ngl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);\n\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);\n\ngl.uniformMatrix4fv(uniforms.projectionMatrix,false,camera.projectionMatrix.elements);\n\nstate.activeTexture(gl.TEXTURE0);\ngl.uniform1i(uniforms.map,0);\n\nvar oldFogType=0;\nvar sceneFogType=0;\nvar fog=scene.fog;\n\nif(fog){\n\ngl.uniform3f(uniforms.fogColor,fog.color.r,fog.color.g,fog.color.b);\n\nif(fog.isFog){\n\ngl.uniform1f(uniforms.fogNear,fog.near);\ngl.uniform1f(uniforms.fogFar,fog.far);\n\ngl.uniform1i(uniforms.fogType,1);\noldFogType=1;\nsceneFogType=1;\n\n}else if(fog.isFogExp2){\n\ngl.uniform1f(uniforms.fogDensity,fog.density);\n\ngl.uniform1i(uniforms.fogType,2);\noldFogType=2;\nsceneFogType=2;\n\n}\n\n}else{\n\ngl.uniform1i(uniforms.fogType,0);\noldFogType=0;\nsceneFogType=0;\n\n}\n\n\n// update positions and sort\n\nfor(var i=0,l=sprites.length;i<l;i++){\n\nvar sprite=sprites[i];\n\nsprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,sprite.matrixWorld);\nsprite.z=-sprite.modelViewMatrix.elements[14];\n\n}\n\nsprites.sort(painterSortStable);\n\n// render all sprites\n\nvar scale=[];\n\nfor(var i=0,l=sprites.length;i<l;i++){\n\nvar sprite=sprites[i];\nvar material=sprite.material;\n\nif(material.visible===false)continue;\n\ngl.uniform1f(uniforms.alphaTest,material.alphaTest);\ngl.uniformMatrix4fv(uniforms.modelViewMatrix,false,sprite.modelViewMatrix.elements);\n\nsprite.matrixWorld.decompose(spritePosition,spriteRotation,spriteScale);\n\nscale[0]=spriteScale.x;\nscale[1]=spriteScale.y;\n\nvar fogType=0;\n\nif(scene.fog&&material.fog){\n\nfogType=sceneFogType;\n\n}\n\nif(oldFogType!==fogType){\n\ngl.uniform1i(uniforms.fogType,fogType);\noldFogType=fogType;\n\n}\n\nif(material.map!==null){\n\ngl.uniform2f(uniforms.uvOffset,material.map.offset.x,material.map.offset.y);\ngl.uniform2f(uniforms.uvScale,material.map.repeat.x,material.map.repeat.y);\n\n}else{\n\ngl.uniform2f(uniforms.uvOffset,0,0);\ngl.uniform2f(uniforms.uvScale,1,1);\n\n}\n\ngl.uniform1f(uniforms.opacity,material.opacity);\ngl.uniform3f(uniforms.color,material.color.r,material.color.g,material.color.b);\n\ngl.uniform1f(uniforms.rotation,material.rotation);\ngl.uniform2fv(uniforms.scale,scale);\n\nstate.setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst);\nstate.setDepthTest(material.depthTest);\nstate.setDepthWrite(material.depthWrite);\n\nif(material.map){\n\nrenderer.setTexture2D(material.map,0);\n\n}else{\n\nrenderer.setTexture2D(texture,0);\n\n}\n\ngl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);\n\n}\n\n// restore gl\n\nstate.enable(gl.CULL_FACE);\n\nrenderer.resetGLState();\n\n};\n\nfunction createProgram(){\n\nvar program=gl.createProgram();\n\nvar vertexShader=gl.createShader(gl.VERTEX_SHADER);\nvar fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);\n\ngl.shaderSource(vertexShader,[\n\n'precision '+renderer.getPrecision()+' float;',\n\n'uniform mat4 modelViewMatrix;',\n'uniform mat4 projectionMatrix;',\n'uniform float rotation;',\n'uniform vec2 scale;',\n'uniform vec2 uvOffset;',\n'uniform vec2 uvScale;',\n\n'attribute vec2 position;',\n'attribute vec2 uv;',\n\n'varying vec2 vUV;',\n\n'void main() {',\n\n'vUV = uvOffset + uv * uvScale;',\n\n'vec2 alignedPosition = position * scale;',\n\n'vec2 rotatedPosition;',\n'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n'vec4 finalPosition;',\n\n'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n'finalPosition.xy += rotatedPosition;',\n'finalPosition = projectionMatrix * finalPosition;',\n\n'gl_Position = finalPosition;',\n\n'}'].\n\njoin('\\n'));\n\ngl.shaderSource(fragmentShader,[\n\n'precision '+renderer.getPrecision()+' float;',\n\n'uniform vec3 color;',\n'uniform sampler2D map;',\n'uniform float opacity;',\n\n'uniform int fogType;',\n'uniform vec3 fogColor;',\n'uniform float fogDensity;',\n'uniform float fogNear;',\n'uniform float fogFar;',\n'uniform float alphaTest;',\n\n'varying vec2 vUV;',\n\n'void main() {',\n\n'vec4 texture = texture2D( map, vUV );',\n\n'if ( texture.a < alphaTest ) discard;',\n\n'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n'if ( fogType > 0 ) {',\n\n'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n'float fogFactor = 0.0;',\n\n'if ( fogType == 1 ) {',\n\n'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n'} else {',\n\n'const float LOG2 = 1.442695;',\n'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n'}',\n\n'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n'}',\n\n'}'].\n\njoin('\\n'));\n\ngl.compileShader(vertexShader);\ngl.compileShader(fragmentShader);\n\ngl.attachShader(program,vertexShader);\ngl.attachShader(program,fragmentShader);\n\ngl.linkProgram(program);\n\nreturn program;\n\n}\n\nfunction painterSortStable(a,b){\n\nif(a.renderOrder!==b.renderOrder){\n\nreturn a.renderOrder-b.renderOrder;\n\n}else if(a.z!==b.z){\n\nreturn b.z-a.z;\n\n}else{\n\nreturn b.id-a.id;\n\n}\n\n}\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nvar materialId=0;\n\nfunction Material(){\n\nObject.defineProperty(this,'id',{value:materialId++});\n\nthis.uuid=_Math.generateUUID();\n\nthis.name='';\nthis.type='Material';\n\nthis.fog=true;\nthis.lights=true;\n\nthis.blending=NormalBlending;\nthis.side=FrontSide;\nthis.shading=SmoothShading;// THREE.FlatShading, THREE.SmoothShading\nthis.vertexColors=NoColors;// THREE.NoColors, THREE.VertexColors, THREE.FaceColors\n\nthis.opacity=1;\nthis.transparent=false;\n\nthis.blendSrc=SrcAlphaFactor;\nthis.blendDst=OneMinusSrcAlphaFactor;\nthis.blendEquation=AddEquation;\nthis.blendSrcAlpha=null;\nthis.blendDstAlpha=null;\nthis.blendEquationAlpha=null;\n\nthis.depthFunc=LessEqualDepth;\nthis.depthTest=true;\nthis.depthWrite=true;\n\nthis.clippingPlanes=null;\nthis.clipIntersection=false;\nthis.clipShadows=false;\n\nthis.colorWrite=true;\n\nthis.precision=null;// override the renderer's default precision for this material\n\nthis.polygonOffset=false;\nthis.polygonOffsetFactor=0;\nthis.polygonOffsetUnits=0;\n\nthis.alphaTest=0;\nthis.premultipliedAlpha=false;\n\nthis.overdraw=0;// Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\nthis.visible=true;\n\nthis._needsUpdate=true;\n\n}\n\nMaterial.prototype={\n\nconstructor:Material,\n\nisMaterial:true,\n\nget needsUpdate(){\n\nreturn this._needsUpdate;\n\n},\n\nset needsUpdate(value){\n\nif(value===true)this.update();\nthis._needsUpdate=value;\n\n},\n\nsetValues:function setValues(values){\n\nif(values===undefined)return;\n\nfor(var key in values){\n\nvar newValue=values[key];\n\nif(newValue===undefined){\n\nconsole.warn(\"THREE.Material: '\"+key+\"' parameter is undefined.\");\ncontinue;\n\n}\n\nvar currentValue=this[key];\n\nif(currentValue===undefined){\n\nconsole.warn(\"THREE.\"+this.type+\": '\"+key+\"' is not a property of this material.\");\ncontinue;\n\n}\n\nif(currentValue&&currentValue.isColor){\n\ncurrentValue.set(newValue);\n\n}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){\n\ncurrentValue.copy(newValue);\n\n}else if(key==='overdraw'){\n\n// ensure overdraw is backwards-compatible with legacy boolean type\nthis[key]=Number(newValue);\n\n}else{\n\nthis[key]=newValue;\n\n}\n\n}\n\n},\n\ntoJSON:function toJSON(meta){\n\nvar isRoot=meta===undefined;\n\nif(isRoot){\n\nmeta={\ntextures:{},\nimages:{}};\n\n\n}\n\nvar data={\nmetadata:{\nversion:4.4,\ntype:'Material',\ngenerator:'Material.toJSON'}};\n\n\n\n// standard Material serialization\ndata.uuid=this.uuid;\ndata.type=this.type;\n\nif(this.name!=='')data.name=this.name;\n\nif(this.color&&this.color.isColor)data.color=this.color.getHex();\n\nif(this.roughness!==undefined)data.roughness=this.roughness;\nif(this.metalness!==undefined)data.metalness=this.metalness;\n\nif(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();\nif(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();\nif(this.shininess!==undefined)data.shininess=this.shininess;\nif(this.clearCoat!==undefined)data.clearCoat=this.clearCoat;\nif(this.clearCoatRoughness!==undefined)data.clearCoatRoughness=this.clearCoatRoughness;\n\nif(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;\nif(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;\nif(this.lightMap&&this.lightMap.isTexture)data.lightMap=this.lightMap.toJSON(meta).uuid;\nif(this.bumpMap&&this.bumpMap.isTexture){\n\ndata.bumpMap=this.bumpMap.toJSON(meta).uuid;\ndata.bumpScale=this.bumpScale;\n\n}\nif(this.normalMap&&this.normalMap.isTexture){\n\ndata.normalMap=this.normalMap.toJSON(meta).uuid;\ndata.normalScale=this.normalScale.toArray();\n\n}\nif(this.displacementMap&&this.displacementMap.isTexture){\n\ndata.displacementMap=this.displacementMap.toJSON(meta).uuid;\ndata.displacementScale=this.displacementScale;\ndata.displacementBias=this.displacementBias;\n\n}\nif(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;\nif(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;\n\nif(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;\nif(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;\n\nif(this.envMap&&this.envMap.isTexture){\n\ndata.envMap=this.envMap.toJSON(meta).uuid;\ndata.reflectivity=this.reflectivity;// Scale behind envMap\n\n}\n\nif(this.gradientMap&&this.gradientMap.isTexture){\n\ndata.gradientMap=this.gradientMap.toJSON(meta).uuid;\n\n}\n\nif(this.size!==undefined)data.size=this.size;\nif(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;\n\nif(this.blending!==NormalBlending)data.blending=this.blending;\nif(this.shading!==SmoothShading)data.shading=this.shading;\nif(this.side!==FrontSide)data.side=this.side;\nif(this.vertexColors!==NoColors)data.vertexColors=this.vertexColors;\n\nif(this.opacity<1)data.opacity=this.opacity;\nif(this.transparent===true)data.transparent=this.transparent;\n\ndata.depthFunc=this.depthFunc;\ndata.depthTest=this.depthTest;\ndata.depthWrite=this.depthWrite;\n\nif(this.alphaTest>0)data.alphaTest=this.alphaTest;\nif(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;\nif(this.wireframe===true)data.wireframe=this.wireframe;\nif(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;\nif(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;\nif(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;\n\ndata.skinning=this.skinning;\ndata.morphTargets=this.morphTargets;\n\n// TODO: Copied from Object3D.toJSON\n\nfunction extractFromCache(cache){\n\nvar values=[];\n\nfor(var key in cache){\n\nvar data=cache[key];\ndelete data.metadata;\nvalues.push(data);\n\n}\n\nreturn values;\n\n}\n\nif(isRoot){\n\nvar textures=extractFromCache(meta.textures);\nvar images=extractFromCache(meta.images);\n\nif(textures.length>0)data.textures=textures;\nif(images.length>0)data.images=images;\n\n}\n\nreturn data;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(source){\n\nthis.name=source.name;\n\nthis.fog=source.fog;\nthis.lights=source.lights;\n\nthis.blending=source.blending;\nthis.side=source.side;\nthis.shading=source.shading;\nthis.vertexColors=source.vertexColors;\n\nthis.opacity=source.opacity;\nthis.transparent=source.transparent;\n\nthis.blendSrc=source.blendSrc;\nthis.blendDst=source.blendDst;\nthis.blendEquation=source.blendEquation;\nthis.blendSrcAlpha=source.blendSrcAlpha;\nthis.blendDstAlpha=source.blendDstAlpha;\nthis.blendEquationAlpha=source.blendEquationAlpha;\n\nthis.depthFunc=source.depthFunc;\nthis.depthTest=source.depthTest;\nthis.depthWrite=source.depthWrite;\n\nthis.colorWrite=source.colorWrite;\n\nthis.precision=source.precision;\n\nthis.polygonOffset=source.polygonOffset;\nthis.polygonOffsetFactor=source.polygonOffsetFactor;\nthis.polygonOffsetUnits=source.polygonOffsetUnits;\n\nthis.alphaTest=source.alphaTest;\n\nthis.premultipliedAlpha=source.premultipliedAlpha;\n\nthis.overdraw=source.overdraw;\n\nthis.visible=source.visible;\nthis.clipShadows=source.clipShadows;\nthis.clipIntersection=source.clipIntersection;\n\nvar srcPlanes=source.clippingPlanes,\ndstPlanes=null;\n\nif(srcPlanes!==null){\n\nvar n=srcPlanes.length;\ndstPlanes=new Array(n);\n\nfor(var i=0;i!==n;++i){\ndstPlanes[i]=srcPlanes[i].clone();}\n\n}\n\nthis.clippingPlanes=dstPlanes;\n\nreturn this;\n\n},\n\nupdate:function update(){\n\nthis.dispatchEvent({type:'update'});\n\n},\n\ndispose:function dispose(){\n\nthis.dispatchEvent({type:'dispose'});\n\n}};\n\n\n\nObject.assign(Material.prototype,EventDispatcher.prototype);\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  defines: { \"label\" : \"value\" },\n\t *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *  fragmentShader: <string>,\n\t *  vertexShader: <string>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  lights: <bool>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\nfunction ShaderMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='ShaderMaterial';\n\nthis.defines={};\nthis.uniforms={};\n\nthis.vertexShader='void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\nthis.fragmentShader='void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\n\nthis.linewidth=1;\n\nthis.wireframe=false;\nthis.wireframeLinewidth=1;\n\nthis.fog=false;// set to use scene fog\nthis.lights=false;// set to use scene lights\nthis.clipping=false;// set to use user-defined clipping planes\n\nthis.skinning=false;// set to use skinning attribute streams\nthis.morphTargets=false;// set to use morph targets\nthis.morphNormals=false;// set to use morph normals\n\nthis.extensions={\nderivatives:false,// set to use derivatives\nfragDepth:false,// set to use fragment depth values\ndrawBuffers:false,// set to use draw buffers\nshaderTextureLOD:false// set to use shader texture LOD\n};\n\n// When rendered geometry doesn't include these attributes but the material does,\n// use these default values in WebGL. This avoids errors when buffer data is missing.\nthis.defaultAttributeValues={\n'color':[1,1,1],\n'uv':[0,0],\n'uv2':[0,0]};\n\n\nthis.index0AttributeName=undefined;\n\nif(parameters!==undefined){\n\nif(parameters.attributes!==undefined){\n\nconsole.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n\n}\n\nthis.setValues(parameters);\n\n}\n\n}\n\nShaderMaterial.prototype=Object.create(Material.prototype);\nShaderMaterial.prototype.constructor=ShaderMaterial;\n\nShaderMaterial.prototype.isShaderMaterial=true;\n\nShaderMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.fragmentShader=source.fragmentShader;\nthis.vertexShader=source.vertexShader;\n\nthis.uniforms=UniformsUtils.clone(source.uniforms);\n\nthis.defines=source.defines;\n\nthis.wireframe=source.wireframe;\nthis.wireframeLinewidth=source.wireframeLinewidth;\n\nthis.lights=source.lights;\nthis.clipping=source.clipping;\n\nthis.skinning=source.skinning;\n\nthis.morphTargets=source.morphTargets;\nthis.morphNormals=source.morphNormals;\n\nthis.extensions=source.extensions;\n\nreturn this;\n\n};\n\nShaderMaterial.prototype.toJSON=function(meta){\n\nvar data=Material.prototype.toJSON.call(this,meta);\n\ndata.uniforms=this.uniforms;\ndata.vertexShader=this.vertexShader;\ndata.fragmentShader=this.fragmentShader;\n\nreturn data;\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / https://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t * }\n\t */\n\nfunction MeshDepthMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='MeshDepthMaterial';\n\nthis.depthPacking=BasicDepthPacking;\n\nthis.skinning=false;\nthis.morphTargets=false;\n\nthis.map=null;\n\nthis.alphaMap=null;\n\nthis.displacementMap=null;\nthis.displacementScale=1;\nthis.displacementBias=0;\n\nthis.wireframe=false;\nthis.wireframeLinewidth=1;\n\nthis.fog=false;\nthis.lights=false;\n\nthis.setValues(parameters);\n\n}\n\nMeshDepthMaterial.prototype=Object.create(Material.prototype);\nMeshDepthMaterial.prototype.constructor=MeshDepthMaterial;\n\nMeshDepthMaterial.prototype.isMeshDepthMaterial=true;\n\nMeshDepthMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.depthPacking=source.depthPacking;\n\nthis.skinning=source.skinning;\nthis.morphTargets=source.morphTargets;\n\nthis.map=source.map;\n\nthis.alphaMap=source.alphaMap;\n\nthis.displacementMap=source.displacementMap;\nthis.displacementScale=source.displacementScale;\nthis.displacementBias=source.displacementBias;\n\nthis.wireframe=source.wireframe;\nthis.wireframeLinewidth=source.wireframeLinewidth;\n\nreturn this;\n\n};\n\n/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\nfunction Box3(min,max){\n\nthis.min=min!==undefined?min:new Vector3(+Infinity,+Infinity,+Infinity);\nthis.max=max!==undefined?max:new Vector3(-Infinity,-Infinity,-Infinity);\n\n}\n\nBox3.prototype={\n\nconstructor:Box3,\n\nisBox3:true,\n\nset:function set(min,max){\n\nthis.min.copy(min);\nthis.max.copy(max);\n\nreturn this;\n\n},\n\nsetFromArray:function setFromArray(array){\n\nvar minX=+Infinity;\nvar minY=+Infinity;\nvar minZ=+Infinity;\n\nvar maxX=-Infinity;\nvar maxY=-Infinity;\nvar maxZ=-Infinity;\n\nfor(var i=0,l=array.length;i<l;i+=3){\n\nvar x=array[i];\nvar y=array[i+1];\nvar z=array[i+2];\n\nif(x<minX)minX=x;\nif(y<minY)minY=y;\nif(z<minZ)minZ=z;\n\nif(x>maxX)maxX=x;\nif(y>maxY)maxY=y;\nif(z>maxZ)maxZ=z;\n\n}\n\nthis.min.set(minX,minY,minZ);\nthis.max.set(maxX,maxY,maxZ);\n\nreturn this;\n\n},\n\nsetFromBufferAttribute:function setFromBufferAttribute(attribute){\n\nvar minX=+Infinity;\nvar minY=+Infinity;\nvar minZ=+Infinity;\n\nvar maxX=-Infinity;\nvar maxY=-Infinity;\nvar maxZ=-Infinity;\n\nfor(var i=0,l=attribute.count;i<l;i++){\n\nvar x=attribute.getX(i);\nvar y=attribute.getY(i);\nvar z=attribute.getZ(i);\n\nif(x<minX)minX=x;\nif(y<minY)minY=y;\nif(z<minZ)minZ=z;\n\nif(x>maxX)maxX=x;\nif(y>maxY)maxY=y;\nif(z>maxZ)maxZ=z;\n\n}\n\nthis.min.set(minX,minY,minZ);\nthis.max.set(maxX,maxY,maxZ);\n\nreturn this;\n\n},\n\nsetFromPoints:function setFromPoints(points){\n\nthis.makeEmpty();\n\nfor(var i=0,il=points.length;i<il;i++){\n\nthis.expandByPoint(points[i]);\n\n}\n\nreturn this;\n\n},\n\nsetFromCenterAndSize:function(){\n\nvar v1=new Vector3();\n\nreturn function setFromCenterAndSize(center,size){\n\nvar halfSize=v1.copy(size).multiplyScalar(0.5);\n\nthis.min.copy(center).sub(halfSize);\nthis.max.copy(center).add(halfSize);\n\nreturn this;\n\n};\n\n}(),\n\nsetFromObject:function setFromObject(object){\n\nthis.makeEmpty();\n\nreturn this.expandByObject(object);\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(box){\n\nthis.min.copy(box.min);\nthis.max.copy(box.max);\n\nreturn this;\n\n},\n\nmakeEmpty:function makeEmpty(){\n\nthis.min.x=this.min.y=this.min.z=+Infinity;\nthis.max.x=this.max.y=this.max.z=-Infinity;\n\nreturn this;\n\n},\n\nisEmpty:function isEmpty(){\n\n// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\nreturn this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;\n\n},\n\ngetCenter:function getCenter(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\nreturn this.isEmpty()?result.set(0,0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);\n\n},\n\ngetSize:function getSize(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\nreturn this.isEmpty()?result.set(0,0,0):result.subVectors(this.max,this.min);\n\n},\n\nexpandByPoint:function expandByPoint(point){\n\nthis.min.min(point);\nthis.max.max(point);\n\nreturn this;\n\n},\n\nexpandByVector:function expandByVector(vector){\n\nthis.min.sub(vector);\nthis.max.add(vector);\n\nreturn this;\n\n},\n\nexpandByScalar:function expandByScalar(scalar){\n\nthis.min.addScalar(-scalar);\nthis.max.addScalar(scalar);\n\nreturn this;\n\n},\n\nexpandByObject:function(){\n\n// Computes the world-axis-aligned bounding box of an object (including its children),\n// accounting for both the object's, and children's, world transforms\n\nvar v1=new Vector3();\n\nreturn function expandByObject(object){\n\nvar scope=this;\n\nobject.updateMatrixWorld(true);\n\nobject.traverse(function(node){\n\nvar i,l;\n\nvar geometry=node.geometry;\n\nif(geometry!==undefined){\n\nif(geometry.isGeometry){\n\nvar vertices=geometry.vertices;\n\nfor(i=0,l=vertices.length;i<l;i++){\n\nv1.copy(vertices[i]);\nv1.applyMatrix4(node.matrixWorld);\n\nscope.expandByPoint(v1);\n\n}\n\n}else if(geometry.isBufferGeometry){\n\nvar attribute=geometry.attributes.position;\n\nif(attribute!==undefined){\n\nfor(i=0,l=attribute.count;i<l;i++){\n\nv1.fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld);\n\nscope.expandByPoint(v1);\n\n}\n\n}\n\n}\n\n}\n\n});\n\nreturn this;\n\n};\n\n}(),\n\ncontainsPoint:function containsPoint(point){\n\nreturn point.x<this.min.x||point.x>this.max.x||\npoint.y<this.min.y||point.y>this.max.y||\npoint.z<this.min.z||point.z>this.max.z?false:true;\n\n},\n\ncontainsBox:function containsBox(box){\n\nreturn this.min.x<=box.min.x&&box.max.x<=this.max.x&&\nthis.min.y<=box.min.y&&box.max.y<=this.max.y&&\nthis.min.z<=box.min.z&&box.max.z<=this.max.z;\n\n},\n\ngetParameter:function getParameter(point,optionalTarget){\n\n// This can potentially have a divide by zero if the box\n// has a size dimension of 0.\n\nvar result=optionalTarget||new Vector3();\n\nreturn result.set(\n(point.x-this.min.x)/(this.max.x-this.min.x),\n(point.y-this.min.y)/(this.max.y-this.min.y),\n(point.z-this.min.z)/(this.max.z-this.min.z));\n\n\n},\n\nintersectsBox:function intersectsBox(box){\n\n// using 6 splitting planes to rule out intersections.\nreturn box.max.x<this.min.x||box.min.x>this.max.x||\nbox.max.y<this.min.y||box.min.y>this.max.y||\nbox.max.z<this.min.z||box.min.z>this.max.z?false:true;\n\n},\n\nintersectsSphere:function(){\n\nvar closestPoint;\n\nreturn function intersectsSphere(sphere){\n\nif(closestPoint===undefined)closestPoint=new Vector3();\n\n// Find the point on the AABB closest to the sphere center.\nthis.clampPoint(sphere.center,closestPoint);\n\n// If that point is inside the sphere, the AABB and sphere intersect.\nreturn closestPoint.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;\n\n};\n\n}(),\n\nintersectsPlane:function intersectsPlane(plane){\n\n// We compute the minimum and maximum dot product values. If those values\n// are on the same side (back or front) of the plane, then there is no intersection.\n\nvar min,max;\n\nif(plane.normal.x>0){\n\nmin=plane.normal.x*this.min.x;\nmax=plane.normal.x*this.max.x;\n\n}else{\n\nmin=plane.normal.x*this.max.x;\nmax=plane.normal.x*this.min.x;\n\n}\n\nif(plane.normal.y>0){\n\nmin+=plane.normal.y*this.min.y;\nmax+=plane.normal.y*this.max.y;\n\n}else{\n\nmin+=plane.normal.y*this.max.y;\nmax+=plane.normal.y*this.min.y;\n\n}\n\nif(plane.normal.z>0){\n\nmin+=plane.normal.z*this.min.z;\nmax+=plane.normal.z*this.max.z;\n\n}else{\n\nmin+=plane.normal.z*this.max.z;\nmax+=plane.normal.z*this.min.z;\n\n}\n\nreturn min<=plane.constant&&max>=plane.constant;\n\n},\n\nclampPoint:function clampPoint(point,optionalTarget){\n\nvar result=optionalTarget||new Vector3();\nreturn result.copy(point).clamp(this.min,this.max);\n\n},\n\ndistanceToPoint:function(){\n\nvar v1=new Vector3();\n\nreturn function distanceToPoint(point){\n\nvar clampedPoint=v1.copy(point).clamp(this.min,this.max);\nreturn clampedPoint.sub(point).length();\n\n};\n\n}(),\n\ngetBoundingSphere:function(){\n\nvar v1=new Vector3();\n\nreturn function getBoundingSphere(optionalTarget){\n\nvar result=optionalTarget||new Sphere();\n\nthis.getCenter(result.center);\n\nresult.radius=this.getSize(v1).length()*0.5;\n\nreturn result;\n\n};\n\n}(),\n\nintersect:function intersect(box){\n\nthis.min.max(box.min);\nthis.max.min(box.max);\n\n// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\nif(this.isEmpty())this.makeEmpty();\n\nreturn this;\n\n},\n\nunion:function union(box){\n\nthis.min.min(box.min);\nthis.max.max(box.max);\n\nreturn this;\n\n},\n\napplyMatrix4:function(){\n\nvar points=[\nnew Vector3(),\nnew Vector3(),\nnew Vector3(),\nnew Vector3(),\nnew Vector3(),\nnew Vector3(),\nnew Vector3(),\nnew Vector3()];\n\n\nreturn function applyMatrix4(matrix){\n\n// transform of empty box is an empty box.\nif(this.isEmpty())return this;\n\n// NOTE: I am using a binary pattern to specify all 2^3 combinations below\npoints[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000\npoints[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001\npoints[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010\npoints[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011\npoints[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100\npoints[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101\npoints[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110\npoints[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111\n\nthis.setFromPoints(points);\n\nreturn this;\n\n};\n\n}(),\n\ntranslate:function translate(offset){\n\nthis.min.add(offset);\nthis.max.add(offset);\n\nreturn this;\n\n},\n\nequals:function equals(box){\n\nreturn box.min.equals(this.min)&&box.max.equals(this.max);\n\n}};\n\n\n\n/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Sphere(center,radius){\n\nthis.center=center!==undefined?center:new Vector3();\nthis.radius=radius!==undefined?radius:0;\n\n}\n\nSphere.prototype={\n\nconstructor:Sphere,\n\nset:function set(center,radius){\n\nthis.center.copy(center);\nthis.radius=radius;\n\nreturn this;\n\n},\n\nsetFromPoints:function(){\n\nvar box;\n\nreturn function setFromPoints(points,optionalCenter){\n\nif(box===undefined)box=new Box3();// see #10547\n\nvar center=this.center;\n\nif(optionalCenter!==undefined){\n\ncenter.copy(optionalCenter);\n\n}else{\n\nbox.setFromPoints(points).getCenter(center);\n\n}\n\nvar maxRadiusSq=0;\n\nfor(var i=0,il=points.length;i<il;i++){\n\nmaxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));\n\n}\n\nthis.radius=Math.sqrt(maxRadiusSq);\n\nreturn this;\n\n};\n\n}(),\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(sphere){\n\nthis.center.copy(sphere.center);\nthis.radius=sphere.radius;\n\nreturn this;\n\n},\n\nempty:function empty(){\n\nreturn this.radius<=0;\n\n},\n\ncontainsPoint:function containsPoint(point){\n\nreturn point.distanceToSquared(this.center)<=this.radius*this.radius;\n\n},\n\ndistanceToPoint:function distanceToPoint(point){\n\nreturn point.distanceTo(this.center)-this.radius;\n\n},\n\nintersectsSphere:function intersectsSphere(sphere){\n\nvar radiusSum=this.radius+sphere.radius;\n\nreturn sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;\n\n},\n\nintersectsBox:function intersectsBox(box){\n\nreturn box.intersectsSphere(this);\n\n},\n\nintersectsPlane:function intersectsPlane(plane){\n\n// We use the following equation to compute the signed distance from\n// the center of the sphere to the plane.\n//\n// distance = q * n - d\n//\n// If this distance is greater than the radius of the sphere,\n// then there is no intersection.\n\nreturn Math.abs(this.center.dot(plane.normal)-plane.constant)<=this.radius;\n\n},\n\nclampPoint:function clampPoint(point,optionalTarget){\n\nvar deltaLengthSq=this.center.distanceToSquared(point);\n\nvar result=optionalTarget||new Vector3();\n\nresult.copy(point);\n\nif(deltaLengthSq>this.radius*this.radius){\n\nresult.sub(this.center).normalize();\nresult.multiplyScalar(this.radius).add(this.center);\n\n}\n\nreturn result;\n\n},\n\ngetBoundingBox:function getBoundingBox(optionalTarget){\n\nvar box=optionalTarget||new Box3();\n\nbox.set(this.center,this.center);\nbox.expandByScalar(this.radius);\n\nreturn box;\n\n},\n\napplyMatrix4:function applyMatrix4(matrix){\n\nthis.center.applyMatrix4(matrix);\nthis.radius=this.radius*matrix.getMaxScaleOnAxis();\n\nreturn this;\n\n},\n\ntranslate:function translate(offset){\n\nthis.center.add(offset);\n\nreturn this;\n\n},\n\nequals:function equals(sphere){\n\nreturn sphere.center.equals(this.center)&&sphere.radius===this.radius;\n\n}};\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t * @author tschw\n\t */\n\nfunction Matrix3(){\n\nthis.elements=new Float32Array([\n\n1,0,0,\n0,1,0,\n0,0,1]);\n\n\n\nif(arguments.length>0){\n\nconsole.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\n\n}\n\n}\n\nMatrix3.prototype={\n\nconstructor:Matrix3,\n\nisMatrix3:true,\n\nset:function set(n11,n12,n13,n21,n22,n23,n31,n32,n33){\n\nvar te=this.elements;\n\nte[0]=n11;te[1]=n21;te[2]=n31;\nte[3]=n12;te[4]=n22;te[5]=n32;\nte[6]=n13;te[7]=n23;te[8]=n33;\n\nreturn this;\n\n},\n\nidentity:function identity(){\n\nthis.set(\n\n1,0,0,\n0,1,0,\n0,0,1);\n\n\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().fromArray(this.elements);\n\n},\n\ncopy:function copy(m){\n\nvar me=m.elements;\n\nthis.set(\n\nme[0],me[3],me[6],\nme[1],me[4],me[7],\nme[2],me[5],me[8]);\n\n\n\nreturn this;\n\n},\n\nsetFromMatrix4:function setFromMatrix4(m){\n\nvar me=m.elements;\n\nthis.set(\n\nme[0],me[4],me[8],\nme[1],me[5],me[9],\nme[2],me[6],me[10]);\n\n\n\nreturn this;\n\n},\n\napplyToBufferAttribute:function(){\n\nvar v1;\n\nreturn function applyToBufferAttribute(attribute){\n\nif(v1===undefined)v1=new Vector3();\n\nfor(var i=0,l=attribute.count;i<l;i++){\n\nv1.x=attribute.getX(i);\nv1.y=attribute.getY(i);\nv1.z=attribute.getZ(i);\n\nv1.applyMatrix3(this);\n\nattribute.setXYZ(i,v1.x,v1.y,v1.z);\n\n}\n\nreturn attribute;\n\n};\n\n}(),\n\nmultiplyScalar:function multiplyScalar(s){\n\nvar te=this.elements;\n\nte[0]*=s;te[3]*=s;te[6]*=s;\nte[1]*=s;te[4]*=s;te[7]*=s;\nte[2]*=s;te[5]*=s;te[8]*=s;\n\nreturn this;\n\n},\n\ndeterminant:function determinant(){\n\nvar te=this.elements;\n\nvar a=te[0],b=te[1],c=te[2],\nd=te[3],e=te[4],f=te[5],\ng=te[6],h=te[7],i=te[8];\n\nreturn a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;\n\n},\n\ngetInverse:function getInverse(matrix,throwOnDegenerate){\n\nif(matrix&&matrix.isMatrix4){\n\nconsole.error(\"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\");\n\n}\n\nvar me=matrix.elements,\nte=this.elements,\n\nn11=me[0],n21=me[1],n31=me[2],\nn12=me[3],n22=me[4],n32=me[5],\nn13=me[6],n23=me[7],n33=me[8],\n\nt11=n33*n22-n32*n23,\nt12=n32*n13-n33*n12,\nt13=n23*n12-n22*n13,\n\ndet=n11*t11+n21*t12+n31*t13;\n\nif(det===0){\n\nvar msg=\"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\nif(throwOnDegenerate===true){\n\nthrow new Error(msg);\n\n}else{\n\nconsole.warn(msg);\n\n}\n\nreturn this.identity();\n}\n\nvar detInv=1/det;\n\nte[0]=t11*detInv;\nte[1]=(n31*n23-n33*n21)*detInv;\nte[2]=(n32*n21-n31*n22)*detInv;\n\nte[3]=t12*detInv;\nte[4]=(n33*n11-n31*n13)*detInv;\nte[5]=(n31*n12-n32*n11)*detInv;\n\nte[6]=t13*detInv;\nte[7]=(n21*n13-n23*n11)*detInv;\nte[8]=(n22*n11-n21*n12)*detInv;\n\nreturn this;\n\n},\n\ntranspose:function transpose(){\n\nvar tmp,m=this.elements;\n\ntmp=m[1];m[1]=m[3];m[3]=tmp;\ntmp=m[2];m[2]=m[6];m[6]=tmp;\ntmp=m[5];m[5]=m[7];m[7]=tmp;\n\nreturn this;\n\n},\n\ngetNormalMatrix:function getNormalMatrix(matrix4){\n\nreturn this.setFromMatrix4(matrix4).getInverse(this).transpose();\n\n},\n\ntransposeIntoArray:function transposeIntoArray(r){\n\nvar m=this.elements;\n\nr[0]=m[0];\nr[1]=m[3];\nr[2]=m[6];\nr[3]=m[1];\nr[4]=m[4];\nr[5]=m[7];\nr[6]=m[2];\nr[7]=m[5];\nr[8]=m[8];\n\nreturn this;\n\n},\n\nfromArray:function fromArray(array,offset){\n\nif(offset===undefined)offset=0;\n\nfor(var i=0;i<9;i++){\n\nthis.elements[i]=array[i+offset];\n\n}\n\nreturn this;\n\n},\n\ntoArray:function toArray(array,offset){\n\nif(array===undefined)array=[];\nif(offset===undefined)offset=0;\n\nvar te=this.elements;\n\narray[offset]=te[0];\narray[offset+1]=te[1];\narray[offset+2]=te[2];\n\narray[offset+3]=te[3];\narray[offset+4]=te[4];\narray[offset+5]=te[5];\n\narray[offset+6]=te[6];\narray[offset+7]=te[7];\narray[offset+8]=te[8];\n\nreturn array;\n\n}};\n\n\n\n/**\n\t * @author bhouston / http://clara.io\n\t */\n\nfunction Plane(normal,constant){\n\nthis.normal=normal!==undefined?normal:new Vector3(1,0,0);\nthis.constant=constant!==undefined?constant:0;\n\n}\n\nPlane.prototype={\n\nconstructor:Plane,\n\nset:function set(normal,constant){\n\nthis.normal.copy(normal);\nthis.constant=constant;\n\nreturn this;\n\n},\n\nsetComponents:function setComponents(x,y,z,w){\n\nthis.normal.set(x,y,z);\nthis.constant=w;\n\nreturn this;\n\n},\n\nsetFromNormalAndCoplanarPoint:function setFromNormalAndCoplanarPoint(normal,point){\n\nthis.normal.copy(normal);\nthis.constant=-point.dot(this.normal);// must be this.normal, not normal, as this.normal is normalized\n\nreturn this;\n\n},\n\nsetFromCoplanarPoints:function(){\n\nvar v1=new Vector3();\nvar v2=new Vector3();\n\nreturn function setFromCoplanarPoints(a,b,c){\n\nvar normal=v1.subVectors(c,b).cross(v2.subVectors(a,b)).normalize();\n\n// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\nthis.setFromNormalAndCoplanarPoint(normal,a);\n\nreturn this;\n\n};\n\n}(),\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(plane){\n\nthis.normal.copy(plane.normal);\nthis.constant=plane.constant;\n\nreturn this;\n\n},\n\nnormalize:function normalize(){\n\n// Note: will lead to a divide by zero if the plane is invalid.\n\nvar inverseNormalLength=1.0/this.normal.length();\nthis.normal.multiplyScalar(inverseNormalLength);\nthis.constant*=inverseNormalLength;\n\nreturn this;\n\n},\n\nnegate:function negate(){\n\nthis.constant*=-1;\nthis.normal.negate();\n\nreturn this;\n\n},\n\ndistanceToPoint:function distanceToPoint(point){\n\nreturn this.normal.dot(point)+this.constant;\n\n},\n\ndistanceToSphere:function distanceToSphere(sphere){\n\nreturn this.distanceToPoint(sphere.center)-sphere.radius;\n\n},\n\nprojectPoint:function projectPoint(point,optionalTarget){\n\nreturn this.orthoPoint(point,optionalTarget).sub(point).negate();\n\n},\n\northoPoint:function orthoPoint(point,optionalTarget){\n\nvar perpendicularMagnitude=this.distanceToPoint(point);\n\nvar result=optionalTarget||new Vector3();\nreturn result.copy(this.normal).multiplyScalar(perpendicularMagnitude);\n\n},\n\nintersectLine:function(){\n\nvar v1=new Vector3();\n\nreturn function intersectLine(line,optionalTarget){\n\nvar result=optionalTarget||new Vector3();\n\nvar direction=line.delta(v1);\n\nvar denominator=this.normal.dot(direction);\n\nif(denominator===0){\n\n// line is coplanar, return origin\nif(this.distanceToPoint(line.start)===0){\n\nreturn result.copy(line.start);\n\n}\n\n// Unsure if this is the correct method to handle this case.\nreturn undefined;\n\n}\n\nvar t=-(line.start.dot(this.normal)+this.constant)/denominator;\n\nif(t<0||t>1){\n\nreturn undefined;\n\n}\n\nreturn result.copy(direction).multiplyScalar(t).add(line.start);\n\n};\n\n}(),\n\nintersectsLine:function intersectsLine(line){\n\n// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\nvar startSign=this.distanceToPoint(line.start);\nvar endSign=this.distanceToPoint(line.end);\n\nreturn startSign<0&&endSign>0||endSign<0&&startSign>0;\n\n},\n\nintersectsBox:function intersectsBox(box){\n\nreturn box.intersectsPlane(this);\n\n},\n\nintersectsSphere:function intersectsSphere(sphere){\n\nreturn sphere.intersectsPlane(this);\n\n},\n\ncoplanarPoint:function coplanarPoint(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\nreturn result.copy(this.normal).multiplyScalar(-this.constant);\n\n},\n\napplyMatrix4:function(){\n\nvar v1=new Vector3();\nvar m1=new Matrix3();\n\nreturn function applyMatrix4(matrix,optionalNormalMatrix){\n\nvar referencePoint=this.coplanarPoint(v1).applyMatrix4(matrix);\n\n// transform normal based on theory here:\n// http://www.songho.ca/opengl/gl_normaltransform.html\nvar normalMatrix=optionalNormalMatrix||m1.getNormalMatrix(matrix);\nvar normal=this.normal.applyMatrix3(normalMatrix).normalize();\n\n// recalculate constant (like in setFromNormalAndCoplanarPoint)\nthis.constant=-referencePoint.dot(normal);\n\nreturn this;\n\n};\n\n}(),\n\ntranslate:function translate(offset){\n\nthis.constant=this.constant-offset.dot(this.normal);\n\nreturn this;\n\n},\n\nequals:function equals(plane){\n\nreturn plane.normal.equals(this.normal)&&plane.constant===this.constant;\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author bhouston / http://clara.io\n\t */\n\nfunction Frustum(p0,p1,p2,p3,p4,p5){\n\nthis.planes=[\n\np0!==undefined?p0:new Plane(),\np1!==undefined?p1:new Plane(),\np2!==undefined?p2:new Plane(),\np3!==undefined?p3:new Plane(),\np4!==undefined?p4:new Plane(),\np5!==undefined?p5:new Plane()];\n\n\n\n}\n\nFrustum.prototype={\n\nconstructor:Frustum,\n\nset:function set(p0,p1,p2,p3,p4,p5){\n\nvar planes=this.planes;\n\nplanes[0].copy(p0);\nplanes[1].copy(p1);\nplanes[2].copy(p2);\nplanes[3].copy(p3);\nplanes[4].copy(p4);\nplanes[5].copy(p5);\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(frustum){\n\nvar planes=this.planes;\n\nfor(var i=0;i<6;i++){\n\nplanes[i].copy(frustum.planes[i]);\n\n}\n\nreturn this;\n\n},\n\nsetFromMatrix:function setFromMatrix(m){\n\nvar planes=this.planes;\nvar me=m.elements;\nvar me0=me[0],me1=me[1],me2=me[2],me3=me[3];\nvar me4=me[4],me5=me[5],me6=me[6],me7=me[7];\nvar me8=me[8],me9=me[9],me10=me[10],me11=me[11];\nvar me12=me[12],me13=me[13],me14=me[14],me15=me[15];\n\nplanes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();\nplanes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();\nplanes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();\nplanes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();\nplanes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();\nplanes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();\n\nreturn this;\n\n},\n\nintersectsObject:function(){\n\nvar sphere=new Sphere();\n\nreturn function intersectsObject(object){\n\nvar geometry=object.geometry;\n\nif(geometry.boundingSphere===null)\ngeometry.computeBoundingSphere();\n\nsphere.copy(geometry.boundingSphere).\napplyMatrix4(object.matrixWorld);\n\nreturn this.intersectsSphere(sphere);\n\n};\n\n}(),\n\nintersectsSprite:function(){\n\nvar sphere=new Sphere();\n\nreturn function intersectsSprite(sprite){\n\nsphere.center.set(0,0,0);\nsphere.radius=0.7071067811865476;\nsphere.applyMatrix4(sprite.matrixWorld);\n\nreturn this.intersectsSphere(sphere);\n\n};\n\n}(),\n\nintersectsSphere:function intersectsSphere(sphere){\n\nvar planes=this.planes;\nvar center=sphere.center;\nvar negRadius=-sphere.radius;\n\nfor(var i=0;i<6;i++){\n\nvar distance=planes[i].distanceToPoint(center);\n\nif(distance<negRadius){\n\nreturn false;\n\n}\n\n}\n\nreturn true;\n\n},\n\nintersectsBox:function(){\n\nvar p1=new Vector3(),\np2=new Vector3();\n\nreturn function intersectsBox(box){\n\nvar planes=this.planes;\n\nfor(var i=0;i<6;i++){\n\nvar plane=planes[i];\n\np1.x=plane.normal.x>0?box.min.x:box.max.x;\np2.x=plane.normal.x>0?box.max.x:box.min.x;\np1.y=plane.normal.y>0?box.min.y:box.max.y;\np2.y=plane.normal.y>0?box.max.y:box.min.y;\np1.z=plane.normal.z>0?box.min.z:box.max.z;\np2.z=plane.normal.z>0?box.max.z:box.min.z;\n\nvar d1=plane.distanceToPoint(p1);\nvar d2=plane.distanceToPoint(p2);\n\n// if both outside plane, no intersection\n\nif(d1<0&&d2<0){\n\nreturn false;\n\n}\n\n}\n\nreturn true;\n\n};\n\n}(),\n\n\ncontainsPoint:function containsPoint(point){\n\nvar planes=this.planes;\n\nfor(var i=0;i<6;i++){\n\nif(planes[i].distanceToPoint(point)<0){\n\nreturn false;\n\n}\n\n}\n\nreturn true;\n\n}};\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLShadowMap(_renderer,_lights,_objects,capabilities){\n\nvar _gl=_renderer.context,\n_state=_renderer.state,\n_frustum=new Frustum(),\n_projScreenMatrix=new Matrix4(),\n\n_lightShadows=_lights.shadows,\n\n_shadowMapSize=new Vector2(),\n_maxShadowMapSize=new Vector2(capabilities.maxTextureSize,capabilities.maxTextureSize),\n\n_lookTarget=new Vector3(),\n_lightPositionWorld=new Vector3(),\n\n_renderList=[],\n\n_MorphingFlag=1,\n_SkinningFlag=2,\n\n_NumberOfMaterialVariants=(_MorphingFlag|_SkinningFlag)+1,\n\n_depthMaterials=new Array(_NumberOfMaterialVariants),\n_distanceMaterials=new Array(_NumberOfMaterialVariants),\n\n_materialCache={};\n\nvar cubeDirections=[\nnew Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),\nnew Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];\n\n\nvar cubeUps=[\nnew Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),\nnew Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];\n\n\nvar cube2DViewPorts=[\nnew Vector4(),new Vector4(),new Vector4(),\nnew Vector4(),new Vector4(),new Vector4()];\n\n\n// init\n\nvar depthMaterialTemplate=new MeshDepthMaterial();\ndepthMaterialTemplate.depthPacking=RGBADepthPacking;\ndepthMaterialTemplate.clipping=true;\n\nvar distanceShader=ShaderLib[\"distanceRGBA\"];\nvar distanceUniforms=UniformsUtils.clone(distanceShader.uniforms);\n\nfor(var i=0;i!==_NumberOfMaterialVariants;++i){\n\nvar useMorphing=(i&_MorphingFlag)!==0;\nvar useSkinning=(i&_SkinningFlag)!==0;\n\nvar depthMaterial=depthMaterialTemplate.clone();\ndepthMaterial.morphTargets=useMorphing;\ndepthMaterial.skinning=useSkinning;\n\n_depthMaterials[i]=depthMaterial;\n\nvar distanceMaterial=new ShaderMaterial({\ndefines:{\n'USE_SHADOWMAP':''},\n\nuniforms:distanceUniforms,\nvertexShader:distanceShader.vertexShader,\nfragmentShader:distanceShader.fragmentShader,\nmorphTargets:useMorphing,\nskinning:useSkinning,\nclipping:true});\n\n\n_distanceMaterials[i]=distanceMaterial;\n\n}\n\n//\n\nvar scope=this;\n\nthis.enabled=false;\n\nthis.autoUpdate=true;\nthis.needsUpdate=false;\n\nthis.type=PCFShadowMap;\n\nthis.renderReverseSided=true;\nthis.renderSingleSided=true;\n\nthis.render=function(scene,camera){\n\nif(scope.enabled===false)return;\nif(scope.autoUpdate===false&&scope.needsUpdate===false)return;\n\nif(_lightShadows.length===0)return;\n\n// Set GL state for depth map.\n_state.buffers.color.setClear(1,1,1,1);\n_state.disable(_gl.BLEND);\n_state.setDepthTest(true);\n_state.setScissorTest(false);\n\n// render depth map\n\nvar faceCount,isPointLight;\n\nfor(var i=0,il=_lightShadows.length;i<il;i++){\n\nvar light=_lightShadows[i];\nvar shadow=light.shadow;\n\nif(shadow===undefined){\n\nconsole.warn('THREE.WebGLShadowMap:',light,'has no shadow.');\ncontinue;\n\n}\n\nvar shadowCamera=shadow.camera;\n\n_shadowMapSize.copy(shadow.mapSize);\n_shadowMapSize.min(_maxShadowMapSize);\n\nif(light&&light.isPointLight){\n\nfaceCount=6;\nisPointLight=true;\n\nvar vpWidth=_shadowMapSize.x;\nvar vpHeight=_shadowMapSize.y;\n\n// These viewports map a cube-map onto a 2D texture with the\n// following orientation:\n//\n//  xzXZ\n//   y Y\n//\n// X - Positive x direction\n// x - Negative x direction\n// Y - Positive y direction\n// y - Negative y direction\n// Z - Positive z direction\n// z - Negative z direction\n\n// positive X\ncube2DViewPorts[0].set(vpWidth*2,vpHeight,vpWidth,vpHeight);\n// negative X\ncube2DViewPorts[1].set(0,vpHeight,vpWidth,vpHeight);\n// positive Z\ncube2DViewPorts[2].set(vpWidth*3,vpHeight,vpWidth,vpHeight);\n// negative Z\ncube2DViewPorts[3].set(vpWidth,vpHeight,vpWidth,vpHeight);\n// positive Y\ncube2DViewPorts[4].set(vpWidth*3,0,vpWidth,vpHeight);\n// negative Y\ncube2DViewPorts[5].set(vpWidth,0,vpWidth,vpHeight);\n\n_shadowMapSize.x*=4.0;\n_shadowMapSize.y*=2.0;\n\n}else{\n\nfaceCount=1;\nisPointLight=false;\n\n}\n\nif(shadow.map===null){\n\nvar pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};\n\nshadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);\n\nshadowCamera.updateProjectionMatrix();\n\n}\n\nif(shadow.isSpotLightShadow){\n\nshadow.update(light);\n\n}\n\n// TODO (abelnation / sam-g-steel): is this needed?\nif(shadow&&shadow.isRectAreaLightShadow){\n\nshadow.update(light);\n\n}\n\nvar shadowMap=shadow.map;\nvar shadowMatrix=shadow.matrix;\n\n_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\nshadowCamera.position.copy(_lightPositionWorld);\n\n_renderer.setRenderTarget(shadowMap);\n_renderer.clear();\n\n// render shadow map for each cube face (if omni-directional) or\n// run a single pass if not\n\nfor(var face=0;face<faceCount;face++){\n\nif(isPointLight){\n\n_lookTarget.copy(shadowCamera.position);\n_lookTarget.add(cubeDirections[face]);\nshadowCamera.up.copy(cubeUps[face]);\nshadowCamera.lookAt(_lookTarget);\n\nvar vpDimensions=cube2DViewPorts[face];\n_state.viewport(vpDimensions);\n\n}else{\n\n_lookTarget.setFromMatrixPosition(light.target.matrixWorld);\nshadowCamera.lookAt(_lookTarget);\n\n}\n\nshadowCamera.updateMatrixWorld();\nshadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);\n\n// compute shadow matrix\n\nshadowMatrix.set(\n0.5,0.0,0.0,0.5,\n0.0,0.5,0.0,0.5,\n0.0,0.0,0.5,0.5,\n0.0,0.0,0.0,1.0);\n\n\nshadowMatrix.multiply(shadowCamera.projectionMatrix);\nshadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n\n// update camera matrices and frustum\n\n_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);\n_frustum.setFromMatrix(_projScreenMatrix);\n\n// set object matrices & frustum culling\n\n_renderList.length=0;\n\nprojectObject(scene,camera,shadowCamera);\n\n// render shadow map\n// render regular objects\n\nfor(var j=0,jl=_renderList.length;j<jl;j++){\n\nvar object=_renderList[j];\nvar geometry=_objects.update(object);\nvar material=object.material;\n\nif(material&&material.isMultiMaterial){\n\nvar groups=geometry.groups;\nvar materials=material.materials;\n\nfor(var k=0,kl=groups.length;k<kl;k++){\n\nvar group=groups[k];\nvar groupMaterial=materials[group.materialIndex];\n\nif(groupMaterial.visible===true){\n\nvar depthMaterial=getDepthMaterial(object,groupMaterial,isPointLight,_lightPositionWorld);\n_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);\n\n}\n\n}\n\n}else{\n\nvar depthMaterial=getDepthMaterial(object,material,isPointLight,_lightPositionWorld);\n_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);\n\n}\n\n}\n\n}\n\n}\n\n// Restore GL state.\nvar clearColor=_renderer.getClearColor(),\nclearAlpha=_renderer.getClearAlpha();\n_renderer.setClearColor(clearColor,clearAlpha);\n\nscope.needsUpdate=false;\n\n};\n\nfunction getDepthMaterial(object,material,isPointLight,lightPositionWorld){\n\nvar geometry=object.geometry;\n\nvar result=null;\n\nvar materialVariants=_depthMaterials;\nvar customMaterial=object.customDepthMaterial;\n\nif(isPointLight){\n\nmaterialVariants=_distanceMaterials;\ncustomMaterial=object.customDistanceMaterial;\n\n}\n\nif(!customMaterial){\n\nvar useMorphing=false;\n\nif(material.morphTargets){\n\nif(geometry&&geometry.isBufferGeometry){\n\nuseMorphing=geometry.morphAttributes&&geometry.morphAttributes.position&&geometry.morphAttributes.position.length>0;\n\n}else if(geometry&&geometry.isGeometry){\n\nuseMorphing=geometry.morphTargets&&geometry.morphTargets.length>0;\n\n}\n\n}\n\nvar useSkinning=object.isSkinnedMesh&&material.skinning;\n\nvar variantIndex=0;\n\nif(useMorphing)variantIndex|=_MorphingFlag;\nif(useSkinning)variantIndex|=_SkinningFlag;\n\nresult=materialVariants[variantIndex];\n\n}else{\n\nresult=customMaterial;\n\n}\n\nif(_renderer.localClippingEnabled&&\nmaterial.clipShadows===true&&\nmaterial.clippingPlanes.length!==0){\n\n// in this case we need a unique material instance reflecting the\n// appropriate state\n\nvar keyA=result.uuid,keyB=material.uuid;\n\nvar materialsForVariant=_materialCache[keyA];\n\nif(materialsForVariant===undefined){\n\nmaterialsForVariant={};\n_materialCache[keyA]=materialsForVariant;\n\n}\n\nvar cachedMaterial=materialsForVariant[keyB];\n\nif(cachedMaterial===undefined){\n\ncachedMaterial=result.clone();\nmaterialsForVariant[keyB]=cachedMaterial;\n\n}\n\nresult=cachedMaterial;\n\n}\n\nresult.visible=material.visible;\nresult.wireframe=material.wireframe;\n\nvar side=material.side;\n\nif(scope.renderSingleSided&&side==DoubleSide){\n\nside=FrontSide;\n\n}\n\nif(scope.renderReverseSided){\n\nif(side===FrontSide)side=BackSide;else\nif(side===BackSide)side=FrontSide;\n\n}\n\nresult.side=side;\n\nresult.clipShadows=material.clipShadows;\nresult.clippingPlanes=material.clippingPlanes;\n\nresult.wireframeLinewidth=material.wireframeLinewidth;\nresult.linewidth=material.linewidth;\n\nif(isPointLight&&result.uniforms.lightPos!==undefined){\n\nresult.uniforms.lightPos.value.copy(lightPositionWorld);\n\n}\n\nreturn result;\n\n}\n\nfunction projectObject(object,camera,shadowCamera){\n\nif(object.visible===false)return;\n\nvar visible=(object.layers.mask&camera.layers.mask)!==0;\n\nif(visible&&(object.isMesh||object.isLine||object.isPoints)){\n\nif(object.castShadow&&(object.frustumCulled===false||_frustum.intersectsObject(object)===true)){\n\nvar material=object.material;\n\nif(material.visible===true){\n\nobject.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);\n_renderList.push(object);\n\n}\n\n}\n\n}\n\nvar children=object.children;\n\nfor(var i=0,l=children.length;i<l;i++){\n\nprojectObject(children[i],camera,shadowCamera);\n\n}\n\n}\n\n}\n\n/**\n\t * @author bhouston / http://clara.io\n\t */\n\nfunction Ray(origin,direction){\n\nthis.origin=origin!==undefined?origin:new Vector3();\nthis.direction=direction!==undefined?direction:new Vector3();\n\n}\n\nRay.prototype={\n\nconstructor:Ray,\n\nset:function set(origin,direction){\n\nthis.origin.copy(origin);\nthis.direction.copy(direction);\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(ray){\n\nthis.origin.copy(ray.origin);\nthis.direction.copy(ray.direction);\n\nreturn this;\n\n},\n\nat:function at(t,optionalTarget){\n\nvar result=optionalTarget||new Vector3();\n\nreturn result.copy(this.direction).multiplyScalar(t).add(this.origin);\n\n},\n\nlookAt:function lookAt(v){\n\nthis.direction.copy(v).sub(this.origin).normalize();\n\nreturn this;\n\n},\n\nrecast:function(){\n\nvar v1=new Vector3();\n\nreturn function recast(t){\n\nthis.origin.copy(this.at(t,v1));\n\nreturn this;\n\n};\n\n}(),\n\nclosestPointToPoint:function closestPointToPoint(point,optionalTarget){\n\nvar result=optionalTarget||new Vector3();\nresult.subVectors(point,this.origin);\nvar directionDistance=result.dot(this.direction);\n\nif(directionDistance<0){\n\nreturn result.copy(this.origin);\n\n}\n\nreturn result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\n},\n\ndistanceToPoint:function distanceToPoint(point){\n\nreturn Math.sqrt(this.distanceSqToPoint(point));\n\n},\n\ndistanceSqToPoint:function(){\n\nvar v1=new Vector3();\n\nreturn function distanceSqToPoint(point){\n\nvar directionDistance=v1.subVectors(point,this.origin).dot(this.direction);\n\n// point behind the ray\n\nif(directionDistance<0){\n\nreturn this.origin.distanceToSquared(point);\n\n}\n\nv1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\nreturn v1.distanceToSquared(point);\n\n};\n\n}(),\n\ndistanceSqToSegment:function(){\n\nvar segCenter=new Vector3();\nvar segDir=new Vector3();\nvar diff=new Vector3();\n\nreturn function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){\n\n// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n// It returns the min distance between the ray and the segment\n// defined by v0 and v1\n// It can also set two optional targets :\n// - The closest point on the ray\n// - The closest point on the segment\n\nsegCenter.copy(v0).add(v1).multiplyScalar(0.5);\nsegDir.copy(v1).sub(v0).normalize();\ndiff.copy(this.origin).sub(segCenter);\n\nvar segExtent=v0.distanceTo(v1)*0.5;\nvar a01=-this.direction.dot(segDir);\nvar b0=diff.dot(this.direction);\nvar b1=-diff.dot(segDir);\nvar c=diff.lengthSq();\nvar det=Math.abs(1-a01*a01);\nvar s0,s1,sqrDist,extDet;\n\nif(det>0){\n\n// The ray and segment are not parallel.\n\ns0=a01*b1-b0;\ns1=a01*b0-b1;\nextDet=segExtent*det;\n\nif(s0>=0){\n\nif(s1>=-extDet){\n\nif(s1<=extDet){\n\n// region 0\n// Minimum at interior points of ray and segment.\n\nvar invDet=1/det;\ns0*=invDet;\ns1*=invDet;\nsqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;\n\n}else{\n\n// region 1\n\ns1=segExtent;\ns0=Math.max(0,-(a01*s1+b0));\nsqrDist=-s0*s0+s1*(s1+2*b1)+c;\n\n}\n\n}else{\n\n// region 5\n\ns1=-segExtent;\ns0=Math.max(0,-(a01*s1+b0));\nsqrDist=-s0*s0+s1*(s1+2*b1)+c;\n\n}\n\n}else{\n\nif(s1<=-extDet){\n\n// region 4\n\ns0=Math.max(0,-(-a01*segExtent+b0));\ns1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);\nsqrDist=-s0*s0+s1*(s1+2*b1)+c;\n\n}else if(s1<=extDet){\n\n// region 3\n\ns0=0;\ns1=Math.min(Math.max(-segExtent,-b1),segExtent);\nsqrDist=s1*(s1+2*b1)+c;\n\n}else{\n\n// region 2\n\ns0=Math.max(0,-(a01*segExtent+b0));\ns1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);\nsqrDist=-s0*s0+s1*(s1+2*b1)+c;\n\n}\n\n}\n\n}else{\n\n// Ray and segment are parallel.\n\ns1=a01>0?-segExtent:segExtent;\ns0=Math.max(0,-(a01*s1+b0));\nsqrDist=-s0*s0+s1*(s1+2*b1)+c;\n\n}\n\nif(optionalPointOnRay){\n\noptionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n\n}\n\nif(optionalPointOnSegment){\n\noptionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);\n\n}\n\nreturn sqrDist;\n\n};\n\n}(),\n\nintersectSphere:function(){\n\nvar v1=new Vector3();\n\nreturn function intersectSphere(sphere,optionalTarget){\n\nv1.subVectors(sphere.center,this.origin);\nvar tca=v1.dot(this.direction);\nvar d2=v1.dot(v1)-tca*tca;\nvar radius2=sphere.radius*sphere.radius;\n\nif(d2>radius2)return null;\n\nvar thc=Math.sqrt(radius2-d2);\n\n// t0 = first intersect point - entrance on front of sphere\nvar t0=tca-thc;\n\n// t1 = second intersect point - exit point on back of sphere\nvar t1=tca+thc;\n\n// test to see if both t0 and t1 are behind the ray - if so, return null\nif(t0<0&&t1<0)return null;\n\n// test to see if t0 is behind the ray:\n// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n// in order to always return an intersect point that is in front of the ray.\nif(t0<0)return this.at(t1,optionalTarget);\n\n// else t0 is in front of the ray, so return the first collision point scaled by t0\nreturn this.at(t0,optionalTarget);\n\n};\n\n}(),\n\nintersectsSphere:function intersectsSphere(sphere){\n\nreturn this.distanceToPoint(sphere.center)<=sphere.radius;\n\n},\n\ndistanceToPlane:function distanceToPlane(plane){\n\nvar denominator=plane.normal.dot(this.direction);\n\nif(denominator===0){\n\n// line is coplanar, return origin\nif(plane.distanceToPoint(this.origin)===0){\n\nreturn 0;\n\n}\n\n// Null is preferable to undefined since undefined means.... it is undefined\n\nreturn null;\n\n}\n\nvar t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;\n\n// Return if the ray never intersects the plane\n\nreturn t>=0?t:null;\n\n},\n\nintersectPlane:function intersectPlane(plane,optionalTarget){\n\nvar t=this.distanceToPlane(plane);\n\nif(t===null){\n\nreturn null;\n\n}\n\nreturn this.at(t,optionalTarget);\n\n},\n\n\n\nintersectsPlane:function intersectsPlane(plane){\n\n// check if the ray lies on the plane first\n\nvar distToPoint=plane.distanceToPoint(this.origin);\n\nif(distToPoint===0){\n\nreturn true;\n\n}\n\nvar denominator=plane.normal.dot(this.direction);\n\nif(denominator*distToPoint<0){\n\nreturn true;\n\n}\n\n// ray origin is behind the plane (and is pointing behind it)\n\nreturn false;\n\n},\n\nintersectBox:function intersectBox(box,optionalTarget){\n\nvar tmin,tmax,tymin,tymax,tzmin,tzmax;\n\nvar invdirx=1/this.direction.x,\ninvdiry=1/this.direction.y,\ninvdirz=1/this.direction.z;\n\nvar origin=this.origin;\n\nif(invdirx>=0){\n\ntmin=(box.min.x-origin.x)*invdirx;\ntmax=(box.max.x-origin.x)*invdirx;\n\n}else{\n\ntmin=(box.max.x-origin.x)*invdirx;\ntmax=(box.min.x-origin.x)*invdirx;\n\n}\n\nif(invdiry>=0){\n\ntymin=(box.min.y-origin.y)*invdiry;\ntymax=(box.max.y-origin.y)*invdiry;\n\n}else{\n\ntymin=(box.max.y-origin.y)*invdiry;\ntymax=(box.min.y-origin.y)*invdiry;\n\n}\n\nif(tmin>tymax||tymin>tmax)return null;\n\n// These lines also handle the case where tmin or tmax is NaN\n// (result of 0 * Infinity). x !== x returns true if x is NaN\n\nif(tymin>tmin||tmin!==tmin)tmin=tymin;\n\nif(tymax<tmax||tmax!==tmax)tmax=tymax;\n\nif(invdirz>=0){\n\ntzmin=(box.min.z-origin.z)*invdirz;\ntzmax=(box.max.z-origin.z)*invdirz;\n\n}else{\n\ntzmin=(box.max.z-origin.z)*invdirz;\ntzmax=(box.min.z-origin.z)*invdirz;\n\n}\n\nif(tmin>tzmax||tzmin>tmax)return null;\n\nif(tzmin>tmin||tmin!==tmin)tmin=tzmin;\n\nif(tzmax<tmax||tmax!==tmax)tmax=tzmax;\n\n//return point closest to the ray (positive side)\n\nif(tmax<0)return null;\n\nreturn this.at(tmin>=0?tmin:tmax,optionalTarget);\n\n},\n\nintersectsBox:function(){\n\nvar v=new Vector3();\n\nreturn function intersectsBox(box){\n\nreturn this.intersectBox(box,v)!==null;\n\n};\n\n}(),\n\nintersectTriangle:function(){\n\n// Compute the offset origin, edges, and normal.\nvar diff=new Vector3();\nvar edge1=new Vector3();\nvar edge2=new Vector3();\nvar normal=new Vector3();\n\nreturn function intersectTriangle(a,b,c,backfaceCulling,optionalTarget){\n\n// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\nedge1.subVectors(b,a);\nedge2.subVectors(c,a);\nnormal.crossVectors(edge1,edge2);\n\n// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\nvar DdN=this.direction.dot(normal);\nvar sign;\n\nif(DdN>0){\n\nif(backfaceCulling)return null;\nsign=1;\n\n}else if(DdN<0){\n\nsign=-1;\nDdN=-DdN;\n\n}else{\n\nreturn null;\n\n}\n\ndiff.subVectors(this.origin,a);\nvar DdQxE2=sign*this.direction.dot(edge2.crossVectors(diff,edge2));\n\n// b1 < 0, no intersection\nif(DdQxE2<0){\n\nreturn null;\n\n}\n\nvar DdE1xQ=sign*this.direction.dot(edge1.cross(diff));\n\n// b2 < 0, no intersection\nif(DdE1xQ<0){\n\nreturn null;\n\n}\n\n// b1+b2 > 1, no intersection\nif(DdQxE2+DdE1xQ>DdN){\n\nreturn null;\n\n}\n\n// Line intersects triangle, check if ray does.\nvar QdN=-sign*diff.dot(normal);\n\n// t < 0, no intersection\nif(QdN<0){\n\nreturn null;\n\n}\n\n// Ray intersects triangle.\nreturn this.at(QdN/DdN,optionalTarget);\n\n};\n\n}(),\n\napplyMatrix4:function applyMatrix4(matrix4){\n\nthis.direction.add(this.origin).applyMatrix4(matrix4);\nthis.origin.applyMatrix4(matrix4);\nthis.direction.sub(this.origin);\nthis.direction.normalize();\n\nreturn this;\n\n},\n\nequals:function equals(ray){\n\nreturn ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author bhouston / http://clara.io\n\t */\n\nfunction Euler(x,y,z,order){\n\nthis._x=x||0;\nthis._y=y||0;\nthis._z=z||0;\nthis._order=order||Euler.DefaultOrder;\n\n}\n\nEuler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];\n\nEuler.DefaultOrder='XYZ';\n\nEuler.prototype={\n\nconstructor:Euler,\n\nisEuler:true,\n\nget x(){\n\nreturn this._x;\n\n},\n\nset x(value){\n\nthis._x=value;\nthis.onChangeCallback();\n\n},\n\nget y(){\n\nreturn this._y;\n\n},\n\nset y(value){\n\nthis._y=value;\nthis.onChangeCallback();\n\n},\n\nget z(){\n\nreturn this._z;\n\n},\n\nset z(value){\n\nthis._z=value;\nthis.onChangeCallback();\n\n},\n\nget order(){\n\nreturn this._order;\n\n},\n\nset order(value){\n\nthis._order=value;\nthis.onChangeCallback();\n\n},\n\nset:function set(x,y,z,order){\n\nthis._x=x;\nthis._y=y;\nthis._z=z;\nthis._order=order||this._order;\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor(this._x,this._y,this._z,this._order);\n\n},\n\ncopy:function copy(euler){\n\nthis._x=euler._x;\nthis._y=euler._y;\nthis._z=euler._z;\nthis._order=euler._order;\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\nsetFromRotationMatrix:function setFromRotationMatrix(m,order,update){\n\nvar clamp=_Math.clamp;\n\n// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\nvar te=m.elements;\nvar m11=te[0],m12=te[4],m13=te[8];\nvar m21=te[1],m22=te[5],m23=te[9];\nvar m31=te[2],m32=te[6],m33=te[10];\n\norder=order||this._order;\n\nif(order==='XYZ'){\n\nthis._y=Math.asin(clamp(m13,-1,1));\n\nif(Math.abs(m13)<0.99999){\n\nthis._x=Math.atan2(-m23,m33);\nthis._z=Math.atan2(-m12,m11);\n\n}else{\n\nthis._x=Math.atan2(m32,m22);\nthis._z=0;\n\n}\n\n}else if(order==='YXZ'){\n\nthis._x=Math.asin(-clamp(m23,-1,1));\n\nif(Math.abs(m23)<0.99999){\n\nthis._y=Math.atan2(m13,m33);\nthis._z=Math.atan2(m21,m22);\n\n}else{\n\nthis._y=Math.atan2(-m31,m11);\nthis._z=0;\n\n}\n\n}else if(order==='ZXY'){\n\nthis._x=Math.asin(clamp(m32,-1,1));\n\nif(Math.abs(m32)<0.99999){\n\nthis._y=Math.atan2(-m31,m33);\nthis._z=Math.atan2(-m12,m22);\n\n}else{\n\nthis._y=0;\nthis._z=Math.atan2(m21,m11);\n\n}\n\n}else if(order==='ZYX'){\n\nthis._y=Math.asin(-clamp(m31,-1,1));\n\nif(Math.abs(m31)<0.99999){\n\nthis._x=Math.atan2(m32,m33);\nthis._z=Math.atan2(m21,m11);\n\n}else{\n\nthis._x=0;\nthis._z=Math.atan2(-m12,m22);\n\n}\n\n}else if(order==='YZX'){\n\nthis._z=Math.asin(clamp(m21,-1,1));\n\nif(Math.abs(m21)<0.99999){\n\nthis._x=Math.atan2(-m23,m22);\nthis._y=Math.atan2(-m31,m11);\n\n}else{\n\nthis._x=0;\nthis._y=Math.atan2(m13,m33);\n\n}\n\n}else if(order==='XZY'){\n\nthis._z=Math.asin(-clamp(m12,-1,1));\n\nif(Math.abs(m12)<0.99999){\n\nthis._x=Math.atan2(m32,m22);\nthis._y=Math.atan2(m13,m11);\n\n}else{\n\nthis._x=Math.atan2(-m23,m33);\nthis._y=0;\n\n}\n\n}else{\n\nconsole.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+order);\n\n}\n\nthis._order=order;\n\nif(update!==false)this.onChangeCallback();\n\nreturn this;\n\n},\n\nsetFromQuaternion:function(){\n\nvar matrix;\n\nreturn function setFromQuaternion(q,order,update){\n\nif(matrix===undefined)matrix=new Matrix4();\n\nmatrix.makeRotationFromQuaternion(q);\n\nreturn this.setFromRotationMatrix(matrix,order,update);\n\n};\n\n}(),\n\nsetFromVector3:function setFromVector3(v,order){\n\nreturn this.set(v.x,v.y,v.z,order||this._order);\n\n},\n\nreorder:function(){\n\n// WARNING: this discards revolution information -bhouston\n\nvar q=new Quaternion();\n\nreturn function reorder(newOrder){\n\nq.setFromEuler(this);\n\nreturn this.setFromQuaternion(q,newOrder);\n\n};\n\n}(),\n\nequals:function equals(euler){\n\nreturn euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;\n\n},\n\nfromArray:function fromArray(array){\n\nthis._x=array[0];\nthis._y=array[1];\nthis._z=array[2];\nif(array[3]!==undefined)this._order=array[3];\n\nthis.onChangeCallback();\n\nreturn this;\n\n},\n\ntoArray:function toArray(array,offset){\n\nif(array===undefined)array=[];\nif(offset===undefined)offset=0;\n\narray[offset]=this._x;\narray[offset+1]=this._y;\narray[offset+2]=this._z;\narray[offset+3]=this._order;\n\nreturn array;\n\n},\n\ntoVector3:function toVector3(optionalResult){\n\nif(optionalResult){\n\nreturn optionalResult.set(this._x,this._y,this._z);\n\n}else{\n\nreturn new Vector3(this._x,this._y,this._z);\n\n}\n\n},\n\nonChange:function onChange(callback){\n\nthis.onChangeCallback=callback;\n\nreturn this;\n\n},\n\nonChangeCallback:function onChangeCallback(){}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Layers(){\n\nthis.mask=1;\n\n}\n\nLayers.prototype={\n\nconstructor:Layers,\n\nset:function set(channel){\n\nthis.mask=1<<channel;\n\n},\n\nenable:function enable(channel){\n\nthis.mask|=1<<channel;\n\n},\n\ntoggle:function toggle(channel){\n\nthis.mask^=1<<channel;\n\n},\n\ndisable:function disable(channel){\n\nthis.mask&=~(1<<channel);\n\n},\n\ntest:function test(layers){\n\nreturn(this.mask&layers.mask)!==0;\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author elephantatwork / www.elephantatwork.ch\n\t */\n\nvar object3DId=0;\n\nfunction Object3D(){\n\nObject.defineProperty(this,'id',{value:object3DId++});\n\nthis.uuid=_Math.generateUUID();\n\nthis.name='';\nthis.type='Object3D';\n\nthis.parent=null;\nthis.children=[];\n\nthis.up=Object3D.DefaultUp.clone();\n\nvar position=new Vector3();\nvar rotation=new Euler();\nvar quaternion=new Quaternion();\nvar scale=new Vector3(1,1,1);\n\nfunction onRotationChange(){\n\nquaternion.setFromEuler(rotation,false);\n\n}\n\nfunction onQuaternionChange(){\n\nrotation.setFromQuaternion(quaternion,undefined,false);\n\n}\n\nrotation.onChange(onRotationChange);\nquaternion.onChange(onQuaternionChange);\n\nObject.defineProperties(this,{\nposition:{\nenumerable:true,\nvalue:position},\n\nrotation:{\nenumerable:true,\nvalue:rotation},\n\nquaternion:{\nenumerable:true,\nvalue:quaternion},\n\nscale:{\nenumerable:true,\nvalue:scale},\n\nmodelViewMatrix:{\nvalue:new Matrix4()},\n\nnormalMatrix:{\nvalue:new Matrix3()}});\n\n\n\nthis.matrix=new Matrix4();\nthis.matrixWorld=new Matrix4();\n\nthis.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;\nthis.matrixWorldNeedsUpdate=false;\n\nthis.layers=new Layers();\nthis.visible=true;\n\nthis.castShadow=false;\nthis.receiveShadow=false;\n\nthis.frustumCulled=true;\nthis.renderOrder=0;\n\nthis.userData={};\n\nthis.onBeforeRender=function(){};\nthis.onAfterRender=function(){};\n\n}\n\nObject3D.DefaultUp=new Vector3(0,1,0);\nObject3D.DefaultMatrixAutoUpdate=true;\n\nObject3D.prototype={\n\nconstructor:Object3D,\n\nisObject3D:true,\n\napplyMatrix:function applyMatrix(matrix){\n\nthis.matrix.multiplyMatrices(matrix,this.matrix);\n\nthis.matrix.decompose(this.position,this.quaternion,this.scale);\n\n},\n\nsetRotationFromAxisAngle:function setRotationFromAxisAngle(axis,angle){\n\n// assumes axis is normalized\n\nthis.quaternion.setFromAxisAngle(axis,angle);\n\n},\n\nsetRotationFromEuler:function setRotationFromEuler(euler){\n\nthis.quaternion.setFromEuler(euler,true);\n\n},\n\nsetRotationFromMatrix:function setRotationFromMatrix(m){\n\n// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\nthis.quaternion.setFromRotationMatrix(m);\n\n},\n\nsetRotationFromQuaternion:function setRotationFromQuaternion(q){\n\n// assumes q is normalized\n\nthis.quaternion.copy(q);\n\n},\n\nrotateOnAxis:function(){\n\n// rotate object on axis in object space\n// axis is assumed to be normalized\n\nvar q1=new Quaternion();\n\nreturn function rotateOnAxis(axis,angle){\n\nq1.setFromAxisAngle(axis,angle);\n\nthis.quaternion.multiply(q1);\n\nreturn this;\n\n};\n\n}(),\n\nrotateX:function(){\n\nvar v1=new Vector3(1,0,0);\n\nreturn function rotateX(angle){\n\nreturn this.rotateOnAxis(v1,angle);\n\n};\n\n}(),\n\nrotateY:function(){\n\nvar v1=new Vector3(0,1,0);\n\nreturn function rotateY(angle){\n\nreturn this.rotateOnAxis(v1,angle);\n\n};\n\n}(),\n\nrotateZ:function(){\n\nvar v1=new Vector3(0,0,1);\n\nreturn function rotateZ(angle){\n\nreturn this.rotateOnAxis(v1,angle);\n\n};\n\n}(),\n\ntranslateOnAxis:function(){\n\n// translate object by distance along axis in object space\n// axis is assumed to be normalized\n\nvar v1=new Vector3();\n\nreturn function translateOnAxis(axis,distance){\n\nv1.copy(axis).applyQuaternion(this.quaternion);\n\nthis.position.add(v1.multiplyScalar(distance));\n\nreturn this;\n\n};\n\n}(),\n\ntranslateX:function(){\n\nvar v1=new Vector3(1,0,0);\n\nreturn function translateX(distance){\n\nreturn this.translateOnAxis(v1,distance);\n\n};\n\n}(),\n\ntranslateY:function(){\n\nvar v1=new Vector3(0,1,0);\n\nreturn function translateY(distance){\n\nreturn this.translateOnAxis(v1,distance);\n\n};\n\n}(),\n\ntranslateZ:function(){\n\nvar v1=new Vector3(0,0,1);\n\nreturn function translateZ(distance){\n\nreturn this.translateOnAxis(v1,distance);\n\n};\n\n}(),\n\nlocalToWorld:function localToWorld(vector){\n\nreturn vector.applyMatrix4(this.matrixWorld);\n\n},\n\nworldToLocal:function(){\n\nvar m1=new Matrix4();\n\nreturn function worldToLocal(vector){\n\nreturn vector.applyMatrix4(m1.getInverse(this.matrixWorld));\n\n};\n\n}(),\n\nlookAt:function(){\n\n// This routine does not support objects with rotated and/or translated parent(s)\n\nvar m1=new Matrix4();\n\nreturn function lookAt(vector){\n\nm1.lookAt(vector,this.position,this.up);\n\nthis.quaternion.setFromRotationMatrix(m1);\n\n};\n\n}(),\n\nadd:function add(object){\n\nif(arguments.length>1){\n\nfor(var i=0;i<arguments.length;i++){\n\nthis.add(arguments[i]);\n\n}\n\nreturn this;\n\n}\n\nif(object===this){\n\nconsole.error(\"THREE.Object3D.add: object can't be added as a child of itself.\",object);\nreturn this;\n\n}\n\nif(object&&object.isObject3D){\n\nif(object.parent!==null){\n\nobject.parent.remove(object);\n\n}\n\nobject.parent=this;\nobject.dispatchEvent({type:'added'});\n\nthis.children.push(object);\n\n}else{\n\nconsole.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\",object);\n\n}\n\nreturn this;\n\n},\n\nremove:function remove(object){\n\nif(arguments.length>1){\n\nfor(var i=0;i<arguments.length;i++){\n\nthis.remove(arguments[i]);\n\n}\n\n}\n\nvar index=this.children.indexOf(object);\n\nif(index!==-1){\n\nobject.parent=null;\n\nobject.dispatchEvent({type:'removed'});\n\nthis.children.splice(index,1);\n\n}\n\n},\n\ngetObjectById:function getObjectById(id){\n\nreturn this.getObjectByProperty('id',id);\n\n},\n\ngetObjectByName:function getObjectByName(name){\n\nreturn this.getObjectByProperty('name',name);\n\n},\n\ngetObjectByProperty:function getObjectByProperty(name,value){\n\nif(this[name]===value)return this;\n\nfor(var i=0,l=this.children.length;i<l;i++){\n\nvar child=this.children[i];\nvar object=child.getObjectByProperty(name,value);\n\nif(object!==undefined){\n\nreturn object;\n\n}\n\n}\n\nreturn undefined;\n\n},\n\ngetWorldPosition:function getWorldPosition(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\n\nthis.updateMatrixWorld(true);\n\nreturn result.setFromMatrixPosition(this.matrixWorld);\n\n},\n\ngetWorldQuaternion:function(){\n\nvar position=new Vector3();\nvar scale=new Vector3();\n\nreturn function getWorldQuaternion(optionalTarget){\n\nvar result=optionalTarget||new Quaternion();\n\nthis.updateMatrixWorld(true);\n\nthis.matrixWorld.decompose(position,result,scale);\n\nreturn result;\n\n};\n\n}(),\n\ngetWorldRotation:function(){\n\nvar quaternion=new Quaternion();\n\nreturn function getWorldRotation(optionalTarget){\n\nvar result=optionalTarget||new Euler();\n\nthis.getWorldQuaternion(quaternion);\n\nreturn result.setFromQuaternion(quaternion,this.rotation.order,false);\n\n};\n\n}(),\n\ngetWorldScale:function(){\n\nvar position=new Vector3();\nvar quaternion=new Quaternion();\n\nreturn function getWorldScale(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\n\nthis.updateMatrixWorld(true);\n\nthis.matrixWorld.decompose(position,quaternion,result);\n\nreturn result;\n\n};\n\n}(),\n\ngetWorldDirection:function(){\n\nvar quaternion=new Quaternion();\n\nreturn function getWorldDirection(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\n\nthis.getWorldQuaternion(quaternion);\n\nreturn result.set(0,0,1).applyQuaternion(quaternion);\n\n};\n\n}(),\n\nraycast:function raycast(){},\n\ntraverse:function traverse(callback){\n\ncallback(this);\n\nvar children=this.children;\n\nfor(var i=0,l=children.length;i<l;i++){\n\nchildren[i].traverse(callback);\n\n}\n\n},\n\ntraverseVisible:function traverseVisible(callback){\n\nif(this.visible===false)return;\n\ncallback(this);\n\nvar children=this.children;\n\nfor(var i=0,l=children.length;i<l;i++){\n\nchildren[i].traverseVisible(callback);\n\n}\n\n},\n\ntraverseAncestors:function traverseAncestors(callback){\n\nvar parent=this.parent;\n\nif(parent!==null){\n\ncallback(parent);\n\nparent.traverseAncestors(callback);\n\n}\n\n},\n\nupdateMatrix:function updateMatrix(){\n\nthis.matrix.compose(this.position,this.quaternion,this.scale);\n\nthis.matrixWorldNeedsUpdate=true;\n\n},\n\nupdateMatrixWorld:function updateMatrixWorld(force){\n\nif(this.matrixAutoUpdate===true)this.updateMatrix();\n\nif(this.matrixWorldNeedsUpdate===true||force===true){\n\nif(this.parent===null){\n\nthis.matrixWorld.copy(this.matrix);\n\n}else{\n\nthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);\n\n}\n\nthis.matrixWorldNeedsUpdate=false;\n\nforce=true;\n\n}\n\n// update children\n\nvar children=this.children;\n\nfor(var i=0,l=children.length;i<l;i++){\n\nchildren[i].updateMatrixWorld(force);\n\n}\n\n},\n\ntoJSON:function toJSON(meta){\n\n// meta is '' when called from JSON.stringify\nvar isRootObject=meta===undefined||meta==='';\n\nvar output={};\n\n// meta is a hash used to collect geometries, materials.\n// not providing it implies that this is the root object\n// being serialized.\nif(isRootObject){\n\n// initialize meta obj\nmeta={\ngeometries:{},\nmaterials:{},\ntextures:{},\nimages:{}};\n\n\noutput.metadata={\nversion:4.4,\ntype:'Object',\ngenerator:'Object3D.toJSON'};\n\n\n}\n\n// standard Object3D serialization\n\nvar object={};\n\nobject.uuid=this.uuid;\nobject.type=this.type;\n\nif(this.name!=='')object.name=this.name;\nif(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;\nif(this.castShadow===true)object.castShadow=true;\nif(this.receiveShadow===true)object.receiveShadow=true;\nif(this.visible===false)object.visible=false;\n\nobject.matrix=this.matrix.toArray();\n\n//\n\nif(this.geometry!==undefined){\n\nif(meta.geometries[this.geometry.uuid]===undefined){\n\nmeta.geometries[this.geometry.uuid]=this.geometry.toJSON(meta);\n\n}\n\nobject.geometry=this.geometry.uuid;\n\n}\n\nif(this.material!==undefined){\n\nif(meta.materials[this.material.uuid]===undefined){\n\nmeta.materials[this.material.uuid]=this.material.toJSON(meta);\n\n}\n\nobject.material=this.material.uuid;\n\n}\n\n//\n\nif(this.children.length>0){\n\nobject.children=[];\n\nfor(var i=0;i<this.children.length;i++){\n\nobject.children.push(this.children[i].toJSON(meta).object);\n\n}\n\n}\n\nif(isRootObject){\n\nvar geometries=extractFromCache(meta.geometries);\nvar materials=extractFromCache(meta.materials);\nvar textures=extractFromCache(meta.textures);\nvar images=extractFromCache(meta.images);\n\nif(geometries.length>0)output.geometries=geometries;\nif(materials.length>0)output.materials=materials;\nif(textures.length>0)output.textures=textures;\nif(images.length>0)output.images=images;\n\n}\n\noutput.object=object;\n\nreturn output;\n\n// extract data from the cache hash\n// remove metadata on each item\n// and return as array\nfunction extractFromCache(cache){\n\nvar values=[];\nfor(var key in cache){\n\nvar data=cache[key];\ndelete data.metadata;\nvalues.push(data);\n\n}\nreturn values;\n\n}\n\n},\n\nclone:function clone(recursive){\n\nreturn new this.constructor().copy(this,recursive);\n\n},\n\ncopy:function copy(source,recursive){\n\nif(recursive===undefined)recursive=true;\n\nthis.name=source.name;\n\nthis.up.copy(source.up);\n\nthis.position.copy(source.position);\nthis.quaternion.copy(source.quaternion);\nthis.scale.copy(source.scale);\n\nthis.matrix.copy(source.matrix);\nthis.matrixWorld.copy(source.matrixWorld);\n\nthis.matrixAutoUpdate=source.matrixAutoUpdate;\nthis.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;\n\nthis.layers.mask=source.layers.mask;\nthis.visible=source.visible;\n\nthis.castShadow=source.castShadow;\nthis.receiveShadow=source.receiveShadow;\n\nthis.frustumCulled=source.frustumCulled;\nthis.renderOrder=source.renderOrder;\n\nthis.userData=JSON.parse(JSON.stringify(source.userData));\n\nif(recursive===true){\n\nfor(var i=0;i<source.children.length;i++){\n\nvar child=source.children[i];\nthis.add(child.clone());\n\n}\n\n}\n\nreturn this;\n\n}};\n\n\n\nObject.assign(Object3D.prototype,EventDispatcher.prototype);\n\n/**\n\t * @author bhouston / http://clara.io\n\t */\n\nfunction Line3(start,end){\n\nthis.start=start!==undefined?start:new Vector3();\nthis.end=end!==undefined?end:new Vector3();\n\n}\n\nLine3.prototype={\n\nconstructor:Line3,\n\nset:function set(start,end){\n\nthis.start.copy(start);\nthis.end.copy(end);\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(line){\n\nthis.start.copy(line.start);\nthis.end.copy(line.end);\n\nreturn this;\n\n},\n\ngetCenter:function getCenter(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\nreturn result.addVectors(this.start,this.end).multiplyScalar(0.5);\n\n},\n\ndelta:function delta(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\nreturn result.subVectors(this.end,this.start);\n\n},\n\ndistanceSq:function distanceSq(){\n\nreturn this.start.distanceToSquared(this.end);\n\n},\n\ndistance:function distance(){\n\nreturn this.start.distanceTo(this.end);\n\n},\n\nat:function at(t,optionalTarget){\n\nvar result=optionalTarget||new Vector3();\n\nreturn this.delta(result).multiplyScalar(t).add(this.start);\n\n},\n\nclosestPointToPointParameter:function(){\n\nvar startP=new Vector3();\nvar startEnd=new Vector3();\n\nreturn function closestPointToPointParameter(point,clampToLine){\n\nstartP.subVectors(point,this.start);\nstartEnd.subVectors(this.end,this.start);\n\nvar startEnd2=startEnd.dot(startEnd);\nvar startEnd_startP=startEnd.dot(startP);\n\nvar t=startEnd_startP/startEnd2;\n\nif(clampToLine){\n\nt=_Math.clamp(t,0,1);\n\n}\n\nreturn t;\n\n};\n\n}(),\n\nclosestPointToPoint:function closestPointToPoint(point,clampToLine,optionalTarget){\n\nvar t=this.closestPointToPointParameter(point,clampToLine);\n\nvar result=optionalTarget||new Vector3();\n\nreturn this.delta(result).multiplyScalar(t).add(this.start);\n\n},\n\napplyMatrix4:function applyMatrix4(matrix){\n\nthis.start.applyMatrix4(matrix);\nthis.end.applyMatrix4(matrix);\n\nreturn this;\n\n},\n\nequals:function equals(line){\n\nreturn line.start.equals(this.start)&&line.end.equals(this.end);\n\n}};\n\n\n\n/**\n\t * @author bhouston / http://clara.io\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Triangle(a,b,c){\n\nthis.a=a!==undefined?a:new Vector3();\nthis.b=b!==undefined?b:new Vector3();\nthis.c=c!==undefined?c:new Vector3();\n\n}\n\nTriangle.normal=function(){\n\nvar v0=new Vector3();\n\nreturn function normal(a,b,c,optionalTarget){\n\nvar result=optionalTarget||new Vector3();\n\nresult.subVectors(c,b);\nv0.subVectors(a,b);\nresult.cross(v0);\n\nvar resultLengthSq=result.lengthSq();\nif(resultLengthSq>0){\n\nreturn result.multiplyScalar(1/Math.sqrt(resultLengthSq));\n\n}\n\nreturn result.set(0,0,0);\n\n};\n\n}();\n\n// static/instance method to calculate barycentric coordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTriangle.barycoordFromPoint=function(){\n\nvar v0=new Vector3();\nvar v1=new Vector3();\nvar v2=new Vector3();\n\nreturn function barycoordFromPoint(point,a,b,c,optionalTarget){\n\nv0.subVectors(c,a);\nv1.subVectors(b,a);\nv2.subVectors(point,a);\n\nvar dot00=v0.dot(v0);\nvar dot01=v0.dot(v1);\nvar dot02=v0.dot(v2);\nvar dot11=v1.dot(v1);\nvar dot12=v1.dot(v2);\n\nvar denom=dot00*dot11-dot01*dot01;\n\nvar result=optionalTarget||new Vector3();\n\n// collinear or singular triangle\nif(denom===0){\n\n// arbitrary location outside of triangle?\n// not sure if this is the best idea, maybe should be returning undefined\nreturn result.set(-2,-1,-1);\n\n}\n\nvar invDenom=1/denom;\nvar u=(dot11*dot02-dot01*dot12)*invDenom;\nvar v=(dot00*dot12-dot01*dot02)*invDenom;\n\n// barycentric coordinates must always sum to 1\nreturn result.set(1-u-v,v,u);\n\n};\n\n}();\n\nTriangle.containsPoint=function(){\n\nvar v1=new Vector3();\n\nreturn function containsPoint(point,a,b,c){\n\nvar result=Triangle.barycoordFromPoint(point,a,b,c,v1);\n\nreturn result.x>=0&&result.y>=0&&result.x+result.y<=1;\n\n};\n\n}();\n\nTriangle.prototype={\n\nconstructor:Triangle,\n\nset:function set(a,b,c){\n\nthis.a.copy(a);\nthis.b.copy(b);\nthis.c.copy(c);\n\nreturn this;\n\n},\n\nsetFromPointsAndIndices:function setFromPointsAndIndices(points,i0,i1,i2){\n\nthis.a.copy(points[i0]);\nthis.b.copy(points[i1]);\nthis.c.copy(points[i2]);\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(triangle){\n\nthis.a.copy(triangle.a);\nthis.b.copy(triangle.b);\nthis.c.copy(triangle.c);\n\nreturn this;\n\n},\n\narea:function(){\n\nvar v0=new Vector3();\nvar v1=new Vector3();\n\nreturn function area(){\n\nv0.subVectors(this.c,this.b);\nv1.subVectors(this.a,this.b);\n\nreturn v0.cross(v1).length()*0.5;\n\n};\n\n}(),\n\nmidpoint:function midpoint(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\nreturn result.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);\n\n},\n\nnormal:function normal(optionalTarget){\n\nreturn Triangle.normal(this.a,this.b,this.c,optionalTarget);\n\n},\n\nplane:function plane(optionalTarget){\n\nvar result=optionalTarget||new Plane();\n\nreturn result.setFromCoplanarPoints(this.a,this.b,this.c);\n\n},\n\nbarycoordFromPoint:function barycoordFromPoint(point,optionalTarget){\n\nreturn Triangle.barycoordFromPoint(point,this.a,this.b,this.c,optionalTarget);\n\n},\n\ncontainsPoint:function containsPoint(point){\n\nreturn Triangle.containsPoint(point,this.a,this.b,this.c);\n\n},\n\nclosestPointToPoint:function(){\n\nvar plane,edgeList,projectedPoint,closestPoint;\n\nreturn function closestPointToPoint(point,optionalTarget){\n\nif(plane===undefined){\n\nplane=new Plane();\nedgeList=[new Line3(),new Line3(),new Line3()];\nprojectedPoint=new Vector3();\nclosestPoint=new Vector3();\n\n}\n\nvar result=optionalTarget||new Vector3();\nvar minDistance=Infinity;\n\n// project the point onto the plane of the triangle\n\nplane.setFromCoplanarPoints(this.a,this.b,this.c);\nplane.projectPoint(point,projectedPoint);\n\n// check if the projection lies within the triangle\n\nif(this.containsPoint(projectedPoint)===true){\n\n// if so, this is the closest point\n\nresult.copy(projectedPoint);\n\n}else{\n\n// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\n\nedgeList[0].set(this.a,this.b);\nedgeList[1].set(this.b,this.c);\nedgeList[2].set(this.c,this.a);\n\nfor(var i=0;i<edgeList.length;i++){\n\nedgeList[i].closestPointToPoint(projectedPoint,true,closestPoint);\n\nvar distance=projectedPoint.distanceToSquared(closestPoint);\n\nif(distance<minDistance){\n\nminDistance=distance;\n\nresult.copy(closestPoint);\n\n}\n\n}\n\n}\n\nreturn result;\n\n};\n\n}(),\n\nequals:function equals(triangle){\n\nreturn triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction Face3(a,b,c,normal,color,materialIndex){\n\nthis.a=a;\nthis.b=b;\nthis.c=c;\n\nthis.normal=normal&&normal.isVector3?normal:new Vector3();\nthis.vertexNormals=Array.isArray(normal)?normal:[];\n\nthis.color=color&&color.isColor?color:new Color();\nthis.vertexColors=Array.isArray(color)?color:[];\n\nthis.materialIndex=materialIndex!==undefined?materialIndex:0;\n\n}\n\nFace3.prototype={\n\nconstructor:Face3,\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(source){\n\nthis.a=source.a;\nthis.b=source.b;\nthis.c=source.c;\n\nthis.normal.copy(source.normal);\nthis.color.copy(source.color);\n\nthis.materialIndex=source.materialIndex;\n\nfor(var i=0,il=source.vertexNormals.length;i<il;i++){\n\nthis.vertexNormals[i]=source.vertexNormals[i].clone();\n\n}\n\nfor(var i=0,il=source.vertexColors.length;i<il;i++){\n\nthis.vertexColors[i]=source.vertexColors[i].clone();\n\n}\n\nreturn this;\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  shading: THREE.SmoothShading,\n\t *  depthTest: <bool>,\n\t *  depthWrite: <bool>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>\n\t * }\n\t */\n\nfunction MeshBasicMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='MeshBasicMaterial';\n\nthis.color=new Color(0xffffff);// emissive\n\nthis.map=null;\n\nthis.lightMap=null;\nthis.lightMapIntensity=1.0;\n\nthis.aoMap=null;\nthis.aoMapIntensity=1.0;\n\nthis.specularMap=null;\n\nthis.alphaMap=null;\n\nthis.envMap=null;\nthis.combine=MultiplyOperation;\nthis.reflectivity=1;\nthis.refractionRatio=0.98;\n\nthis.wireframe=false;\nthis.wireframeLinewidth=1;\nthis.wireframeLinecap='round';\nthis.wireframeLinejoin='round';\n\nthis.skinning=false;\nthis.morphTargets=false;\n\nthis.lights=false;\n\nthis.setValues(parameters);\n\n}\n\nMeshBasicMaterial.prototype=Object.create(Material.prototype);\nMeshBasicMaterial.prototype.constructor=MeshBasicMaterial;\n\nMeshBasicMaterial.prototype.isMeshBasicMaterial=true;\n\nMeshBasicMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.color.copy(source.color);\n\nthis.map=source.map;\n\nthis.lightMap=source.lightMap;\nthis.lightMapIntensity=source.lightMapIntensity;\n\nthis.aoMap=source.aoMap;\nthis.aoMapIntensity=source.aoMapIntensity;\n\nthis.specularMap=source.specularMap;\n\nthis.alphaMap=source.alphaMap;\n\nthis.envMap=source.envMap;\nthis.combine=source.combine;\nthis.reflectivity=source.reflectivity;\nthis.refractionRatio=source.refractionRatio;\n\nthis.wireframe=source.wireframe;\nthis.wireframeLinewidth=source.wireframeLinewidth;\nthis.wireframeLinecap=source.wireframeLinecap;\nthis.wireframeLinejoin=source.wireframeLinejoin;\n\nthis.skinning=source.skinning;\nthis.morphTargets=source.morphTargets;\n\nreturn this;\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction BufferAttribute(array,itemSize,normalized){\n\nif(Array.isArray(array)){\n\nthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n\n}\n\nthis.uuid=_Math.generateUUID();\n\nthis.array=array;\nthis.itemSize=itemSize;\nthis.count=array!==undefined?array.length/itemSize:0;\nthis.normalized=normalized===true;\n\nthis.dynamic=false;\nthis.updateRange={offset:0,count:-1};\n\nthis.onUploadCallback=function(){};\n\nthis.version=0;\n\n}\n\nBufferAttribute.prototype={\n\nconstructor:BufferAttribute,\n\nisBufferAttribute:true,\n\nset needsUpdate(value){\n\nif(value===true)this.version++;\n\n},\n\nsetArray:function setArray(array){\n\nif(Array.isArray(array)){\n\nthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n\n}\n\nthis.count=array!==undefined?array.length/this.itemSize:0;\nthis.array=array;\n\n},\n\nsetDynamic:function setDynamic(value){\n\nthis.dynamic=value;\n\nreturn this;\n\n},\n\ncopy:function copy(source){\n\nthis.array=new source.array.constructor(source.array);\nthis.itemSize=source.itemSize;\nthis.count=source.count;\nthis.normalized=source.normalized;\n\nthis.dynamic=source.dynamic;\n\nreturn this;\n\n},\n\ncopyAt:function copyAt(index1,attribute,index2){\n\nindex1*=this.itemSize;\nindex2*=attribute.itemSize;\n\nfor(var i=0,l=this.itemSize;i<l;i++){\n\nthis.array[index1+i]=attribute.array[index2+i];\n\n}\n\nreturn this;\n\n},\n\ncopyArray:function copyArray(array){\n\nthis.array.set(array);\n\nreturn this;\n\n},\n\ncopyColorsArray:function copyColorsArray(colors){\n\nvar array=this.array,offset=0;\n\nfor(var i=0,l=colors.length;i<l;i++){\n\nvar color=colors[i];\n\nif(color===undefined){\n\nconsole.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);\ncolor=new Color();\n\n}\n\narray[offset++]=color.r;\narray[offset++]=color.g;\narray[offset++]=color.b;\n\n}\n\nreturn this;\n\n},\n\ncopyIndicesArray:function copyIndicesArray(indices){\n\nvar array=this.array,offset=0;\n\nfor(var i=0,l=indices.length;i<l;i++){\n\nvar index=indices[i];\n\narray[offset++]=index.a;\narray[offset++]=index.b;\narray[offset++]=index.c;\n\n}\n\nreturn this;\n\n},\n\ncopyVector2sArray:function copyVector2sArray(vectors){\n\nvar array=this.array,offset=0;\n\nfor(var i=0,l=vectors.length;i<l;i++){\n\nvar vector=vectors[i];\n\nif(vector===undefined){\n\nconsole.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);\nvector=new Vector2();\n\n}\n\narray[offset++]=vector.x;\narray[offset++]=vector.y;\n\n}\n\nreturn this;\n\n},\n\ncopyVector3sArray:function copyVector3sArray(vectors){\n\nvar array=this.array,offset=0;\n\nfor(var i=0,l=vectors.length;i<l;i++){\n\nvar vector=vectors[i];\n\nif(vector===undefined){\n\nconsole.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);\nvector=new Vector3();\n\n}\n\narray[offset++]=vector.x;\narray[offset++]=vector.y;\narray[offset++]=vector.z;\n\n}\n\nreturn this;\n\n},\n\ncopyVector4sArray:function copyVector4sArray(vectors){\n\nvar array=this.array,offset=0;\n\nfor(var i=0,l=vectors.length;i<l;i++){\n\nvar vector=vectors[i];\n\nif(vector===undefined){\n\nconsole.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);\nvector=new Vector4();\n\n}\n\narray[offset++]=vector.x;\narray[offset++]=vector.y;\narray[offset++]=vector.z;\narray[offset++]=vector.w;\n\n}\n\nreturn this;\n\n},\n\nset:function set(value,offset){\n\nif(offset===undefined)offset=0;\n\nthis.array.set(value,offset);\n\nreturn this;\n\n},\n\ngetX:function getX(index){\n\nreturn this.array[index*this.itemSize];\n\n},\n\nsetX:function setX(index,x){\n\nthis.array[index*this.itemSize]=x;\n\nreturn this;\n\n},\n\ngetY:function getY(index){\n\nreturn this.array[index*this.itemSize+1];\n\n},\n\nsetY:function setY(index,y){\n\nthis.array[index*this.itemSize+1]=y;\n\nreturn this;\n\n},\n\ngetZ:function getZ(index){\n\nreturn this.array[index*this.itemSize+2];\n\n},\n\nsetZ:function setZ(index,z){\n\nthis.array[index*this.itemSize+2]=z;\n\nreturn this;\n\n},\n\ngetW:function getW(index){\n\nreturn this.array[index*this.itemSize+3];\n\n},\n\nsetW:function setW(index,w){\n\nthis.array[index*this.itemSize+3]=w;\n\nreturn this;\n\n},\n\nsetXY:function setXY(index,x,y){\n\nindex*=this.itemSize;\n\nthis.array[index+0]=x;\nthis.array[index+1]=y;\n\nreturn this;\n\n},\n\nsetXYZ:function setXYZ(index,x,y,z){\n\nindex*=this.itemSize;\n\nthis.array[index+0]=x;\nthis.array[index+1]=y;\nthis.array[index+2]=z;\n\nreturn this;\n\n},\n\nsetXYZW:function setXYZW(index,x,y,z,w){\n\nindex*=this.itemSize;\n\nthis.array[index+0]=x;\nthis.array[index+1]=y;\nthis.array[index+2]=z;\nthis.array[index+3]=w;\n\nreturn this;\n\n},\n\nonUpload:function onUpload(callback){\n\nthis.onUploadCallback=callback;\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor(this.array,this.itemSize).copy(this);\n\n}};\n\n\n\n//\n\nfunction Int8BufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Int8Array(array),itemSize);\n\n}\n\nInt8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nInt8BufferAttribute.prototype.constructor=Int8BufferAttribute;\n\n\nfunction Uint8BufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Uint8Array(array),itemSize);\n\n}\n\nUint8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nUint8BufferAttribute.prototype.constructor=Uint8BufferAttribute;\n\n\nfunction Uint8ClampedBufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Uint8ClampedArray(array),itemSize);\n\n}\n\nUint8ClampedBufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nUint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute;\n\n\nfunction Int16BufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Int16Array(array),itemSize);\n\n}\n\nInt16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nInt16BufferAttribute.prototype.constructor=Int16BufferAttribute;\n\n\nfunction Uint16BufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Uint16Array(array),itemSize);\n\n}\n\nUint16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nUint16BufferAttribute.prototype.constructor=Uint16BufferAttribute;\n\n\nfunction Int32BufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Int32Array(array),itemSize);\n\n}\n\nInt32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nInt32BufferAttribute.prototype.constructor=Int32BufferAttribute;\n\n\nfunction Uint32BufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Uint32Array(array),itemSize);\n\n}\n\nUint32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nUint32BufferAttribute.prototype.constructor=Uint32BufferAttribute;\n\n\nfunction Float32BufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Float32Array(array),itemSize);\n\n}\n\nFloat32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nFloat32BufferAttribute.prototype.constructor=Float32BufferAttribute;\n\n\nfunction Float64BufferAttribute(array,itemSize){\n\nBufferAttribute.call(this,new Float64Array(array),itemSize);\n\n}\n\nFloat64BufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nFloat64BufferAttribute.prototype.constructor=Float64BufferAttribute;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction DirectGeometry(){\n\nthis.indices=[];\nthis.vertices=[];\nthis.normals=[];\nthis.colors=[];\nthis.uvs=[];\nthis.uvs2=[];\n\nthis.groups=[];\n\nthis.morphTargets={};\n\nthis.skinWeights=[];\nthis.skinIndices=[];\n\n// this.lineDistances = [];\n\nthis.boundingBox=null;\nthis.boundingSphere=null;\n\n// update flags\n\nthis.verticesNeedUpdate=false;\nthis.normalsNeedUpdate=false;\nthis.colorsNeedUpdate=false;\nthis.uvsNeedUpdate=false;\nthis.groupsNeedUpdate=false;\n\n}\n\nObject.assign(DirectGeometry.prototype,{\n\ncomputeGroups:function computeGroups(geometry){\n\nvar group;\nvar groups=[];\nvar materialIndex=undefined;\n\nvar faces=geometry.faces;\n\nfor(var i=0;i<faces.length;i++){\n\nvar face=faces[i];\n\n// materials\n\nif(face.materialIndex!==materialIndex){\n\nmaterialIndex=face.materialIndex;\n\nif(group!==undefined){\n\ngroup.count=i*3-group.start;\ngroups.push(group);\n\n}\n\ngroup={\nstart:i*3,\nmaterialIndex:materialIndex};\n\n\n}\n\n}\n\nif(group!==undefined){\n\ngroup.count=i*3-group.start;\ngroups.push(group);\n\n}\n\nthis.groups=groups;\n\n},\n\nfromGeometry:function fromGeometry(geometry){\n\nvar faces=geometry.faces;\nvar vertices=geometry.vertices;\nvar faceVertexUvs=geometry.faceVertexUvs;\n\nvar hasFaceVertexUv=faceVertexUvs[0]&&faceVertexUvs[0].length>0;\nvar hasFaceVertexUv2=faceVertexUvs[1]&&faceVertexUvs[1].length>0;\n\n// morphs\n\nvar morphTargets=geometry.morphTargets;\nvar morphTargetsLength=morphTargets.length;\n\nvar morphTargetsPosition;\n\nif(morphTargetsLength>0){\n\nmorphTargetsPosition=[];\n\nfor(var i=0;i<morphTargetsLength;i++){\n\nmorphTargetsPosition[i]=[];\n\n}\n\nthis.morphTargets.position=morphTargetsPosition;\n\n}\n\nvar morphNormals=geometry.morphNormals;\nvar morphNormalsLength=morphNormals.length;\n\nvar morphTargetsNormal;\n\nif(morphNormalsLength>0){\n\nmorphTargetsNormal=[];\n\nfor(var i=0;i<morphNormalsLength;i++){\n\nmorphTargetsNormal[i]=[];\n\n}\n\nthis.morphTargets.normal=morphTargetsNormal;\n\n}\n\n// skins\n\nvar skinIndices=geometry.skinIndices;\nvar skinWeights=geometry.skinWeights;\n\nvar hasSkinIndices=skinIndices.length===vertices.length;\nvar hasSkinWeights=skinWeights.length===vertices.length;\n\n//\n\nfor(var i=0;i<faces.length;i++){\n\nvar face=faces[i];\n\nthis.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);\n\nvar vertexNormals=face.vertexNormals;\n\nif(vertexNormals.length===3){\n\nthis.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]);\n\n}else{\n\nvar normal=face.normal;\n\nthis.normals.push(normal,normal,normal);\n\n}\n\nvar vertexColors=face.vertexColors;\n\nif(vertexColors.length===3){\n\nthis.colors.push(vertexColors[0],vertexColors[1],vertexColors[2]);\n\n}else{\n\nvar color=face.color;\n\nthis.colors.push(color,color,color);\n\n}\n\nif(hasFaceVertexUv===true){\n\nvar vertexUvs=faceVertexUvs[0][i];\n\nif(vertexUvs!==undefined){\n\nthis.uvs.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);\n\n}else{\n\nconsole.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',i);\n\nthis.uvs.push(new Vector2(),new Vector2(),new Vector2());\n\n}\n\n}\n\nif(hasFaceVertexUv2===true){\n\nvar vertexUvs=faceVertexUvs[1][i];\n\nif(vertexUvs!==undefined){\n\nthis.uvs2.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);\n\n}else{\n\nconsole.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',i);\n\nthis.uvs2.push(new Vector2(),new Vector2(),new Vector2());\n\n}\n\n}\n\n// morphs\n\nfor(var j=0;j<morphTargetsLength;j++){\n\nvar morphTarget=morphTargets[j].vertices;\n\nmorphTargetsPosition[j].push(morphTarget[face.a],morphTarget[face.b],morphTarget[face.c]);\n\n}\n\nfor(var j=0;j<morphNormalsLength;j++){\n\nvar morphNormal=morphNormals[j].vertexNormals[i];\n\nmorphTargetsNormal[j].push(morphNormal.a,morphNormal.b,morphNormal.c);\n\n}\n\n// skins\n\nif(hasSkinIndices){\n\nthis.skinIndices.push(skinIndices[face.a],skinIndices[face.b],skinIndices[face.c]);\n\n}\n\nif(hasSkinWeights){\n\nthis.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c]);\n\n}\n\n}\n\nthis.computeGroups(geometry);\n\nthis.verticesNeedUpdate=geometry.verticesNeedUpdate;\nthis.normalsNeedUpdate=geometry.normalsNeedUpdate;\nthis.colorsNeedUpdate=geometry.colorsNeedUpdate;\nthis.uvsNeedUpdate=geometry.uvsNeedUpdate;\nthis.groupsNeedUpdate=geometry.groupsNeedUpdate;\n\nreturn this;\n\n}});\n\n\n\n// http://stackoverflow.com/questions/1669190/javascript-min-max-array-values/13440842#13440842\n\nfunction arrayMax(array){\n\nvar length=array.length,max=-Infinity;\n\nwhile(length--){\n\nif(array[length]>max){\n\nmax=array[length];\n\n}\n\n}\n\nreturn max;\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author kile / http://kile.stravaganza.org/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author bhouston / http://clara.io\n\t */\n\nvar count=0;\nfunction GeometryIdCount(){return count++;}\n\nfunction Geometry(){\n\nObject.defineProperty(this,'id',{value:GeometryIdCount()});\n\nthis.uuid=_Math.generateUUID();\n\nthis.name='';\nthis.type='Geometry';\n\nthis.vertices=[];\nthis.colors=[];\nthis.faces=[];\nthis.faceVertexUvs=[[]];\n\nthis.morphTargets=[];\nthis.morphNormals=[];\n\nthis.skinWeights=[];\nthis.skinIndices=[];\n\nthis.lineDistances=[];\n\nthis.boundingBox=null;\nthis.boundingSphere=null;\n\n// update flags\n\nthis.elementsNeedUpdate=false;\nthis.verticesNeedUpdate=false;\nthis.uvsNeedUpdate=false;\nthis.normalsNeedUpdate=false;\nthis.colorsNeedUpdate=false;\nthis.lineDistancesNeedUpdate=false;\nthis.groupsNeedUpdate=false;\n\n}\n\nGeometry.prototype={\n\nconstructor:Geometry,\n\nisGeometry:true,\n\napplyMatrix:function applyMatrix(matrix){\n\nvar normalMatrix=new Matrix3().getNormalMatrix(matrix);\n\nfor(var i=0,il=this.vertices.length;i<il;i++){\n\nvar vertex=this.vertices[i];\nvertex.applyMatrix4(matrix);\n\n}\n\nfor(var i=0,il=this.faces.length;i<il;i++){\n\nvar face=this.faces[i];\nface.normal.applyMatrix3(normalMatrix).normalize();\n\nfor(var j=0,jl=face.vertexNormals.length;j<jl;j++){\n\nface.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n\n}\n\n}\n\nif(this.boundingBox!==null){\n\nthis.computeBoundingBox();\n\n}\n\nif(this.boundingSphere!==null){\n\nthis.computeBoundingSphere();\n\n}\n\nthis.verticesNeedUpdate=true;\nthis.normalsNeedUpdate=true;\n\nreturn this;\n\n},\n\nrotateX:function(){\n\n// rotate geometry around world x-axis\n\nvar m1;\n\nreturn function rotateX(angle){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeRotationX(angle);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\nrotateY:function(){\n\n// rotate geometry around world y-axis\n\nvar m1;\n\nreturn function rotateY(angle){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeRotationY(angle);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\nrotateZ:function(){\n\n// rotate geometry around world z-axis\n\nvar m1;\n\nreturn function rotateZ(angle){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeRotationZ(angle);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\ntranslate:function(){\n\n// translate geometry\n\nvar m1;\n\nreturn function translate(x,y,z){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeTranslation(x,y,z);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\nscale:function(){\n\n// scale geometry\n\nvar m1;\n\nreturn function scale(x,y,z){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeScale(x,y,z);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\nlookAt:function(){\n\nvar obj;\n\nreturn function lookAt(vector){\n\nif(obj===undefined)obj=new Object3D();\n\nobj.lookAt(vector);\n\nobj.updateMatrix();\n\nthis.applyMatrix(obj.matrix);\n\n};\n\n}(),\n\nfromBufferGeometry:function fromBufferGeometry(geometry){\n\nvar scope=this;\n\nvar indices=geometry.index!==null?geometry.index.array:undefined;\nvar attributes=geometry.attributes;\n\nvar positions=attributes.position.array;\nvar normals=attributes.normal!==undefined?attributes.normal.array:undefined;\nvar colors=attributes.color!==undefined?attributes.color.array:undefined;\nvar uvs=attributes.uv!==undefined?attributes.uv.array:undefined;\nvar uvs2=attributes.uv2!==undefined?attributes.uv2.array:undefined;\n\nif(uvs2!==undefined)this.faceVertexUvs[1]=[];\n\nvar tempNormals=[];\nvar tempUVs=[];\nvar tempUVs2=[];\n\nfor(var i=0,j=0;i<positions.length;i+=3,j+=2){\n\nscope.vertices.push(new Vector3(positions[i],positions[i+1],positions[i+2]));\n\nif(normals!==undefined){\n\ntempNormals.push(new Vector3(normals[i],normals[i+1],normals[i+2]));\n\n}\n\nif(colors!==undefined){\n\nscope.colors.push(new Color(colors[i],colors[i+1],colors[i+2]));\n\n}\n\nif(uvs!==undefined){\n\ntempUVs.push(new Vector2(uvs[j],uvs[j+1]));\n\n}\n\nif(uvs2!==undefined){\n\ntempUVs2.push(new Vector2(uvs2[j],uvs2[j+1]));\n\n}\n\n}\n\nfunction addFace(a,b,c,materialIndex){\n\nvar vertexNormals=normals!==undefined?[tempNormals[a].clone(),tempNormals[b].clone(),tempNormals[c].clone()]:[];\nvar vertexColors=colors!==undefined?[scope.colors[a].clone(),scope.colors[b].clone(),scope.colors[c].clone()]:[];\n\nvar face=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);\n\nscope.faces.push(face);\n\nif(uvs!==undefined){\n\nscope.faceVertexUvs[0].push([tempUVs[a].clone(),tempUVs[b].clone(),tempUVs[c].clone()]);\n\n}\n\nif(uvs2!==undefined){\n\nscope.faceVertexUvs[1].push([tempUVs2[a].clone(),tempUVs2[b].clone(),tempUVs2[c].clone()]);\n\n}\n\n}\n\nif(indices!==undefined){\n\nvar groups=geometry.groups;\n\nif(groups.length>0){\n\nfor(var i=0;i<groups.length;i++){\n\nvar group=groups[i];\n\nvar start=group.start;\nvar count=group.count;\n\nfor(var j=start,jl=start+count;j<jl;j+=3){\n\naddFace(indices[j],indices[j+1],indices[j+2],group.materialIndex);\n\n}\n\n}\n\n}else{\n\nfor(var i=0;i<indices.length;i+=3){\n\naddFace(indices[i],indices[i+1],indices[i+2]);\n\n}\n\n}\n\n}else{\n\nfor(var i=0;i<positions.length/3;i+=3){\n\naddFace(i,i+1,i+2);\n\n}\n\n}\n\nthis.computeFaceNormals();\n\nif(geometry.boundingBox!==null){\n\nthis.boundingBox=geometry.boundingBox.clone();\n\n}\n\nif(geometry.boundingSphere!==null){\n\nthis.boundingSphere=geometry.boundingSphere.clone();\n\n}\n\nreturn this;\n\n},\n\ncenter:function center(){\n\nthis.computeBoundingBox();\n\nvar offset=this.boundingBox.getCenter().negate();\n\nthis.translate(offset.x,offset.y,offset.z);\n\nreturn offset;\n\n},\n\nnormalize:function normalize(){\n\nthis.computeBoundingSphere();\n\nvar center=this.boundingSphere.center;\nvar radius=this.boundingSphere.radius;\n\nvar s=radius===0?1:1.0/radius;\n\nvar matrix=new Matrix4();\nmatrix.set(\ns,0,0,-s*center.x,\n0,s,0,-s*center.y,\n0,0,s,-s*center.z,\n0,0,0,1);\n\n\nthis.applyMatrix(matrix);\n\nreturn this;\n\n},\n\ncomputeFaceNormals:function computeFaceNormals(){\n\nvar cb=new Vector3(),ab=new Vector3();\n\nfor(var f=0,fl=this.faces.length;f<fl;f++){\n\nvar face=this.faces[f];\n\nvar vA=this.vertices[face.a];\nvar vB=this.vertices[face.b];\nvar vC=this.vertices[face.c];\n\ncb.subVectors(vC,vB);\nab.subVectors(vA,vB);\ncb.cross(ab);\n\ncb.normalize();\n\nface.normal.copy(cb);\n\n}\n\n},\n\ncomputeVertexNormals:function computeVertexNormals(areaWeighted){\n\nif(areaWeighted===undefined)areaWeighted=true;\n\nvar v,vl,f,fl,face,vertices;\n\nvertices=new Array(this.vertices.length);\n\nfor(v=0,vl=this.vertices.length;v<vl;v++){\n\nvertices[v]=new Vector3();\n\n}\n\nif(areaWeighted){\n\n// vertex normals weighted by triangle areas\n// http://www.iquilezles.org/www/articles/normals/normals.htm\n\nvar vA,vB,vC;\nvar cb=new Vector3(),ab=new Vector3();\n\nfor(f=0,fl=this.faces.length;f<fl;f++){\n\nface=this.faces[f];\n\nvA=this.vertices[face.a];\nvB=this.vertices[face.b];\nvC=this.vertices[face.c];\n\ncb.subVectors(vC,vB);\nab.subVectors(vA,vB);\ncb.cross(ab);\n\nvertices[face.a].add(cb);\nvertices[face.b].add(cb);\nvertices[face.c].add(cb);\n\n}\n\n}else{\n\nthis.computeFaceNormals();\n\nfor(f=0,fl=this.faces.length;f<fl;f++){\n\nface=this.faces[f];\n\nvertices[face.a].add(face.normal);\nvertices[face.b].add(face.normal);\nvertices[face.c].add(face.normal);\n\n}\n\n}\n\nfor(v=0,vl=this.vertices.length;v<vl;v++){\n\nvertices[v].normalize();\n\n}\n\nfor(f=0,fl=this.faces.length;f<fl;f++){\n\nface=this.faces[f];\n\nvar vertexNormals=face.vertexNormals;\n\nif(vertexNormals.length===3){\n\nvertexNormals[0].copy(vertices[face.a]);\nvertexNormals[1].copy(vertices[face.b]);\nvertexNormals[2].copy(vertices[face.c]);\n\n}else{\n\nvertexNormals[0]=vertices[face.a].clone();\nvertexNormals[1]=vertices[face.b].clone();\nvertexNormals[2]=vertices[face.c].clone();\n\n}\n\n}\n\nif(this.faces.length>0){\n\nthis.normalsNeedUpdate=true;\n\n}\n\n},\n\ncomputeFlatVertexNormals:function computeFlatVertexNormals(){\n\nvar f,fl,face;\n\nthis.computeFaceNormals();\n\nfor(f=0,fl=this.faces.length;f<fl;f++){\n\nface=this.faces[f];\n\nvar vertexNormals=face.vertexNormals;\n\nif(vertexNormals.length===3){\n\nvertexNormals[0].copy(face.normal);\nvertexNormals[1].copy(face.normal);\nvertexNormals[2].copy(face.normal);\n\n}else{\n\nvertexNormals[0]=face.normal.clone();\nvertexNormals[1]=face.normal.clone();\nvertexNormals[2]=face.normal.clone();\n\n}\n\n}\n\nif(this.faces.length>0){\n\nthis.normalsNeedUpdate=true;\n\n}\n\n},\n\ncomputeMorphNormals:function computeMorphNormals(){\n\nvar i,il,f,fl,face;\n\n// save original normals\n// - create temp variables on first access\n//   otherwise just copy (for faster repeated calls)\n\nfor(f=0,fl=this.faces.length;f<fl;f++){\n\nface=this.faces[f];\n\nif(!face.__originalFaceNormal){\n\nface.__originalFaceNormal=face.normal.clone();\n\n}else{\n\nface.__originalFaceNormal.copy(face.normal);\n\n}\n\nif(!face.__originalVertexNormals)face.__originalVertexNormals=[];\n\nfor(i=0,il=face.vertexNormals.length;i<il;i++){\n\nif(!face.__originalVertexNormals[i]){\n\nface.__originalVertexNormals[i]=face.vertexNormals[i].clone();\n\n}else{\n\nface.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n\n}\n\n}\n\n}\n\n// use temp geometry to compute face and vertex normals for each morph\n\nvar tmpGeo=new Geometry();\ntmpGeo.faces=this.faces;\n\nfor(i=0,il=this.morphTargets.length;i<il;i++){\n\n// create on first access\n\nif(!this.morphNormals[i]){\n\nthis.morphNormals[i]={};\nthis.morphNormals[i].faceNormals=[];\nthis.morphNormals[i].vertexNormals=[];\n\nvar dstNormalsFace=this.morphNormals[i].faceNormals;\nvar dstNormalsVertex=this.morphNormals[i].vertexNormals;\n\nvar faceNormal,vertexNormals;\n\nfor(f=0,fl=this.faces.length;f<fl;f++){\n\nfaceNormal=new Vector3();\nvertexNormals={a:new Vector3(),b:new Vector3(),c:new Vector3()};\n\ndstNormalsFace.push(faceNormal);\ndstNormalsVertex.push(vertexNormals);\n\n}\n\n}\n\nvar morphNormals=this.morphNormals[i];\n\n// set vertices to morph target\n\ntmpGeo.vertices=this.morphTargets[i].vertices;\n\n// compute morph normals\n\ntmpGeo.computeFaceNormals();\ntmpGeo.computeVertexNormals();\n\n// store morph normals\n\nvar faceNormal,vertexNormals;\n\nfor(f=0,fl=this.faces.length;f<fl;f++){\n\nface=this.faces[f];\n\nfaceNormal=morphNormals.faceNormals[f];\nvertexNormals=morphNormals.vertexNormals[f];\n\nfaceNormal.copy(face.normal);\n\nvertexNormals.a.copy(face.vertexNormals[0]);\nvertexNormals.b.copy(face.vertexNormals[1]);\nvertexNormals.c.copy(face.vertexNormals[2]);\n\n}\n\n}\n\n// restore original normals\n\nfor(f=0,fl=this.faces.length;f<fl;f++){\n\nface=this.faces[f];\n\nface.normal=face.__originalFaceNormal;\nface.vertexNormals=face.__originalVertexNormals;\n\n}\n\n},\n\ncomputeLineDistances:function computeLineDistances(){\n\nvar d=0;\nvar vertices=this.vertices;\n\nfor(var i=0,il=vertices.length;i<il;i++){\n\nif(i>0){\n\nd+=vertices[i].distanceTo(vertices[i-1]);\n\n}\n\nthis.lineDistances[i]=d;\n\n}\n\n},\n\ncomputeBoundingBox:function computeBoundingBox(){\n\nif(this.boundingBox===null){\n\nthis.boundingBox=new Box3();\n\n}\n\nthis.boundingBox.setFromPoints(this.vertices);\n\n},\n\ncomputeBoundingSphere:function computeBoundingSphere(){\n\nif(this.boundingSphere===null){\n\nthis.boundingSphere=new Sphere();\n\n}\n\nthis.boundingSphere.setFromPoints(this.vertices);\n\n},\n\nmerge:function merge(geometry,matrix,materialIndexOffset){\n\nif((geometry&&geometry.isGeometry)===false){\n\nconsole.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',geometry);\nreturn;\n\n}\n\nvar normalMatrix,\nvertexOffset=this.vertices.length,\nvertices1=this.vertices,\nvertices2=geometry.vertices,\nfaces1=this.faces,\nfaces2=geometry.faces,\nuvs1=this.faceVertexUvs[0],\nuvs2=geometry.faceVertexUvs[0],\ncolors1=this.colors,\ncolors2=geometry.colors;\n\nif(materialIndexOffset===undefined)materialIndexOffset=0;\n\nif(matrix!==undefined){\n\nnormalMatrix=new Matrix3().getNormalMatrix(matrix);\n\n}\n\n// vertices\n\nfor(var i=0,il=vertices2.length;i<il;i++){\n\nvar vertex=vertices2[i];\n\nvar vertexCopy=vertex.clone();\n\nif(matrix!==undefined)vertexCopy.applyMatrix4(matrix);\n\nvertices1.push(vertexCopy);\n\n}\n\n// colors\n\nfor(var i=0,il=colors2.length;i<il;i++){\n\ncolors1.push(colors2[i].clone());\n\n}\n\n// faces\n\nfor(i=0,il=faces2.length;i<il;i++){\n\nvar face=faces2[i],faceCopy,normal,color,\nfaceVertexNormals=face.vertexNormals,\nfaceVertexColors=face.vertexColors;\n\nfaceCopy=new Face3(face.a+vertexOffset,face.b+vertexOffset,face.c+vertexOffset);\nfaceCopy.normal.copy(face.normal);\n\nif(normalMatrix!==undefined){\n\nfaceCopy.normal.applyMatrix3(normalMatrix).normalize();\n\n}\n\nfor(var j=0,jl=faceVertexNormals.length;j<jl;j++){\n\nnormal=faceVertexNormals[j].clone();\n\nif(normalMatrix!==undefined){\n\nnormal.applyMatrix3(normalMatrix).normalize();\n\n}\n\nfaceCopy.vertexNormals.push(normal);\n\n}\n\nfaceCopy.color.copy(face.color);\n\nfor(var j=0,jl=faceVertexColors.length;j<jl;j++){\n\ncolor=faceVertexColors[j];\nfaceCopy.vertexColors.push(color.clone());\n\n}\n\nfaceCopy.materialIndex=face.materialIndex+materialIndexOffset;\n\nfaces1.push(faceCopy);\n\n}\n\n// uvs\n\nfor(i=0,il=uvs2.length;i<il;i++){\n\nvar uv=uvs2[i],uvCopy=[];\n\nif(uv===undefined){\n\ncontinue;\n\n}\n\nfor(var j=0,jl=uv.length;j<jl;j++){\n\nuvCopy.push(uv[j].clone());\n\n}\n\nuvs1.push(uvCopy);\n\n}\n\n},\n\nmergeMesh:function mergeMesh(mesh){\n\nif((mesh&&mesh.isMesh)===false){\n\nconsole.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',mesh);\nreturn;\n\n}\n\nmesh.matrixAutoUpdate&&mesh.updateMatrix();\n\nthis.merge(mesh.geometry,mesh.matrix);\n\n},\n\n/*\n\t\t * Checks for duplicate vertices with hashmap.\n\t\t * Duplicated vertices are removed\n\t\t * and faces' vertices are updated.\n\t\t */\n\nmergeVertices:function mergeVertices(){\n\nvar verticesMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)\nvar unique=[],changes=[];\n\nvar v,key;\nvar precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001\nvar precision=Math.pow(10,precisionPoints);\nvar i,il,face;\nvar indices,j,jl;\n\nfor(i=0,il=this.vertices.length;i<il;i++){\n\nv=this.vertices[i];\nkey=Math.round(v.x*precision)+'_'+Math.round(v.y*precision)+'_'+Math.round(v.z*precision);\n\nif(verticesMap[key]===undefined){\n\nverticesMap[key]=i;\nunique.push(this.vertices[i]);\nchanges[i]=unique.length-1;\n\n}else{\n\n//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\nchanges[i]=changes[verticesMap[key]];\n\n}\n\n}\n\n\n// if faces are completely degenerate after merging vertices, we\n// have to remove them from the geometry.\nvar faceIndicesToRemove=[];\n\nfor(i=0,il=this.faces.length;i<il;i++){\n\nface=this.faces[i];\n\nface.a=changes[face.a];\nface.b=changes[face.b];\nface.c=changes[face.c];\n\nindices=[face.a,face.b,face.c];\n\n// if any duplicate vertices are found in a Face3\n// we have to remove the face as nothing can be saved\nfor(var n=0;n<3;n++){\n\nif(indices[n]===indices[(n+1)%3]){\n\nfaceIndicesToRemove.push(i);\nbreak;\n\n}\n\n}\n\n}\n\nfor(i=faceIndicesToRemove.length-1;i>=0;i--){\n\nvar idx=faceIndicesToRemove[i];\n\nthis.faces.splice(idx,1);\n\nfor(j=0,jl=this.faceVertexUvs.length;j<jl;j++){\n\nthis.faceVertexUvs[j].splice(idx,1);\n\n}\n\n}\n\n// Use unique set of vertices\n\nvar diff=this.vertices.length-unique.length;\nthis.vertices=unique;\nreturn diff;\n\n},\n\nsortFacesByMaterialIndex:function sortFacesByMaterialIndex(){\n\nvar faces=this.faces;\nvar length=faces.length;\n\n// tag faces\n\nfor(var i=0;i<length;i++){\n\nfaces[i]._id=i;\n\n}\n\n// sort faces\n\nfunction materialIndexSort(a,b){\n\nreturn a.materialIndex-b.materialIndex;\n\n}\n\nfaces.sort(materialIndexSort);\n\n// sort uvs\n\nvar uvs1=this.faceVertexUvs[0];\nvar uvs2=this.faceVertexUvs[1];\n\nvar newUvs1,newUvs2;\n\nif(uvs1&&uvs1.length===length)newUvs1=[];\nif(uvs2&&uvs2.length===length)newUvs2=[];\n\nfor(var i=0;i<length;i++){\n\nvar id=faces[i]._id;\n\nif(newUvs1)newUvs1.push(uvs1[id]);\nif(newUvs2)newUvs2.push(uvs2[id]);\n\n}\n\nif(newUvs1)this.faceVertexUvs[0]=newUvs1;\nif(newUvs2)this.faceVertexUvs[1]=newUvs2;\n\n},\n\ntoJSON:function toJSON(){\n\nvar data={\nmetadata:{\nversion:4.4,\ntype:'Geometry',\ngenerator:'Geometry.toJSON'}};\n\n\n\n// standard Geometry serialization\n\ndata.uuid=this.uuid;\ndata.type=this.type;\nif(this.name!=='')data.name=this.name;\n\nif(this.parameters!==undefined){\n\nvar parameters=this.parameters;\n\nfor(var key in parameters){\n\nif(parameters[key]!==undefined)data[key]=parameters[key];\n\n}\n\nreturn data;\n\n}\n\nvar vertices=[];\n\nfor(var i=0;i<this.vertices.length;i++){\n\nvar vertex=this.vertices[i];\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n}\n\nvar faces=[];\nvar normals=[];\nvar normalsHash={};\nvar colors=[];\nvar colorsHash={};\nvar uvs=[];\nvar uvsHash={};\n\nfor(var i=0;i<this.faces.length;i++){\n\nvar face=this.faces[i];\n\nvar hasMaterial=true;\nvar hasFaceUv=false;// deprecated\nvar hasFaceVertexUv=this.faceVertexUvs[0][i]!==undefined;\nvar hasFaceNormal=face.normal.length()>0;\nvar hasFaceVertexNormal=face.vertexNormals.length>0;\nvar hasFaceColor=face.color.r!==1||face.color.g!==1||face.color.b!==1;\nvar hasFaceVertexColor=face.vertexColors.length>0;\n\nvar faceType=0;\n\nfaceType=setBit(faceType,0,0);// isQuad\nfaceType=setBit(faceType,1,hasMaterial);\nfaceType=setBit(faceType,2,hasFaceUv);\nfaceType=setBit(faceType,3,hasFaceVertexUv);\nfaceType=setBit(faceType,4,hasFaceNormal);\nfaceType=setBit(faceType,5,hasFaceVertexNormal);\nfaceType=setBit(faceType,6,hasFaceColor);\nfaceType=setBit(faceType,7,hasFaceVertexColor);\n\nfaces.push(faceType);\nfaces.push(face.a,face.b,face.c);\nfaces.push(face.materialIndex);\n\nif(hasFaceVertexUv){\n\nvar faceVertexUvs=this.faceVertexUvs[0][i];\n\nfaces.push(\ngetUvIndex(faceVertexUvs[0]),\ngetUvIndex(faceVertexUvs[1]),\ngetUvIndex(faceVertexUvs[2]));\n\n\n}\n\nif(hasFaceNormal){\n\nfaces.push(getNormalIndex(face.normal));\n\n}\n\nif(hasFaceVertexNormal){\n\nvar vertexNormals=face.vertexNormals;\n\nfaces.push(\ngetNormalIndex(vertexNormals[0]),\ngetNormalIndex(vertexNormals[1]),\ngetNormalIndex(vertexNormals[2]));\n\n\n}\n\nif(hasFaceColor){\n\nfaces.push(getColorIndex(face.color));\n\n}\n\nif(hasFaceVertexColor){\n\nvar vertexColors=face.vertexColors;\n\nfaces.push(\ngetColorIndex(vertexColors[0]),\ngetColorIndex(vertexColors[1]),\ngetColorIndex(vertexColors[2]));\n\n\n}\n\n}\n\nfunction setBit(value,position,enabled){\n\nreturn enabled?value|1<<position:value&~(1<<position);\n\n}\n\nfunction getNormalIndex(normal){\n\nvar hash=normal.x.toString()+normal.y.toString()+normal.z.toString();\n\nif(normalsHash[hash]!==undefined){\n\nreturn normalsHash[hash];\n\n}\n\nnormalsHash[hash]=normals.length/3;\nnormals.push(normal.x,normal.y,normal.z);\n\nreturn normalsHash[hash];\n\n}\n\nfunction getColorIndex(color){\n\nvar hash=color.r.toString()+color.g.toString()+color.b.toString();\n\nif(colorsHash[hash]!==undefined){\n\nreturn colorsHash[hash];\n\n}\n\ncolorsHash[hash]=colors.length;\ncolors.push(color.getHex());\n\nreturn colorsHash[hash];\n\n}\n\nfunction getUvIndex(uv){\n\nvar hash=uv.x.toString()+uv.y.toString();\n\nif(uvsHash[hash]!==undefined){\n\nreturn uvsHash[hash];\n\n}\n\nuvsHash[hash]=uvs.length/2;\nuvs.push(uv.x,uv.y);\n\nreturn uvsHash[hash];\n\n}\n\ndata.data={};\n\ndata.data.vertices=vertices;\ndata.data.normals=normals;\nif(colors.length>0)data.data.colors=colors;\nif(uvs.length>0)data.data.uvs=[uvs];// temporal backward compatibility\ndata.data.faces=faces;\n\nreturn data;\n\n},\n\nclone:function clone(){\n\n/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\nreturn new Geometry().copy(this);\n\n},\n\ncopy:function copy(source){\n\nvar i,il,j,jl,k,kl;\n\n// reset\n\nthis.vertices=[];\nthis.colors=[];\nthis.faces=[];\nthis.faceVertexUvs=[[]];\nthis.morphTargets=[];\nthis.morphNormals=[];\nthis.skinWeights=[];\nthis.skinIndices=[];\nthis.lineDistances=[];\nthis.boundingBox=null;\nthis.boundingSphere=null;\n\n// name\n\nthis.name=source.name;\n\n// vertices\n\nvar vertices=source.vertices;\n\nfor(i=0,il=vertices.length;i<il;i++){\n\nthis.vertices.push(vertices[i].clone());\n\n}\n\n// colors\n\nvar colors=source.colors;\n\nfor(i=0,il=colors.length;i<il;i++){\n\nthis.colors.push(colors[i].clone());\n\n}\n\n// faces\n\nvar faces=source.faces;\n\nfor(i=0,il=faces.length;i<il;i++){\n\nthis.faces.push(faces[i].clone());\n\n}\n\n// face vertex uvs\n\nfor(i=0,il=source.faceVertexUvs.length;i<il;i++){\n\nvar faceVertexUvs=source.faceVertexUvs[i];\n\nif(this.faceVertexUvs[i]===undefined){\n\nthis.faceVertexUvs[i]=[];\n\n}\n\nfor(j=0,jl=faceVertexUvs.length;j<jl;j++){\n\nvar uvs=faceVertexUvs[j],uvsCopy=[];\n\nfor(k=0,kl=uvs.length;k<kl;k++){\n\nvar uv=uvs[k];\n\nuvsCopy.push(uv.clone());\n\n}\n\nthis.faceVertexUvs[i].push(uvsCopy);\n\n}\n\n}\n\n// morph targets\n\nvar morphTargets=source.morphTargets;\n\nfor(i=0,il=morphTargets.length;i<il;i++){\n\nvar morphTarget={};\nmorphTarget.name=morphTargets[i].name;\n\n// vertices\n\nif(morphTargets[i].vertices!==undefined){\n\nmorphTarget.vertices=[];\n\nfor(j=0,jl=morphTargets[i].vertices.length;j<jl;j++){\n\nmorphTarget.vertices.push(morphTargets[i].vertices[j].clone());\n\n}\n\n}\n\n// normals\n\nif(morphTargets[i].normals!==undefined){\n\nmorphTarget.normals=[];\n\nfor(j=0,jl=morphTargets[i].normals.length;j<jl;j++){\n\nmorphTarget.normals.push(morphTargets[i].normals[j].clone());\n\n}\n\n}\n\nthis.morphTargets.push(morphTarget);\n\n}\n\n// morph normals\n\nvar morphNormals=source.morphNormals;\n\nfor(i=0,il=morphNormals.length;i<il;i++){\n\nvar morphNormal={};\n\n// vertex normals\n\nif(morphNormals[i].vertexNormals!==undefined){\n\nmorphNormal.vertexNormals=[];\n\nfor(j=0,jl=morphNormals[i].vertexNormals.length;j<jl;j++){\n\nvar srcVertexNormal=morphNormals[i].vertexNormals[j];\nvar destVertexNormal={};\n\ndestVertexNormal.a=srcVertexNormal.a.clone();\ndestVertexNormal.b=srcVertexNormal.b.clone();\ndestVertexNormal.c=srcVertexNormal.c.clone();\n\nmorphNormal.vertexNormals.push(destVertexNormal);\n\n}\n\n}\n\n// face normals\n\nif(morphNormals[i].faceNormals!==undefined){\n\nmorphNormal.faceNormals=[];\n\nfor(j=0,jl=morphNormals[i].faceNormals.length;j<jl;j++){\n\nmorphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\n\n}\n\n}\n\nthis.morphNormals.push(morphNormal);\n\n}\n\n// skin weights\n\nvar skinWeights=source.skinWeights;\n\nfor(i=0,il=skinWeights.length;i<il;i++){\n\nthis.skinWeights.push(skinWeights[i].clone());\n\n}\n\n// skin indices\n\nvar skinIndices=source.skinIndices;\n\nfor(i=0,il=skinIndices.length;i<il;i++){\n\nthis.skinIndices.push(skinIndices[i].clone());\n\n}\n\n// line distances\n\nvar lineDistances=source.lineDistances;\n\nfor(i=0,il=lineDistances.length;i<il;i++){\n\nthis.lineDistances.push(lineDistances[i]);\n\n}\n\n// bounding box\n\nvar boundingBox=source.boundingBox;\n\nif(boundingBox!==null){\n\nthis.boundingBox=boundingBox.clone();\n\n}\n\n// bounding sphere\n\nvar boundingSphere=source.boundingSphere;\n\nif(boundingSphere!==null){\n\nthis.boundingSphere=boundingSphere.clone();\n\n}\n\n// update flags\n\nthis.elementsNeedUpdate=source.elementsNeedUpdate;\nthis.verticesNeedUpdate=source.verticesNeedUpdate;\nthis.uvsNeedUpdate=source.uvsNeedUpdate;\nthis.normalsNeedUpdate=source.normalsNeedUpdate;\nthis.colorsNeedUpdate=source.colorsNeedUpdate;\nthis.lineDistancesNeedUpdate=source.lineDistancesNeedUpdate;\nthis.groupsNeedUpdate=source.groupsNeedUpdate;\n\nreturn this;\n\n},\n\ndispose:function dispose(){\n\nthis.dispatchEvent({type:'dispose'});\n\n}};\n\n\n\nObject.assign(Geometry.prototype,EventDispatcher.prototype);\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction BufferGeometry(){\n\nObject.defineProperty(this,'id',{value:GeometryIdCount()});\n\nthis.uuid=_Math.generateUUID();\n\nthis.name='';\nthis.type='BufferGeometry';\n\nthis.index=null;\nthis.attributes={};\n\nthis.morphAttributes={};\n\nthis.groups=[];\n\nthis.boundingBox=null;\nthis.boundingSphere=null;\n\nthis.drawRange={start:0,count:Infinity};\n\n}\n\nBufferGeometry.prototype={\n\nconstructor:BufferGeometry,\n\nisBufferGeometry:true,\n\ngetIndex:function getIndex(){\n\nreturn this.index;\n\n},\n\nsetIndex:function setIndex(index){\n\nif(Array.isArray(index)){\n\nthis.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);\n\n}else{\n\nthis.index=index;\n\n}\n\n},\n\naddAttribute:function addAttribute(name,attribute){\n\nif((attribute&&attribute.isBufferAttribute)===false&&(attribute&&attribute.isInterleavedBufferAttribute)===false){\n\nconsole.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\n\nthis.addAttribute(name,new BufferAttribute(arguments[1],arguments[2]));\n\nreturn;\n\n}\n\nif(name==='index'){\n\nconsole.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\nthis.setIndex(attribute);\n\nreturn;\n\n}\n\nthis.attributes[name]=attribute;\n\nreturn this;\n\n},\n\ngetAttribute:function getAttribute(name){\n\nreturn this.attributes[name];\n\n},\n\nremoveAttribute:function removeAttribute(name){\n\ndelete this.attributes[name];\n\nreturn this;\n\n},\n\naddGroup:function addGroup(start,count,materialIndex){\n\nthis.groups.push({\n\nstart:start,\ncount:count,\nmaterialIndex:materialIndex!==undefined?materialIndex:0});\n\n\n\n},\n\nclearGroups:function clearGroups(){\n\nthis.groups=[];\n\n},\n\nsetDrawRange:function setDrawRange(start,count){\n\nthis.drawRange.start=start;\nthis.drawRange.count=count;\n\n},\n\napplyMatrix:function applyMatrix(matrix){\n\nvar position=this.attributes.position;\n\nif(position!==undefined){\n\nmatrix.applyToBufferAttribute(position);\nposition.needsUpdate=true;\n\n}\n\nvar normal=this.attributes.normal;\n\nif(normal!==undefined){\n\nvar normalMatrix=new Matrix3().getNormalMatrix(matrix);\n\nnormalMatrix.applyToBufferAttribute(normal);\nnormal.needsUpdate=true;\n\n}\n\nif(this.boundingBox!==null){\n\nthis.computeBoundingBox();\n\n}\n\nif(this.boundingSphere!==null){\n\nthis.computeBoundingSphere();\n\n}\n\nreturn this;\n\n},\n\nrotateX:function(){\n\n// rotate geometry around world x-axis\n\nvar m1;\n\nreturn function rotateX(angle){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeRotationX(angle);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\nrotateY:function(){\n\n// rotate geometry around world y-axis\n\nvar m1;\n\nreturn function rotateY(angle){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeRotationY(angle);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\nrotateZ:function(){\n\n// rotate geometry around world z-axis\n\nvar m1;\n\nreturn function rotateZ(angle){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeRotationZ(angle);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\ntranslate:function(){\n\n// translate geometry\n\nvar m1;\n\nreturn function translate(x,y,z){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeTranslation(x,y,z);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\nscale:function(){\n\n// scale geometry\n\nvar m1;\n\nreturn function scale(x,y,z){\n\nif(m1===undefined)m1=new Matrix4();\n\nm1.makeScale(x,y,z);\n\nthis.applyMatrix(m1);\n\nreturn this;\n\n};\n\n}(),\n\nlookAt:function(){\n\nvar obj;\n\nreturn function lookAt(vector){\n\nif(obj===undefined)obj=new Object3D();\n\nobj.lookAt(vector);\n\nobj.updateMatrix();\n\nthis.applyMatrix(obj.matrix);\n\n};\n\n}(),\n\ncenter:function center(){\n\nthis.computeBoundingBox();\n\nvar offset=this.boundingBox.getCenter().negate();\n\nthis.translate(offset.x,offset.y,offset.z);\n\nreturn offset;\n\n},\n\nsetFromObject:function setFromObject(object){\n\n// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\n\nvar geometry=object.geometry;\n\nif(object.isPoints||object.isLine){\n\nvar positions=new Float32BufferAttribute(geometry.vertices.length*3,3);\nvar colors=new Float32BufferAttribute(geometry.colors.length*3,3);\n\nthis.addAttribute('position',positions.copyVector3sArray(geometry.vertices));\nthis.addAttribute('color',colors.copyColorsArray(geometry.colors));\n\nif(geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length){\n\nvar lineDistances=new Float32BufferAttribute(geometry.lineDistances.length,1);\n\nthis.addAttribute('lineDistance',lineDistances.copyArray(geometry.lineDistances));\n\n}\n\nif(geometry.boundingSphere!==null){\n\nthis.boundingSphere=geometry.boundingSphere.clone();\n\n}\n\nif(geometry.boundingBox!==null){\n\nthis.boundingBox=geometry.boundingBox.clone();\n\n}\n\n}else if(object.isMesh){\n\nif(geometry&&geometry.isGeometry){\n\nthis.fromGeometry(geometry);\n\n}\n\n}\n\nreturn this;\n\n},\n\nupdateFromObject:function updateFromObject(object){\n\nvar geometry=object.geometry;\n\nif(object.isMesh){\n\nvar direct=geometry.__directGeometry;\n\nif(geometry.elementsNeedUpdate===true){\n\ndirect=undefined;\ngeometry.elementsNeedUpdate=false;\n\n}\n\nif(direct===undefined){\n\nreturn this.fromGeometry(geometry);\n\n}\n\ndirect.verticesNeedUpdate=geometry.verticesNeedUpdate;\ndirect.normalsNeedUpdate=geometry.normalsNeedUpdate;\ndirect.colorsNeedUpdate=geometry.colorsNeedUpdate;\ndirect.uvsNeedUpdate=geometry.uvsNeedUpdate;\ndirect.groupsNeedUpdate=geometry.groupsNeedUpdate;\n\ngeometry.verticesNeedUpdate=false;\ngeometry.normalsNeedUpdate=false;\ngeometry.colorsNeedUpdate=false;\ngeometry.uvsNeedUpdate=false;\ngeometry.groupsNeedUpdate=false;\n\ngeometry=direct;\n\n}\n\nvar attribute;\n\nif(geometry.verticesNeedUpdate===true){\n\nattribute=this.attributes.position;\n\nif(attribute!==undefined){\n\nattribute.copyVector3sArray(geometry.vertices);\nattribute.needsUpdate=true;\n\n}\n\ngeometry.verticesNeedUpdate=false;\n\n}\n\nif(geometry.normalsNeedUpdate===true){\n\nattribute=this.attributes.normal;\n\nif(attribute!==undefined){\n\nattribute.copyVector3sArray(geometry.normals);\nattribute.needsUpdate=true;\n\n}\n\ngeometry.normalsNeedUpdate=false;\n\n}\n\nif(geometry.colorsNeedUpdate===true){\n\nattribute=this.attributes.color;\n\nif(attribute!==undefined){\n\nattribute.copyColorsArray(geometry.colors);\nattribute.needsUpdate=true;\n\n}\n\ngeometry.colorsNeedUpdate=false;\n\n}\n\nif(geometry.uvsNeedUpdate){\n\nattribute=this.attributes.uv;\n\nif(attribute!==undefined){\n\nattribute.copyVector2sArray(geometry.uvs);\nattribute.needsUpdate=true;\n\n}\n\ngeometry.uvsNeedUpdate=false;\n\n}\n\nif(geometry.lineDistancesNeedUpdate){\n\nattribute=this.attributes.lineDistance;\n\nif(attribute!==undefined){\n\nattribute.copyArray(geometry.lineDistances);\nattribute.needsUpdate=true;\n\n}\n\ngeometry.lineDistancesNeedUpdate=false;\n\n}\n\nif(geometry.groupsNeedUpdate){\n\ngeometry.computeGroups(object.geometry);\nthis.groups=geometry.groups;\n\ngeometry.groupsNeedUpdate=false;\n\n}\n\nreturn this;\n\n},\n\nfromGeometry:function fromGeometry(geometry){\n\ngeometry.__directGeometry=new DirectGeometry().fromGeometry(geometry);\n\nreturn this.fromDirectGeometry(geometry.__directGeometry);\n\n},\n\nfromDirectGeometry:function fromDirectGeometry(geometry){\n\nvar positions=new Float32Array(geometry.vertices.length*3);\nthis.addAttribute('position',new BufferAttribute(positions,3).copyVector3sArray(geometry.vertices));\n\nif(geometry.normals.length>0){\n\nvar normals=new Float32Array(geometry.normals.length*3);\nthis.addAttribute('normal',new BufferAttribute(normals,3).copyVector3sArray(geometry.normals));\n\n}\n\nif(geometry.colors.length>0){\n\nvar colors=new Float32Array(geometry.colors.length*3);\nthis.addAttribute('color',new BufferAttribute(colors,3).copyColorsArray(geometry.colors));\n\n}\n\nif(geometry.uvs.length>0){\n\nvar uvs=new Float32Array(geometry.uvs.length*2);\nthis.addAttribute('uv',new BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs));\n\n}\n\nif(geometry.uvs2.length>0){\n\nvar uvs2=new Float32Array(geometry.uvs2.length*2);\nthis.addAttribute('uv2',new BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2));\n\n}\n\nif(geometry.indices.length>0){\n\nvar TypeArray=arrayMax(geometry.indices)>65535?Uint32Array:Uint16Array;\nvar indices=new TypeArray(geometry.indices.length*3);\nthis.setIndex(new BufferAttribute(indices,1).copyIndicesArray(geometry.indices));\n\n}\n\n// groups\n\nthis.groups=geometry.groups;\n\n// morphs\n\nfor(var name in geometry.morphTargets){\n\nvar array=[];\nvar morphTargets=geometry.morphTargets[name];\n\nfor(var i=0,l=morphTargets.length;i<l;i++){\n\nvar morphTarget=morphTargets[i];\n\nvar attribute=new Float32BufferAttribute(morphTarget.length*3,3);\n\narray.push(attribute.copyVector3sArray(morphTarget));\n\n}\n\nthis.morphAttributes[name]=array;\n\n}\n\n// skinning\n\nif(geometry.skinIndices.length>0){\n\nvar skinIndices=new Float32BufferAttribute(geometry.skinIndices.length*4,4);\nthis.addAttribute('skinIndex',skinIndices.copyVector4sArray(geometry.skinIndices));\n\n}\n\nif(geometry.skinWeights.length>0){\n\nvar skinWeights=new Float32BufferAttribute(geometry.skinWeights.length*4,4);\nthis.addAttribute('skinWeight',skinWeights.copyVector4sArray(geometry.skinWeights));\n\n}\n\n//\n\nif(geometry.boundingSphere!==null){\n\nthis.boundingSphere=geometry.boundingSphere.clone();\n\n}\n\nif(geometry.boundingBox!==null){\n\nthis.boundingBox=geometry.boundingBox.clone();\n\n}\n\nreturn this;\n\n},\n\ncomputeBoundingBox:function computeBoundingBox(){\n\nif(this.boundingBox===null){\n\nthis.boundingBox=new Box3();\n\n}\n\nvar position=this.attributes.position;\n\nif(position!==undefined){\n\nthis.boundingBox.setFromBufferAttribute(position);\n\n}else{\n\nthis.boundingBox.makeEmpty();\n\n}\n\nif(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){\n\nconsole.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.',this);\n\n}\n\n},\n\ncomputeBoundingSphere:function(){\n\nvar box=new Box3();\nvar vector=new Vector3();\n\nreturn function computeBoundingSphere(){\n\nif(this.boundingSphere===null){\n\nthis.boundingSphere=new Sphere();\n\n}\n\nvar position=this.attributes.position;\n\nif(position){\n\nvar center=this.boundingSphere.center;\n\nbox.setFromBufferAttribute(position);\nbox.getCenter(center);\n\n// hoping to find a boundingSphere with a radius smaller than the\n// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\nvar maxRadiusSq=0;\n\nfor(var i=0,il=position.count;i<il;i++){\n\nvector.x=position.getX(i);\nvector.y=position.getY(i);\nvector.z=position.getZ(i);\nmaxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(vector));\n\n}\n\nthis.boundingSphere.radius=Math.sqrt(maxRadiusSq);\n\nif(isNaN(this.boundingSphere.radius)){\n\nconsole.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.',this);\n\n}\n\n}\n\n};\n\n}(),\n\ncomputeFaceNormals:function computeFaceNormals(){\n\n// backwards compatibility\n\n},\n\ncomputeVertexNormals:function computeVertexNormals(){\n\nvar index=this.index;\nvar attributes=this.attributes;\nvar groups=this.groups;\n\nif(attributes.position){\n\nvar positions=attributes.position.array;\n\nif(attributes.normal===undefined){\n\nthis.addAttribute('normal',new BufferAttribute(new Float32Array(positions.length),3));\n\n}else{\n\n// reset existing normals to zero\n\nvar array=attributes.normal.array;\n\nfor(var i=0,il=array.length;i<il;i++){\n\narray[i]=0;\n\n}\n\n}\n\nvar normals=attributes.normal.array;\n\nvar vA,vB,vC;\nvar pA=new Vector3(),pB=new Vector3(),pC=new Vector3();\nvar cb=new Vector3(),ab=new Vector3();\n\n// indexed elements\n\nif(index){\n\nvar indices=index.array;\n\nif(groups.length===0){\n\nthis.addGroup(0,indices.length);\n\n}\n\nfor(var j=0,jl=groups.length;j<jl;++j){\n\nvar group=groups[j];\n\nvar start=group.start;\nvar count=group.count;\n\nfor(var i=start,il=start+count;i<il;i+=3){\n\nvA=indices[i+0]*3;\nvB=indices[i+1]*3;\nvC=indices[i+2]*3;\n\npA.fromArray(positions,vA);\npB.fromArray(positions,vB);\npC.fromArray(positions,vC);\n\ncb.subVectors(pC,pB);\nab.subVectors(pA,pB);\ncb.cross(ab);\n\nnormals[vA]+=cb.x;\nnormals[vA+1]+=cb.y;\nnormals[vA+2]+=cb.z;\n\nnormals[vB]+=cb.x;\nnormals[vB+1]+=cb.y;\nnormals[vB+2]+=cb.z;\n\nnormals[vC]+=cb.x;\nnormals[vC+1]+=cb.y;\nnormals[vC+2]+=cb.z;\n\n}\n\n}\n\n}else{\n\n// non-indexed elements (unconnected triangle soup)\n\nfor(var i=0,il=positions.length;i<il;i+=9){\n\npA.fromArray(positions,i);\npB.fromArray(positions,i+3);\npC.fromArray(positions,i+6);\n\ncb.subVectors(pC,pB);\nab.subVectors(pA,pB);\ncb.cross(ab);\n\nnormals[i]=cb.x;\nnormals[i+1]=cb.y;\nnormals[i+2]=cb.z;\n\nnormals[i+3]=cb.x;\nnormals[i+4]=cb.y;\nnormals[i+5]=cb.z;\n\nnormals[i+6]=cb.x;\nnormals[i+7]=cb.y;\nnormals[i+8]=cb.z;\n\n}\n\n}\n\nthis.normalizeNormals();\n\nattributes.normal.needsUpdate=true;\n\n}\n\n},\n\nmerge:function merge(geometry,offset){\n\nif((geometry&&geometry.isBufferGeometry)===false){\n\nconsole.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);\nreturn;\n\n}\n\nif(offset===undefined)offset=0;\n\nvar attributes=this.attributes;\n\nfor(var key in attributes){\n\nif(geometry.attributes[key]===undefined)continue;\n\nvar attribute1=attributes[key];\nvar attributeArray1=attribute1.array;\n\nvar attribute2=geometry.attributes[key];\nvar attributeArray2=attribute2.array;\n\nvar attributeSize=attribute2.itemSize;\n\nfor(var i=0,j=attributeSize*offset;i<attributeArray2.length;i++,j++){\n\nattributeArray1[j]=attributeArray2[i];\n\n}\n\n}\n\nreturn this;\n\n},\n\nnormalizeNormals:function normalizeNormals(){\n\nvar normals=this.attributes.normal.array;\n\nvar x,y,z,n;\n\nfor(var i=0,il=normals.length;i<il;i+=3){\n\nx=normals[i];\ny=normals[i+1];\nz=normals[i+2];\n\nn=1.0/Math.sqrt(x*x+y*y+z*z);\n\nnormals[i]*=n;\nnormals[i+1]*=n;\nnormals[i+2]*=n;\n\n}\n\n},\n\ntoNonIndexed:function toNonIndexed(){\n\nif(this.index===null){\n\nconsole.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');\nreturn this;\n\n}\n\nvar geometry2=new BufferGeometry();\n\nvar indices=this.index.array;\nvar attributes=this.attributes;\n\nfor(var name in attributes){\n\nvar attribute=attributes[name];\n\nvar array=attribute.array;\nvar itemSize=attribute.itemSize;\n\nvar array2=new array.constructor(indices.length*itemSize);\n\nvar index=0,index2=0;\n\nfor(var i=0,l=indices.length;i<l;i++){\n\nindex=indices[i]*itemSize;\n\nfor(var j=0;j<itemSize;j++){\n\narray2[index2++]=array[index++];\n\n}\n\n}\n\ngeometry2.addAttribute(name,new BufferAttribute(array2,itemSize));\n\n}\n\nreturn geometry2;\n\n},\n\ntoJSON:function toJSON(){\n\nvar data={\nmetadata:{\nversion:4.4,\ntype:'BufferGeometry',\ngenerator:'BufferGeometry.toJSON'}};\n\n\n\n// standard BufferGeometry serialization\n\ndata.uuid=this.uuid;\ndata.type=this.type;\nif(this.name!=='')data.name=this.name;\n\nif(this.parameters!==undefined){\n\nvar parameters=this.parameters;\n\nfor(var key in parameters){\n\nif(parameters[key]!==undefined)data[key]=parameters[key];\n\n}\n\nreturn data;\n\n}\n\ndata.data={attributes:{}};\n\nvar index=this.index;\n\nif(index!==null){\n\nvar array=Array.prototype.slice.call(index.array);\n\ndata.data.index={\ntype:index.array.constructor.name,\narray:array};\n\n\n}\n\nvar attributes=this.attributes;\n\nfor(var key in attributes){\n\nvar attribute=attributes[key];\n\nvar array=Array.prototype.slice.call(attribute.array);\n\ndata.data.attributes[key]={\nitemSize:attribute.itemSize,\ntype:attribute.array.constructor.name,\narray:array,\nnormalized:attribute.normalized};\n\n\n}\n\nvar groups=this.groups;\n\nif(groups.length>0){\n\ndata.data.groups=JSON.parse(JSON.stringify(groups));\n\n}\n\nvar boundingSphere=this.boundingSphere;\n\nif(boundingSphere!==null){\n\ndata.data.boundingSphere={\ncenter:boundingSphere.center.toArray(),\nradius:boundingSphere.radius};\n\n\n}\n\nreturn data;\n\n},\n\nclone:function clone(){\n\n/*\n\t\t\t// Handle primitives\n\n\t\t\tvar parameters = this.parameters;\n\n\t\t\tif ( parameters !== undefined ) {\n\n\t\t\t\tvar values = [];\n\n\t\t\t\tfor ( var key in parameters ) {\n\n\t\t\t\t\tvalues.push( parameters[ key ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\n\t\t\t\tthis.constructor.apply( geometry, values );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t\treturn new this.constructor().copy( this );\n\t\t\t*/\n\nreturn new BufferGeometry().copy(this);\n\n},\n\ncopy:function copy(source){\n\nvar name,i,l;\n\n// reset\n\nthis.index=null;\nthis.attributes={};\nthis.morphAttributes={};\nthis.groups=[];\nthis.boundingBox=null;\nthis.boundingSphere=null;\n\n// name\n\nthis.name=source.name;\n\n// index\n\nvar index=source.index;\n\nif(index!==null){\n\nthis.setIndex(index.clone());\n\n}\n\n// attributes\n\nvar attributes=source.attributes;\n\nfor(name in attributes){\n\nvar attribute=attributes[name];\nthis.addAttribute(name,attribute.clone());\n\n}\n\n// morph attributes\n\nvar morphAttributes=source.morphAttributes;\n\nfor(name in morphAttributes){\n\nvar array=[];\nvar morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes\n\nfor(i=0,l=morphAttribute.length;i<l;i++){\n\narray.push(morphAttribute[i].clone());\n\n}\n\nthis.morphAttributes[name]=array;\n\n}\n\n// groups\n\nvar groups=source.groups;\n\nfor(i=0,l=groups.length;i<l;i++){\n\nvar group=groups[i];\nthis.addGroup(group.start,group.count,group.materialIndex);\n\n}\n\n// bounding box\n\nvar boundingBox=source.boundingBox;\n\nif(boundingBox!==null){\n\nthis.boundingBox=boundingBox.clone();\n\n}\n\n// bounding sphere\n\nvar boundingSphere=source.boundingSphere;\n\nif(boundingSphere!==null){\n\nthis.boundingSphere=boundingSphere.clone();\n\n}\n\n// draw range\n\nthis.drawRange.start=source.drawRange.start;\nthis.drawRange.count=source.drawRange.count;\n\nreturn this;\n\n},\n\ndispose:function dispose(){\n\nthis.dispatchEvent({type:'dispose'});\n\n}};\n\n\n\nBufferGeometry.MaxIndex=65535;\n\nObject.assign(BufferGeometry.prototype,EventDispatcher.prototype);\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author jonobr1 / http://jonobr1.com/\n\t */\n\nfunction Mesh(geometry,material){\n\nObject3D.call(this);\n\nthis.type='Mesh';\n\nthis.geometry=geometry!==undefined?geometry:new BufferGeometry();\nthis.material=material!==undefined?material:new MeshBasicMaterial({color:Math.random()*0xffffff});\n\nthis.drawMode=TrianglesDrawMode;\n\nthis.updateMorphTargets();\n\n}\n\nMesh.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:Mesh,\n\nisMesh:true,\n\nsetDrawMode:function setDrawMode(value){\n\nthis.drawMode=value;\n\n},\n\ncopy:function copy(source){\n\nObject3D.prototype.copy.call(this,source);\n\nthis.drawMode=source.drawMode;\n\nreturn this;\n\n},\n\nupdateMorphTargets:function updateMorphTargets(){\n\nvar morphTargets=this.geometry.morphTargets;\n\nif(morphTargets!==undefined&&morphTargets.length>0){\n\nthis.morphTargetInfluences=[];\nthis.morphTargetDictionary={};\n\nfor(var m=0,ml=morphTargets.length;m<ml;m++){\n\nthis.morphTargetInfluences.push(0);\nthis.morphTargetDictionary[morphTargets[m].name]=m;\n\n}\n\n}\n\n},\n\nraycast:function(){\n\nvar inverseMatrix=new Matrix4();\nvar ray=new Ray();\nvar sphere=new Sphere();\n\nvar vA=new Vector3();\nvar vB=new Vector3();\nvar vC=new Vector3();\n\nvar tempA=new Vector3();\nvar tempB=new Vector3();\nvar tempC=new Vector3();\n\nvar uvA=new Vector2();\nvar uvB=new Vector2();\nvar uvC=new Vector2();\n\nvar barycoord=new Vector3();\n\nvar intersectionPoint=new Vector3();\nvar intersectionPointWorld=new Vector3();\n\nfunction uvIntersection(point,p1,p2,p3,uv1,uv2,uv3){\n\nTriangle.barycoordFromPoint(point,p1,p2,p3,barycoord);\n\nuv1.multiplyScalar(barycoord.x);\nuv2.multiplyScalar(barycoord.y);\nuv3.multiplyScalar(barycoord.z);\n\nuv1.add(uv2).add(uv3);\n\nreturn uv1.clone();\n\n}\n\nfunction checkIntersection(object,raycaster,ray,pA,pB,pC,point){\n\nvar intersect;\nvar material=object.material;\n\nif(material.side===BackSide){\n\nintersect=ray.intersectTriangle(pC,pB,pA,true,point);\n\n}else{\n\nintersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);\n\n}\n\nif(intersect===null)return null;\n\nintersectionPointWorld.copy(point);\nintersectionPointWorld.applyMatrix4(object.matrixWorld);\n\nvar distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);\n\nif(distance<raycaster.near||distance>raycaster.far)return null;\n\nreturn{\ndistance:distance,\npoint:intersectionPointWorld.clone(),\nobject:object};\n\n\n}\n\nfunction checkBufferGeometryIntersection(object,raycaster,ray,position,uv,a,b,c){\n\nvA.fromBufferAttribute(position,a);\nvB.fromBufferAttribute(position,b);\nvC.fromBufferAttribute(position,c);\n\nvar intersection=checkIntersection(object,raycaster,ray,vA,vB,vC,intersectionPoint);\n\nif(intersection){\n\nif(uv){\n\nuvA.fromBufferAttribute(uv,a);\nuvB.fromBufferAttribute(uv,b);\nuvC.fromBufferAttribute(uv,c);\n\nintersection.uv=uvIntersection(intersectionPoint,vA,vB,vC,uvA,uvB,uvC);\n\n}\n\nintersection.face=new Face3(a,b,c,Triangle.normal(vA,vB,vC));\nintersection.faceIndex=a;\n\n}\n\nreturn intersection;\n\n}\n\nreturn function raycast(raycaster,intersects){\n\nvar geometry=this.geometry;\nvar material=this.material;\nvar matrixWorld=this.matrixWorld;\n\nif(material===undefined)return;\n\n// Checking boundingSphere distance to ray\n\nif(geometry.boundingSphere===null)geometry.computeBoundingSphere();\n\nsphere.copy(geometry.boundingSphere);\nsphere.applyMatrix4(matrixWorld);\n\nif(raycaster.ray.intersectsSphere(sphere)===false)return;\n\n//\n\ninverseMatrix.getInverse(matrixWorld);\nray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n\n// Check boundingBox before continuing\n\nif(geometry.boundingBox!==null){\n\nif(ray.intersectsBox(geometry.boundingBox)===false)return;\n\n}\n\nvar intersection;\n\nif(geometry.isBufferGeometry){\n\nvar a,b,c;\nvar index=geometry.index;\nvar position=geometry.attributes.position;\nvar uv=geometry.attributes.uv;\nvar i,l;\n\nif(index!==null){\n\n// indexed buffer geometry\n\nfor(i=0,l=index.count;i<l;i+=3){\n\na=index.getX(i);\nb=index.getX(i+1);\nc=index.getX(i+2);\n\nintersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);\n\nif(intersection){\n\nintersection.faceIndex=Math.floor(i/3);// triangle number in indices buffer semantics\nintersects.push(intersection);\n\n}\n\n}\n\n}else{\n\n// non-indexed buffer geometry\n\nfor(i=0,l=position.count;i<l;i+=3){\n\na=i;\nb=i+1;\nc=i+2;\n\nintersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);\n\nif(intersection){\n\nintersection.index=a;// triangle number in positions buffer semantics\nintersects.push(intersection);\n\n}\n\n}\n\n}\n\n}else if(geometry.isGeometry){\n\nvar fvA,fvB,fvC;\nvar isFaceMaterial=material&&material.isMultiMaterial;\nvar materials=isFaceMaterial===true?material.materials:null;\n\nvar vertices=geometry.vertices;\nvar faces=geometry.faces;\nvar uvs;\n\nvar faceVertexUvs=geometry.faceVertexUvs[0];\nif(faceVertexUvs.length>0)uvs=faceVertexUvs;\n\nfor(var f=0,fl=faces.length;f<fl;f++){\n\nvar face=faces[f];\nvar faceMaterial=isFaceMaterial===true?materials[face.materialIndex]:material;\n\nif(faceMaterial===undefined)continue;\n\nfvA=vertices[face.a];\nfvB=vertices[face.b];\nfvC=vertices[face.c];\n\nif(faceMaterial.morphTargets===true){\n\nvar morphTargets=geometry.morphTargets;\nvar morphInfluences=this.morphTargetInfluences;\n\nvA.set(0,0,0);\nvB.set(0,0,0);\nvC.set(0,0,0);\n\nfor(var t=0,tl=morphTargets.length;t<tl;t++){\n\nvar influence=morphInfluences[t];\n\nif(influence===0)continue;\n\nvar targets=morphTargets[t].vertices;\n\nvA.addScaledVector(tempA.subVectors(targets[face.a],fvA),influence);\nvB.addScaledVector(tempB.subVectors(targets[face.b],fvB),influence);\nvC.addScaledVector(tempC.subVectors(targets[face.c],fvC),influence);\n\n}\n\nvA.add(fvA);\nvB.add(fvB);\nvC.add(fvC);\n\nfvA=vA;\nfvB=vB;\nfvC=vC;\n\n}\n\nintersection=checkIntersection(this,raycaster,ray,fvA,fvB,fvC,intersectionPoint);\n\nif(intersection){\n\nif(uvs){\n\nvar uvs_f=uvs[f];\nuvA.copy(uvs_f[0]);\nuvB.copy(uvs_f[1]);\nuvC.copy(uvs_f[2]);\n\nintersection.uv=uvIntersection(intersectionPoint,fvA,fvB,fvC,uvA,uvB,uvC);\n\n}\n\nintersection.face=face;\nintersection.faceIndex=f;\nintersects.push(intersection);\n\n}\n\n}\n\n}\n\n};\n\n}(),\n\nclone:function clone(){\n\nreturn new this.constructor(this.geometry,this.material).copy(this);\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n\t */\n\nfunction BoxGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){\n\nGeometry.call(this);\n\nthis.type='BoxGeometry';\n\nthis.parameters={\nwidth:width,\nheight:height,\ndepth:depth,\nwidthSegments:widthSegments,\nheightSegments:heightSegments,\ndepthSegments:depthSegments};\n\n\nthis.fromBufferGeometry(new BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments));\nthis.mergeVertices();\n\n}\n\nBoxGeometry.prototype=Object.create(Geometry.prototype);\nBoxGeometry.prototype.constructor=BoxGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){\n\nBufferGeometry.call(this);\n\nthis.type='BoxBufferGeometry';\n\nthis.parameters={\nwidth:width,\nheight:height,\ndepth:depth,\nwidthSegments:widthSegments,\nheightSegments:heightSegments,\ndepthSegments:depthSegments};\n\n\nvar scope=this;\n\n// segments\n\nwidthSegments=Math.floor(widthSegments)||1;\nheightSegments=Math.floor(heightSegments)||1;\ndepthSegments=Math.floor(depthSegments)||1;\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// helper variables\n\nvar numberOfVertices=0;\nvar groupStart=0;\n\n// build each side of the box geometry\n\nbuildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px\nbuildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx\nbuildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py\nbuildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny\nbuildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz\nbuildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\nfunction buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){\n\nvar segmentWidth=width/gridX;\nvar segmentHeight=height/gridY;\n\nvar widthHalf=width/2;\nvar heightHalf=height/2;\nvar depthHalf=depth/2;\n\nvar gridX1=gridX+1;\nvar gridY1=gridY+1;\n\nvar vertexCounter=0;\nvar groupCount=0;\n\nvar ix,iy;\n\nvar vector=new Vector3();\n\n// generate vertices, normals and uvs\n\nfor(iy=0;iy<gridY1;iy++){\n\nvar y=iy*segmentHeight-heightHalf;\n\nfor(ix=0;ix<gridX1;ix++){\n\nvar x=ix*segmentWidth-widthHalf;\n\n// set values to correct vector component\n\nvector[u]=x*udir;\nvector[v]=y*vdir;\nvector[w]=depthHalf;\n\n// now apply vector to vertex buffer\n\nvertices.push(vector.x,vector.y,vector.z);\n\n// set values to correct vector component\n\nvector[u]=0;\nvector[v]=0;\nvector[w]=depth>0?1:-1;\n\n// now apply vector to normal buffer\n\nnormals.push(vector.x,vector.y,vector.z);\n\n// uvs\n\nuvs.push(ix/gridX);\nuvs.push(1-iy/gridY);\n\n// counters\n\nvertexCounter+=1;\n\n}\n\n}\n\n// indices\n\n// 1. you need three indices to draw a single face\n// 2. a single segment consists of two faces\n// 3. so we need to generate six (2*3) indices per segment\n\nfor(iy=0;iy<gridY;iy++){\n\nfor(ix=0;ix<gridX;ix++){\n\nvar a=numberOfVertices+ix+gridX1*iy;\nvar b=numberOfVertices+ix+gridX1*(iy+1);\nvar c=numberOfVertices+(ix+1)+gridX1*(iy+1);\nvar d=numberOfVertices+(ix+1)+gridX1*iy;\n\n// faces\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n// increase counter\n\ngroupCount+=6;\n\n}\n\n}\n\n// add a group to the geometry. this will ensure multi material support\n\nscope.addGroup(groupStart,groupCount,materialIndex);\n\n// calculate new start value for groups\n\ngroupStart+=groupCount;\n\n// update total number of vertices\n\nnumberOfVertices+=vertexCounter;\n\n}\n\n}\n\nBoxBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nBoxBufferGeometry.prototype.constructor=BoxBufferGeometry;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\nfunction PlaneGeometry(width,height,widthSegments,heightSegments){\n\nGeometry.call(this);\n\nthis.type='PlaneGeometry';\n\nthis.parameters={\nwidth:width,\nheight:height,\nwidthSegments:widthSegments,\nheightSegments:heightSegments};\n\n\nthis.fromBufferGeometry(new PlaneBufferGeometry(width,height,widthSegments,heightSegments));\n\n}\n\nPlaneGeometry.prototype=Object.create(Geometry.prototype);\nPlaneGeometry.prototype.constructor=PlaneGeometry;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n\t */\n\nfunction PlaneBufferGeometry(width,height,widthSegments,heightSegments){\n\nBufferGeometry.call(this);\n\nthis.type='PlaneBufferGeometry';\n\nthis.parameters={\nwidth:width,\nheight:height,\nwidthSegments:widthSegments,\nheightSegments:heightSegments};\n\n\nvar width_half=width/2;\nvar height_half=height/2;\n\nvar gridX=Math.floor(widthSegments)||1;\nvar gridY=Math.floor(heightSegments)||1;\n\nvar gridX1=gridX+1;\nvar gridY1=gridY+1;\n\nvar segment_width=width/gridX;\nvar segment_height=height/gridY;\n\nvar ix,iy;\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// generate vertices, normals and uvs\n\nfor(iy=0;iy<gridY1;iy++){\n\nvar y=iy*segment_height-height_half;\n\nfor(ix=0;ix<gridX1;ix++){\n\nvar x=ix*segment_width-width_half;\n\nvertices.push(x,-y,0);\n\nnormals.push(0,0,1);\n\nuvs.push(ix/gridX);\nuvs.push(1-iy/gridY);\n\n}\n\n}\n\n// indices\n\nfor(iy=0;iy<gridY;iy++){\n\nfor(ix=0;ix<gridX;ix++){\n\nvar a=ix+gridX1*iy;\nvar b=ix+gridX1*(iy+1);\nvar c=ix+1+gridX1*(iy+1);\nvar d=ix+1+gridX1*iy;\n\n// faces\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n}\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n}\n\nPlaneBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nPlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\nfunction Camera(){\n\nObject3D.call(this);\n\nthis.type='Camera';\n\nthis.matrixWorldInverse=new Matrix4();\nthis.projectionMatrix=new Matrix4();\n\n}\n\nCamera.prototype=Object.create(Object3D.prototype);\nCamera.prototype.constructor=Camera;\n\nCamera.prototype.isCamera=true;\n\nCamera.prototype.getWorldDirection=function(){\n\nvar quaternion=new Quaternion();\n\nreturn function getWorldDirection(optionalTarget){\n\nvar result=optionalTarget||new Vector3();\n\nthis.getWorldQuaternion(quaternion);\n\nreturn result.set(0,0,-1).applyQuaternion(quaternion);\n\n};\n\n}();\n\nCamera.prototype.lookAt=function(){\n\n// This routine does not support cameras with rotated and/or translated parent(s)\n\nvar m1=new Matrix4();\n\nreturn function lookAt(vector){\n\nm1.lookAt(this.position,vector,this.up);\n\nthis.quaternion.setFromRotationMatrix(m1);\n\n};\n\n}();\n\nCamera.prototype.clone=function(){\n\nreturn new this.constructor().copy(this);\n\n};\n\nCamera.prototype.copy=function(source){\n\nObject3D.prototype.copy.call(this,source);\n\nthis.matrixWorldInverse.copy(source.matrixWorldInverse);\nthis.projectionMatrix.copy(source.projectionMatrix);\n\nreturn this;\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author greggman / http://games.greggman.com/\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author tschw\n\t */\n\nfunction PerspectiveCamera(fov,aspect,near,far){\n\nCamera.call(this);\n\nthis.type='PerspectiveCamera';\n\nthis.fov=fov!==undefined?fov:50;\nthis.zoom=1;\n\nthis.near=near!==undefined?near:0.1;\nthis.far=far!==undefined?far:2000;\nthis.focus=10;\n\nthis.aspect=aspect!==undefined?aspect:1;\nthis.view=null;\n\nthis.filmGauge=35;// width of the film (default in millimeters)\nthis.filmOffset=0;// horizontal film offset (same unit as gauge)\n\nthis.updateProjectionMatrix();\n\n}\n\nPerspectiveCamera.prototype=Object.assign(Object.create(Camera.prototype),{\n\nconstructor:PerspectiveCamera,\n\nisPerspectiveCamera:true,\n\ncopy:function copy(source){\n\nCamera.prototype.copy.call(this,source);\n\nthis.fov=source.fov;\nthis.zoom=source.zoom;\n\nthis.near=source.near;\nthis.far=source.far;\nthis.focus=source.focus;\n\nthis.aspect=source.aspect;\nthis.view=source.view===null?null:Object.assign({},source.view);\n\nthis.filmGauge=source.filmGauge;\nthis.filmOffset=source.filmOffset;\n\nreturn this;\n\n},\n\n/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\nsetFocalLength:function setFocalLength(focalLength){\n\n// see http://www.bobatkins.com/photography/technical/field_of_view.html\nvar vExtentSlope=0.5*this.getFilmHeight()/focalLength;\n\nthis.fov=_Math.RAD2DEG*2*Math.atan(vExtentSlope);\nthis.updateProjectionMatrix();\n\n},\n\n/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\ngetFocalLength:function getFocalLength(){\n\nvar vExtentSlope=Math.tan(_Math.DEG2RAD*0.5*this.fov);\n\nreturn 0.5*this.getFilmHeight()/vExtentSlope;\n\n},\n\ngetEffectiveFOV:function getEffectiveFOV(){\n\nreturn _Math.RAD2DEG*2*Math.atan(\nMath.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom);\n\n},\n\ngetFilmWidth:function getFilmWidth(){\n\n// film not completely covered in portrait format (aspect < 1)\nreturn this.filmGauge*Math.min(this.aspect,1);\n\n},\n\ngetFilmHeight:function getFilmHeight(){\n\n// film not completely covered in landscape format (aspect > 1)\nreturn this.filmGauge/Math.max(this.aspect,1);\n\n},\n\n/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *   +---+---+---+\n\t\t *   | A | B | C |\n\t\t *   +---+---+---+\n\t\t *   | D | E | F |\n\t\t *   +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *   var w = 1920;\n\t\t *   var h = 1080;\n\t\t *   var fullWidth = w * 3;\n\t\t *   var fullHeight = h * 2;\n\t\t *\n\t\t *   --A--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *   --B--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *   --C--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *   --D--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *   --E--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *   --F--\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\nsetViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){\n\nthis.aspect=fullWidth/fullHeight;\n\nthis.view={\nfullWidth:fullWidth,\nfullHeight:fullHeight,\noffsetX:x,\noffsetY:y,\nwidth:width,\nheight:height};\n\n\nthis.updateProjectionMatrix();\n\n},\n\nclearViewOffset:function clearViewOffset(){\n\nthis.view=null;\nthis.updateProjectionMatrix();\n\n},\n\nupdateProjectionMatrix:function updateProjectionMatrix(){\n\nvar near=this.near,\ntop=near*Math.tan(\n_Math.DEG2RAD*0.5*this.fov)/this.zoom,\nheight=2*top,\nwidth=this.aspect*height,\nleft=-0.5*width,\nview=this.view;\n\nif(view!==null){\n\nvar fullWidth=view.fullWidth,\nfullHeight=view.fullHeight;\n\nleft+=view.offsetX*width/fullWidth;\ntop-=view.offsetY*height/fullHeight;\nwidth*=view.width/fullWidth;\nheight*=view.height/fullHeight;\n\n}\n\nvar skew=this.filmOffset;\nif(skew!==0)left+=near*skew/this.getFilmWidth();\n\nthis.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);\n\n},\n\ntoJSON:function toJSON(meta){\n\nvar data=Object3D.prototype.toJSON.call(this,meta);\n\ndata.object.fov=this.fov;\ndata.object.zoom=this.zoom;\n\ndata.object.near=this.near;\ndata.object.far=this.far;\ndata.object.focus=this.focus;\n\ndata.object.aspect=this.aspect;\n\nif(this.view!==null)data.object.view=Object.assign({},this.view);\n\ndata.object.filmGauge=this.filmGauge;\ndata.object.filmOffset=this.filmOffset;\n\nreturn data;\n\n}});\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author arose / http://github.com/arose\n\t */\n\nfunction OrthographicCamera(left,right,top,bottom,near,far){\n\nCamera.call(this);\n\nthis.type='OrthographicCamera';\n\nthis.zoom=1;\nthis.view=null;\n\nthis.left=left;\nthis.right=right;\nthis.top=top;\nthis.bottom=bottom;\n\nthis.near=near!==undefined?near:0.1;\nthis.far=far!==undefined?far:2000;\n\nthis.updateProjectionMatrix();\n\n}\n\nOrthographicCamera.prototype=Object.assign(Object.create(Camera.prototype),{\n\nconstructor:OrthographicCamera,\n\nisOrthographicCamera:true,\n\ncopy:function copy(source){\n\nCamera.prototype.copy.call(this,source);\n\nthis.left=source.left;\nthis.right=source.right;\nthis.top=source.top;\nthis.bottom=source.bottom;\nthis.near=source.near;\nthis.far=source.far;\n\nthis.zoom=source.zoom;\nthis.view=source.view===null?null:Object.assign({},source.view);\n\nreturn this;\n\n},\n\nsetViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){\n\nthis.view={\nfullWidth:fullWidth,\nfullHeight:fullHeight,\noffsetX:x,\noffsetY:y,\nwidth:width,\nheight:height};\n\n\nthis.updateProjectionMatrix();\n\n},\n\nclearViewOffset:function clearViewOffset(){\n\nthis.view=null;\nthis.updateProjectionMatrix();\n\n},\n\nupdateProjectionMatrix:function updateProjectionMatrix(){\n\nvar dx=(this.right-this.left)/(2*this.zoom);\nvar dy=(this.top-this.bottom)/(2*this.zoom);\nvar cx=(this.right+this.left)/2;\nvar cy=(this.top+this.bottom)/2;\n\nvar left=cx-dx;\nvar right=cx+dx;\nvar top=cy+dy;\nvar bottom=cy-dy;\n\nif(this.view!==null){\n\nvar zoomW=this.zoom/(this.view.width/this.view.fullWidth);\nvar zoomH=this.zoom/(this.view.height/this.view.fullHeight);\nvar scaleW=(this.right-this.left)/this.view.width;\nvar scaleH=(this.top-this.bottom)/this.view.height;\n\nleft+=scaleW*(this.view.offsetX/zoomW);\nright=left+scaleW*(this.view.width/zoomW);\ntop-=scaleH*(this.view.offsetY/zoomH);\nbottom=top-scaleH*(this.view.height/zoomH);\n\n}\n\nthis.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);\n\n},\n\ntoJSON:function toJSON(meta){\n\nvar data=Object3D.prototype.toJSON.call(this,meta);\n\ndata.object.zoom=this.zoom;\ndata.object.left=this.left;\ndata.object.right=this.right;\ndata.object.top=this.top;\ndata.object.bottom=this.bottom;\ndata.object.near=this.near;\ndata.object.far=this.far;\n\nif(this.view!==null)data.object.view=Object.assign({},this.view);\n\nreturn data;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLIndexedBufferRenderer(gl,extensions,infoRender){\n\nvar mode;\n\nfunction setMode(value){\n\nmode=value;\n\n}\n\nvar type,size;\n\nfunction setIndex(index){\n\nif(index.array instanceof Uint32Array&&extensions.get('OES_element_index_uint')){\n\ntype=gl.UNSIGNED_INT;\nsize=4;\n\n}else if(index.array instanceof Uint16Array){\n\ntype=gl.UNSIGNED_SHORT;\nsize=2;\n\n}else{\n\ntype=gl.UNSIGNED_BYTE;\nsize=1;\n\n}\n\n}\n\nfunction render(start,count){\n\ngl.drawElements(mode,count,type,start*size);\n\ninfoRender.calls++;\ninfoRender.vertices+=count;\n\nif(mode===gl.TRIANGLES)infoRender.faces+=count/3;\n\n}\n\nfunction renderInstances(geometry,start,count){\n\nvar extension=extensions.get('ANGLE_instanced_arrays');\n\nif(extension===null){\n\nconsole.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\nreturn;\n\n}\n\nextension.drawElementsInstancedANGLE(mode,count,type,start*size,geometry.maxInstancedCount);\n\ninfoRender.calls++;\ninfoRender.vertices+=count*geometry.maxInstancedCount;\n\nif(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;\n\n}\n\nreturn{\n\nsetMode:setMode,\nsetIndex:setIndex,\nrender:render,\nrenderInstances:renderInstances};\n\n\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLBufferRenderer(gl,extensions,infoRender){\n\nvar mode;\n\nfunction setMode(value){\n\nmode=value;\n\n}\n\nfunction render(start,count){\n\ngl.drawArrays(mode,start,count);\n\ninfoRender.calls++;\ninfoRender.vertices+=count;\n\nif(mode===gl.TRIANGLES)infoRender.faces+=count/3;\n\n}\n\nfunction renderInstances(geometry){\n\nvar extension=extensions.get('ANGLE_instanced_arrays');\n\nif(extension===null){\n\nconsole.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\nreturn;\n\n}\n\nvar position=geometry.attributes.position;\n\nvar count=0;\n\nif(position.isInterleavedBufferAttribute){\n\ncount=position.data.count;\n\nextension.drawArraysInstancedANGLE(mode,0,count,geometry.maxInstancedCount);\n\n}else{\n\ncount=position.count;\n\nextension.drawArraysInstancedANGLE(mode,0,count,geometry.maxInstancedCount);\n\n}\n\ninfoRender.calls++;\ninfoRender.vertices+=count*geometry.maxInstancedCount;\n\nif(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;\n\n}\n\nreturn{\nsetMode:setMode,\nrender:render,\nrenderInstances:renderInstances};\n\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLLights(){\n\nvar lights={};\n\nreturn{\n\nget:function get(light){\n\nif(lights[light.id]!==undefined){\n\nreturn lights[light.id];\n\n}\n\nvar uniforms;\n\nswitch(light.type){\n\ncase'DirectionalLight':\nuniforms={\ndirection:new Vector3(),\ncolor:new Color(),\n\nshadow:false,\nshadowBias:0,\nshadowRadius:1,\nshadowMapSize:new Vector2()};\n\nbreak;\n\ncase'SpotLight':\nuniforms={\nposition:new Vector3(),\ndirection:new Vector3(),\ncolor:new Color(),\ndistance:0,\nconeCos:0,\npenumbraCos:0,\ndecay:0,\n\nshadow:false,\nshadowBias:0,\nshadowRadius:1,\nshadowMapSize:new Vector2()};\n\nbreak;\n\ncase'PointLight':\nuniforms={\nposition:new Vector3(),\ncolor:new Color(),\ndistance:0,\ndecay:0,\n\nshadow:false,\nshadowBias:0,\nshadowRadius:1,\nshadowMapSize:new Vector2()};\n\nbreak;\n\ncase'HemisphereLight':\nuniforms={\ndirection:new Vector3(),\nskyColor:new Color(),\ngroundColor:new Color()};\n\nbreak;\n\ncase'RectAreaLight':\nuniforms={\ncolor:new Color(),\nposition:new Vector3(),\nhalfWidth:new Vector3(),\nhalfHeight:new Vector3()\n// TODO (abelnation): set RectAreaLight shadow uniforms\n};\nbreak;}\n\n\n\nlights[light.id]=uniforms;\n\nreturn uniforms;\n\n}};\n\n\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction addLineNumbers(string){\n\nvar lines=string.split('\\n');\n\nfor(var i=0;i<lines.length;i++){\n\nlines[i]=i+1+': '+lines[i];\n\n}\n\nreturn lines.join('\\n');\n\n}\n\nfunction WebGLShader(gl,type,string){\n\nvar shader=gl.createShader(type);\n\ngl.shaderSource(shader,string);\ngl.compileShader(shader);\n\nif(gl.getShaderParameter(shader,gl.COMPILE_STATUS)===false){\n\nconsole.error('THREE.WebGLShader: Shader couldn\\'t compile.');\n\n}\n\nif(gl.getShaderInfoLog(shader)!==''){\n\nconsole.warn('THREE.WebGLShader: gl.getShaderInfoLog()',type===gl.VERTEX_SHADER?'vertex':'fragment',gl.getShaderInfoLog(shader),addLineNumbers(string));\n\n}\n\n// --enable-privileged-webgl-extension\n// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\nreturn shader;\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nvar programIdCount=0;\n\nfunction getEncodingComponents(encoding){\n\nswitch(encoding){\n\ncase LinearEncoding:\nreturn['Linear','( value )'];\ncase sRGBEncoding:\nreturn['sRGB','( value )'];\ncase RGBEEncoding:\nreturn['RGBE','( value )'];\ncase RGBM7Encoding:\nreturn['RGBM','( value, 7.0 )'];\ncase RGBM16Encoding:\nreturn['RGBM','( value, 16.0 )'];\ncase RGBDEncoding:\nreturn['RGBD','( value, 256.0 )'];\ncase GammaEncoding:\nreturn['Gamma','( value, float( GAMMA_FACTOR ) )'];\ndefault:\nthrow new Error('unsupported encoding: '+encoding);}\n\n\n\n}\n\nfunction getTexelDecodingFunction(functionName,encoding){\n\nvar components=getEncodingComponents(encoding);\nreturn\"vec4 \"+functionName+\"( vec4 value ) { return \"+components[0]+\"ToLinear\"+components[1]+\"; }\";\n\n}\n\nfunction getTexelEncodingFunction(functionName,encoding){\n\nvar components=getEncodingComponents(encoding);\nreturn\"vec4 \"+functionName+\"( vec4 value ) { return LinearTo\"+components[0]+components[1]+\"; }\";\n\n}\n\nfunction getToneMappingFunction(functionName,toneMapping){\n\nvar toneMappingName;\n\nswitch(toneMapping){\n\ncase LinearToneMapping:\ntoneMappingName=\"Linear\";\nbreak;\n\ncase ReinhardToneMapping:\ntoneMappingName=\"Reinhard\";\nbreak;\n\ncase Uncharted2ToneMapping:\ntoneMappingName=\"Uncharted2\";\nbreak;\n\ncase CineonToneMapping:\ntoneMappingName=\"OptimizedCineon\";\nbreak;\n\ndefault:\nthrow new Error('unsupported toneMapping: '+toneMapping);}\n\n\n\nreturn\"vec3 \"+functionName+\"( vec3 color ) { return \"+toneMappingName+\"ToneMapping( color ); }\";\n\n}\n\nfunction generateExtensions(extensions,parameters,rendererExtensions){\n\nextensions=extensions||{};\n\nvar chunks=[\nextensions.derivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.normalMap||parameters.flatShading?'#extension GL_OES_standard_derivatives : enable':'',\n(extensions.fragDepth||parameters.logarithmicDepthBuffer)&&rendererExtensions.get('EXT_frag_depth')?'#extension GL_EXT_frag_depth : enable':'',\nextensions.drawBuffers&&rendererExtensions.get('WEBGL_draw_buffers')?'#extension GL_EXT_draw_buffers : require':'',\n(extensions.shaderTextureLOD||parameters.envMap)&&rendererExtensions.get('EXT_shader_texture_lod')?'#extension GL_EXT_shader_texture_lod : enable':''];\n\n\nreturn chunks.filter(filterEmptyLine).join('\\n');\n\n}\n\nfunction generateDefines(defines){\n\nvar chunks=[];\n\nfor(var name in defines){\n\nvar value=defines[name];\n\nif(value===false)continue;\n\nchunks.push('#define '+name+' '+value);\n\n}\n\nreturn chunks.join('\\n');\n\n}\n\nfunction fetchAttributeLocations(gl,program,identifiers){\n\nvar attributes={};\n\nvar n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);\n\nfor(var i=0;i<n;i++){\n\nvar info=gl.getActiveAttrib(program,i);\nvar name=info.name;\n\n// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\n\nattributes[name]=gl.getAttribLocation(program,name);\n\n}\n\nreturn attributes;\n\n}\n\nfunction filterEmptyLine(string){\n\nreturn string!=='';\n\n}\n\nfunction replaceLightNums(string,parameters){\n\nreturn string.\nreplace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).\nreplace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).\nreplace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).\nreplace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).\nreplace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights);\n\n}\n\nfunction parseIncludes(string){\n\nvar pattern=/#include +<([\\w\\d.]+)>/g;\n\nfunction replace(match,include){\n\nvar replace=ShaderChunk[include];\n\nif(replace===undefined){\n\nthrow new Error('Can not resolve #include <'+include+'>');\n\n}\n\nreturn parseIncludes(replace);\n\n}\n\nreturn string.replace(pattern,replace);\n\n}\n\nfunction unrollLoops(string){\n\nvar pattern=/for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\nfunction replace(match,start,end,snippet){\n\nvar unroll='';\n\nfor(var i=parseInt(start);i<parseInt(end);i++){\n\nunroll+=snippet.replace(/\\[ i \\]/g,'[ '+i+' ]');\n\n}\n\nreturn unroll;\n\n}\n\nreturn string.replace(pattern,replace);\n\n}\n\nfunction WebGLProgram(renderer,code,material,parameters){\n\nvar gl=renderer.context;\n\nvar extensions=material.extensions;\nvar defines=material.defines;\n\nvar vertexShader=material.__webglShader.vertexShader;\nvar fragmentShader=material.__webglShader.fragmentShader;\n\nvar shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';\n\nif(parameters.shadowMapType===PCFShadowMap){\n\nshadowMapTypeDefine='SHADOWMAP_TYPE_PCF';\n\n}else if(parameters.shadowMapType===PCFSoftShadowMap){\n\nshadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';\n\n}\n\nvar envMapTypeDefine='ENVMAP_TYPE_CUBE';\nvar envMapModeDefine='ENVMAP_MODE_REFLECTION';\nvar envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';\n\nif(parameters.envMap){\n\nswitch(material.envMap.mapping){\n\ncase CubeReflectionMapping:\ncase CubeRefractionMapping:\nenvMapTypeDefine='ENVMAP_TYPE_CUBE';\nbreak;\n\ncase CubeUVReflectionMapping:\ncase CubeUVRefractionMapping:\nenvMapTypeDefine='ENVMAP_TYPE_CUBE_UV';\nbreak;\n\ncase EquirectangularReflectionMapping:\ncase EquirectangularRefractionMapping:\nenvMapTypeDefine='ENVMAP_TYPE_EQUIREC';\nbreak;\n\ncase SphericalReflectionMapping:\nenvMapTypeDefine='ENVMAP_TYPE_SPHERE';\nbreak;}\n\n\n\nswitch(material.envMap.mapping){\n\ncase CubeRefractionMapping:\ncase EquirectangularRefractionMapping:\nenvMapModeDefine='ENVMAP_MODE_REFRACTION';\nbreak;}\n\n\n\nswitch(material.combine){\n\ncase MultiplyOperation:\nenvMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';\nbreak;\n\ncase MixOperation:\nenvMapBlendingDefine='ENVMAP_BLENDING_MIX';\nbreak;\n\ncase AddOperation:\nenvMapBlendingDefine='ENVMAP_BLENDING_ADD';\nbreak;}\n\n\n\n}\n\nvar gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;\n\n// console.log( 'building new program ' );\n\n//\n\nvar customExtensions=generateExtensions(extensions,parameters,renderer.extensions);\n\nvar customDefines=generateDefines(defines);\n\n//\n\nvar program=gl.createProgram();\n\nvar prefixVertex,prefixFragment;\n\nif(material.isRawShaderMaterial){\n\nprefixVertex=[\n\ncustomDefines,\n\n'\\n'].\n\nfilter(filterEmptyLine).join('\\n');\n\nprefixFragment=[\n\ncustomExtensions,\ncustomDefines,\n\n'\\n'].\n\nfilter(filterEmptyLine).join('\\n');\n\n}else{\n\nprefixVertex=[\n\n\n'precision '+parameters.precision+' float;',\n'precision '+parameters.precision+' int;',\n\n'#define SHADER_NAME '+material.__webglShader.name,\n\ncustomDefines,\n\nparameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'',\n\n'#define GAMMA_FACTOR '+gammaFactorDefine,\n\n'#define MAX_BONES '+parameters.maxBones,\nparameters.useFog&&parameters.fog?'#define USE_FOG':'',\nparameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',\n\n\nparameters.map?'#define USE_MAP':'',\nparameters.envMap?'#define USE_ENVMAP':'',\nparameters.envMap?'#define '+envMapModeDefine:'',\nparameters.lightMap?'#define USE_LIGHTMAP':'',\nparameters.aoMap?'#define USE_AOMAP':'',\nparameters.emissiveMap?'#define USE_EMISSIVEMAP':'',\nparameters.bumpMap?'#define USE_BUMPMAP':'',\nparameters.normalMap?'#define USE_NORMALMAP':'',\nparameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',\nparameters.specularMap?'#define USE_SPECULARMAP':'',\nparameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',\nparameters.metalnessMap?'#define USE_METALNESSMAP':'',\nparameters.alphaMap?'#define USE_ALPHAMAP':'',\nparameters.vertexColors?'#define USE_COLOR':'',\n\nparameters.flatShading?'#define FLAT_SHADED':'',\n\nparameters.skinning?'#define USE_SKINNING':'',\nparameters.useVertexTexture?'#define BONE_TEXTURE':'',\n\nparameters.morphTargets?'#define USE_MORPHTARGETS':'',\nparameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',\nparameters.doubleSided?'#define DOUBLE_SIDED':'',\nparameters.flipSided?'#define FLIP_SIDED':'',\n\n'#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,\n\nparameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',\nparameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',\n\nparameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',\n\nparameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',\nparameters.logarithmicDepthBuffer&&renderer.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',\n\n'uniform mat4 modelMatrix;',\n'uniform mat4 modelViewMatrix;',\n'uniform mat4 projectionMatrix;',\n'uniform mat4 viewMatrix;',\n'uniform mat3 normalMatrix;',\n'uniform vec3 cameraPosition;',\n\n'attribute vec3 position;',\n'attribute vec3 normal;',\n'attribute vec2 uv;',\n\n'#ifdef USE_COLOR',\n\n'\tattribute vec3 color;',\n\n'#endif',\n\n'#ifdef USE_MORPHTARGETS',\n\n'\tattribute vec3 morphTarget0;',\n'\tattribute vec3 morphTarget1;',\n'\tattribute vec3 morphTarget2;',\n'\tattribute vec3 morphTarget3;',\n\n'\t#ifdef USE_MORPHNORMALS',\n\n'\t\tattribute vec3 morphNormal0;',\n'\t\tattribute vec3 morphNormal1;',\n'\t\tattribute vec3 morphNormal2;',\n'\t\tattribute vec3 morphNormal3;',\n\n'\t#else',\n\n'\t\tattribute vec3 morphTarget4;',\n'\t\tattribute vec3 morphTarget5;',\n'\t\tattribute vec3 morphTarget6;',\n'\t\tattribute vec3 morphTarget7;',\n\n'\t#endif',\n\n'#endif',\n\n'#ifdef USE_SKINNING',\n\n'\tattribute vec4 skinIndex;',\n'\tattribute vec4 skinWeight;',\n\n'#endif',\n\n'\\n'].\n\nfilter(filterEmptyLine).join('\\n');\n\nprefixFragment=[\n\ncustomExtensions,\n\n'precision '+parameters.precision+' float;',\n'precision '+parameters.precision+' int;',\n\n'#define SHADER_NAME '+material.__webglShader.name,\n\ncustomDefines,\n\nparameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest:'',\n\n'#define GAMMA_FACTOR '+gammaFactorDefine,\n\nparameters.useFog&&parameters.fog?'#define USE_FOG':'',\nparameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',\n\nparameters.map?'#define USE_MAP':'',\nparameters.envMap?'#define USE_ENVMAP':'',\nparameters.envMap?'#define '+envMapTypeDefine:'',\nparameters.envMap?'#define '+envMapModeDefine:'',\nparameters.envMap?'#define '+envMapBlendingDefine:'',\nparameters.lightMap?'#define USE_LIGHTMAP':'',\nparameters.aoMap?'#define USE_AOMAP':'',\nparameters.emissiveMap?'#define USE_EMISSIVEMAP':'',\nparameters.bumpMap?'#define USE_BUMPMAP':'',\nparameters.normalMap?'#define USE_NORMALMAP':'',\nparameters.specularMap?'#define USE_SPECULARMAP':'',\nparameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',\nparameters.metalnessMap?'#define USE_METALNESSMAP':'',\nparameters.alphaMap?'#define USE_ALPHAMAP':'',\nparameters.vertexColors?'#define USE_COLOR':'',\n\nparameters.gradientMap?'#define USE_GRADIENTMAP':'',\n\nparameters.flatShading?'#define FLAT_SHADED':'',\n\nparameters.doubleSided?'#define DOUBLE_SIDED':'',\nparameters.flipSided?'#define FLIP_SIDED':'',\n\n'#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,\n'#define UNION_CLIPPING_PLANES '+(parameters.numClippingPlanes-parameters.numClipIntersection),\n\nparameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',\nparameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',\n\nparameters.premultipliedAlpha?\"#define PREMULTIPLIED_ALPHA\":'',\n\nparameters.physicallyCorrectLights?\"#define PHYSICALLY_CORRECT_LIGHTS\":'',\n\nparameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',\nparameters.logarithmicDepthBuffer&&renderer.extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',\n\nparameters.envMap&&renderer.extensions.get('EXT_shader_texture_lod')?'#define TEXTURE_LOD_EXT':'',\n\n'uniform mat4 viewMatrix;',\n'uniform vec3 cameraPosition;',\n\nparameters.toneMapping!==NoToneMapping?\"#define TONE_MAPPING\":'',\nparameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below\nparameters.toneMapping!==NoToneMapping?getToneMappingFunction(\"toneMapping\",parameters.toneMapping):'',\n\nparameters.outputEncoding||parameters.mapEncoding||parameters.envMapEncoding||parameters.emissiveMapEncoding?ShaderChunk['encodings_pars_fragment']:'',// this code is required here because it is used by the various encoding/decoding function defined below\nparameters.mapEncoding?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',\nparameters.envMapEncoding?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',\nparameters.emissiveMapEncoding?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',\nparameters.outputEncoding?getTexelEncodingFunction(\"linearToOutputTexel\",parameters.outputEncoding):'',\n\nparameters.depthPacking?\"#define DEPTH_PACKING \"+material.depthPacking:'',\n\n'\\n'].\n\nfilter(filterEmptyLine).join('\\n');\n\n}\n\nvertexShader=parseIncludes(vertexShader,parameters);\nvertexShader=replaceLightNums(vertexShader,parameters);\n\nfragmentShader=parseIncludes(fragmentShader,parameters);\nfragmentShader=replaceLightNums(fragmentShader,parameters);\n\nif(!material.isShaderMaterial){\n\nvertexShader=unrollLoops(vertexShader);\nfragmentShader=unrollLoops(fragmentShader);\n\n}\n\nvar vertexGlsl=prefixVertex+vertexShader;\nvar fragmentGlsl=prefixFragment+fragmentShader;\n\n// console.log( '*VERTEX*', vertexGlsl );\n// console.log( '*FRAGMENT*', fragmentGlsl );\n\nvar glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl);\nvar glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);\n\ngl.attachShader(program,glVertexShader);\ngl.attachShader(program,glFragmentShader);\n\n// Force a particular attribute to index 0.\n\nif(material.index0AttributeName!==undefined){\n\ngl.bindAttribLocation(program,0,material.index0AttributeName);\n\n}else if(parameters.morphTargets===true){\n\n// programs with morphTargets displace position out of attribute 0\ngl.bindAttribLocation(program,0,'position');\n\n}\n\ngl.linkProgram(program);\n\nvar programLog=gl.getProgramInfoLog(program);\nvar vertexLog=gl.getShaderInfoLog(glVertexShader);\nvar fragmentLog=gl.getShaderInfoLog(glFragmentShader);\n\nvar runnable=true;\nvar haveDiagnostics=true;\n\n// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\n// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\n\nif(gl.getProgramParameter(program,gl.LINK_STATUS)===false){\n\nrunnable=false;\n\nconsole.error('THREE.WebGLProgram: shader error: ',gl.getError(),'gl.VALIDATE_STATUS',gl.getProgramParameter(program,gl.VALIDATE_STATUS),'gl.getProgramInfoLog',programLog,vertexLog,fragmentLog);\n\n}else if(programLog!==''){\n\nconsole.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);\n\n}else if(vertexLog===''||fragmentLog===''){\n\nhaveDiagnostics=false;\n\n}\n\nif(haveDiagnostics){\n\nthis.diagnostics={\n\nrunnable:runnable,\nmaterial:material,\n\nprogramLog:programLog,\n\nvertexShader:{\n\nlog:vertexLog,\nprefix:prefixVertex},\n\n\n\nfragmentShader:{\n\nlog:fragmentLog,\nprefix:prefixFragment}};\n\n\n\n\n\n}\n\n// clean up\n\ngl.deleteShader(glVertexShader);\ngl.deleteShader(glFragmentShader);\n\n// set up caching for uniform locations\n\nvar cachedUniforms;\n\nthis.getUniforms=function(){\n\nif(cachedUniforms===undefined){\n\ncachedUniforms=\nnew WebGLUniforms(gl,program,renderer);\n\n}\n\nreturn cachedUniforms;\n\n};\n\n// set up caching for attribute locations\n\nvar cachedAttributes;\n\nthis.getAttributes=function(){\n\nif(cachedAttributes===undefined){\n\ncachedAttributes=fetchAttributeLocations(gl,program);\n\n}\n\nreturn cachedAttributes;\n\n};\n\n// free resource\n\nthis.destroy=function(){\n\ngl.deleteProgram(program);\nthis.program=undefined;\n\n};\n\n// DEPRECATED\n\nObject.defineProperties(this,{\n\nuniforms:{\nget:function get(){\n\nconsole.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');\nreturn this.getUniforms();\n\n}},\n\n\nattributes:{\nget:function get(){\n\nconsole.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');\nreturn this.getAttributes();\n\n}}});\n\n\n\n\n\n//\n\nthis.id=programIdCount++;\nthis.code=code;\nthis.usedTimes=1;\nthis.program=program;\nthis.vertexShader=glVertexShader;\nthis.fragmentShader=glFragmentShader;\n\nreturn this;\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLPrograms(renderer,capabilities){\n\nvar programs=[];\n\nvar shaderIDs={\nMeshDepthMaterial:'depth',\nMeshNormalMaterial:'normal',\nMeshBasicMaterial:'basic',\nMeshLambertMaterial:'lambert',\nMeshPhongMaterial:'phong',\nMeshToonMaterial:'phong',\nMeshStandardMaterial:'physical',\nMeshPhysicalMaterial:'physical',\nLineBasicMaterial:'basic',\nLineDashedMaterial:'dashed',\nPointsMaterial:'points'};\n\n\nvar parameterNames=[\n\"precision\",\"supportsVertexTextures\",\"map\",\"mapEncoding\",\"envMap\",\"envMapMode\",\"envMapEncoding\",\n\"lightMap\",\"aoMap\",\"emissiveMap\",\"emissiveMapEncoding\",\"bumpMap\",\"normalMap\",\"displacementMap\",\"specularMap\",\n\"roughnessMap\",\"metalnessMap\",\"gradientMap\",\n\"alphaMap\",\"combine\",\"vertexColors\",\"fog\",\"useFog\",\"fogExp\",\n\"flatShading\",\"sizeAttenuation\",\"logarithmicDepthBuffer\",\"skinning\",\n\"maxBones\",\"useVertexTexture\",\"morphTargets\",\"morphNormals\",\n\"maxMorphTargets\",\"maxMorphNormals\",\"premultipliedAlpha\",\n\"numDirLights\",\"numPointLights\",\"numSpotLights\",\"numHemiLights\",\"numRectAreaLights\",\n\"shadowMapEnabled\",\"shadowMapType\",\"toneMapping\",'physicallyCorrectLights',\n\"alphaTest\",\"doubleSided\",\"flipSided\",\"numClippingPlanes\",\"numClipIntersection\",\"depthPacking\"];\n\n\n\nfunction allocateBones(object){\n\nif(capabilities.floatVertexTextures&&object&&object.skeleton&&object.skeleton.useVertexTexture){\n\nreturn 1024;\n\n}else{\n\n// default for when object is not specified\n// ( for example when prebuilding shader to be used with multiple objects )\n//\n//  - leave some extra space for other uniforms\n//  - limit here is ANGLE's 254 max uniform vectors\n//    (up to 54 should be safe)\n\nvar nVertexUniforms=capabilities.maxVertexUniforms;\nvar nVertexMatrices=Math.floor((nVertexUniforms-20)/4);\n\nvar maxBones=nVertexMatrices;\n\nif(object!==undefined&&object&&object.isSkinnedMesh){\n\nmaxBones=Math.min(object.skeleton.bones.length,maxBones);\n\nif(maxBones<object.skeleton.bones.length){\n\nconsole.warn('WebGLRenderer: too many bones - '+object.skeleton.bones.length+', this GPU supports just '+maxBones+' (try OpenGL instead of ANGLE)');\n\n}\n\n}\n\nreturn maxBones;\n\n}\n\n}\n\nfunction getTextureEncodingFromMap(map,gammaOverrideLinear){\n\nvar encoding;\n\nif(!map){\n\nencoding=LinearEncoding;\n\n}else if(map.isTexture){\n\nencoding=map.encoding;\n\n}else if(map.isWebGLRenderTarget){\n\nconsole.warn(\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\");\nencoding=map.texture.encoding;\n\n}\n\n// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\nif(encoding===LinearEncoding&&gammaOverrideLinear){\n\nencoding=GammaEncoding;\n\n}\n\nreturn encoding;\n\n}\n\nthis.getParameters=function(material,lights,fog,nClipPlanes,nClipIntersection,object){\n\nvar shaderID=shaderIDs[material.type];\n\n// heuristics to create shader parameters according to lights in the scene\n// (not to blow over maxLights budget)\n\nvar maxBones=allocateBones(object);\nvar precision=renderer.getPrecision();\n\nif(material.precision!==null){\n\nprecision=capabilities.getMaxPrecision(material.precision);\n\nif(precision!==material.precision){\n\nconsole.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');\n\n}\n\n}\n\nvar currentRenderTarget=renderer.getCurrentRenderTarget();\n\nvar parameters={\n\nshaderID:shaderID,\n\nprecision:precision,\nsupportsVertexTextures:capabilities.vertexTextures,\noutputEncoding:getTextureEncodingFromMap(!currentRenderTarget?null:currentRenderTarget.texture,renderer.gammaOutput),\nmap:!!material.map,\nmapEncoding:getTextureEncodingFromMap(material.map,renderer.gammaInput),\nenvMap:!!material.envMap,\nenvMapMode:material.envMap&&material.envMap.mapping,\nenvMapEncoding:getTextureEncodingFromMap(material.envMap,renderer.gammaInput),\nenvMapCubeUV:!!material.envMap&&(material.envMap.mapping===CubeUVReflectionMapping||material.envMap.mapping===CubeUVRefractionMapping),\nlightMap:!!material.lightMap,\naoMap:!!material.aoMap,\nemissiveMap:!!material.emissiveMap,\nemissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap,renderer.gammaInput),\nbumpMap:!!material.bumpMap,\nnormalMap:!!material.normalMap,\ndisplacementMap:!!material.displacementMap,\nroughnessMap:!!material.roughnessMap,\nmetalnessMap:!!material.metalnessMap,\nspecularMap:!!material.specularMap,\nalphaMap:!!material.alphaMap,\n\ngradientMap:!!material.gradientMap,\n\ncombine:material.combine,\n\nvertexColors:material.vertexColors,\n\nfog:!!fog,\nuseFog:material.fog,\nfogExp:fog&&fog.isFogExp2,\n\nflatShading:material.shading===FlatShading,\n\nsizeAttenuation:material.sizeAttenuation,\nlogarithmicDepthBuffer:capabilities.logarithmicDepthBuffer,\n\nskinning:material.skinning,\nmaxBones:maxBones,\nuseVertexTexture:capabilities.floatVertexTextures&&object&&object.skeleton&&object.skeleton.useVertexTexture,\n\nmorphTargets:material.morphTargets,\nmorphNormals:material.morphNormals,\nmaxMorphTargets:renderer.maxMorphTargets,\nmaxMorphNormals:renderer.maxMorphNormals,\n\nnumDirLights:lights.directional.length,\nnumPointLights:lights.point.length,\nnumSpotLights:lights.spot.length,\nnumRectAreaLights:lights.rectArea.length,\nnumHemiLights:lights.hemi.length,\n\nnumClippingPlanes:nClipPlanes,\nnumClipIntersection:nClipIntersection,\n\nshadowMapEnabled:renderer.shadowMap.enabled&&object.receiveShadow&&lights.shadows.length>0,\nshadowMapType:renderer.shadowMap.type,\n\ntoneMapping:renderer.toneMapping,\nphysicallyCorrectLights:renderer.physicallyCorrectLights,\n\npremultipliedAlpha:material.premultipliedAlpha,\n\nalphaTest:material.alphaTest,\ndoubleSided:material.side===DoubleSide,\nflipSided:material.side===BackSide,\n\ndepthPacking:material.depthPacking!==undefined?material.depthPacking:false};\n\n\n\nreturn parameters;\n\n};\n\nthis.getProgramCode=function(material,parameters){\n\nvar array=[];\n\nif(parameters.shaderID){\n\narray.push(parameters.shaderID);\n\n}else{\n\narray.push(material.fragmentShader);\narray.push(material.vertexShader);\n\n}\n\nif(material.defines!==undefined){\n\nfor(var name in material.defines){\n\narray.push(name);\narray.push(material.defines[name]);\n\n}\n\n}\n\nfor(var i=0;i<parameterNames.length;i++){\n\narray.push(parameters[parameterNames[i]]);\n\n}\n\nreturn array.join();\n\n};\n\nthis.acquireProgram=function(material,parameters,code){\n\nvar program;\n\n// Check if code has been already compiled\nfor(var p=0,pl=programs.length;p<pl;p++){\n\nvar programInfo=programs[p];\n\nif(programInfo.code===code){\n\nprogram=programInfo;\n++program.usedTimes;\n\nbreak;\n\n}\n\n}\n\nif(program===undefined){\n\nprogram=new WebGLProgram(renderer,code,material,parameters);\nprograms.push(program);\n\n}\n\nreturn program;\n\n};\n\nthis.releaseProgram=function(program){\n\nif(--program.usedTimes===0){\n\n// Remove from unordered set\nvar i=programs.indexOf(program);\nprograms[i]=programs[programs.length-1];\nprograms.pop();\n\n// Free WebGL resources\nprogram.destroy();\n\n}\n\n};\n\n// Exposed for resource monitoring & error feedback via renderer.info:\nthis.programs=programs;\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLGeometries(gl,properties,info){\n\nvar geometries={};\n\nfunction onGeometryDispose(event){\n\nvar geometry=event.target;\nvar buffergeometry=geometries[geometry.id];\n\nif(buffergeometry.index!==null){\n\ndeleteAttribute(buffergeometry.index);\n\n}\n\ndeleteAttributes(buffergeometry.attributes);\n\ngeometry.removeEventListener('dispose',onGeometryDispose);\n\ndelete geometries[geometry.id];\n\n// TODO\n\nvar property=properties.get(geometry);\n\nif(property.wireframe){\n\ndeleteAttribute(property.wireframe);\n\n}\n\nproperties.delete(geometry);\n\nvar bufferproperty=properties.get(buffergeometry);\n\nif(bufferproperty.wireframe){\n\ndeleteAttribute(bufferproperty.wireframe);\n\n}\n\nproperties.delete(buffergeometry);\n\n//\n\ninfo.memory.geometries--;\n\n}\n\nfunction getAttributeBuffer(attribute){\n\nif(attribute.isInterleavedBufferAttribute){\n\nreturn properties.get(attribute.data).__webglBuffer;\n\n}\n\nreturn properties.get(attribute).__webglBuffer;\n\n}\n\nfunction deleteAttribute(attribute){\n\nvar buffer=getAttributeBuffer(attribute);\n\nif(buffer!==undefined){\n\ngl.deleteBuffer(buffer);\nremoveAttributeBuffer(attribute);\n\n}\n\n}\n\nfunction deleteAttributes(attributes){\n\nfor(var name in attributes){\n\ndeleteAttribute(attributes[name]);\n\n}\n\n}\n\nfunction removeAttributeBuffer(attribute){\n\nif(attribute.isInterleavedBufferAttribute){\n\nproperties.delete(attribute.data);\n\n}else{\n\nproperties.delete(attribute);\n\n}\n\n}\n\nreturn{\n\nget:function get(object){\n\nvar geometry=object.geometry;\n\nif(geometries[geometry.id]!==undefined){\n\nreturn geometries[geometry.id];\n\n}\n\ngeometry.addEventListener('dispose',onGeometryDispose);\n\nvar buffergeometry;\n\nif(geometry.isBufferGeometry){\n\nbuffergeometry=geometry;\n\n}else if(geometry.isGeometry){\n\nif(geometry._bufferGeometry===undefined){\n\ngeometry._bufferGeometry=new BufferGeometry().setFromObject(object);\n\n}\n\nbuffergeometry=geometry._bufferGeometry;\n\n}\n\ngeometries[geometry.id]=buffergeometry;\n\ninfo.memory.geometries++;\n\nreturn buffergeometry;\n\n}};\n\n\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLObjects(gl,properties,info){\n\nvar geometries=new WebGLGeometries(gl,properties,info);\n\n//\n\nfunction update(object){\n\n// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\n\nvar geometry=geometries.get(object);\n\nif(object.geometry.isGeometry){\n\ngeometry.updateFromObject(object);\n\n}\n\nvar index=geometry.index;\nvar attributes=geometry.attributes;\n\nif(index!==null){\n\nupdateAttribute(index,gl.ELEMENT_ARRAY_BUFFER);\n\n}\n\nfor(var name in attributes){\n\nupdateAttribute(attributes[name],gl.ARRAY_BUFFER);\n\n}\n\n// morph targets\n\nvar morphAttributes=geometry.morphAttributes;\n\nfor(var name in morphAttributes){\n\nvar array=morphAttributes[name];\n\nfor(var i=0,l=array.length;i<l;i++){\n\nupdateAttribute(array[i],gl.ARRAY_BUFFER);\n\n}\n\n}\n\nreturn geometry;\n\n}\n\nfunction updateAttribute(attribute,bufferType){\n\nvar data=attribute.isInterleavedBufferAttribute?attribute.data:attribute;\n\nvar attributeProperties=properties.get(data);\n\nif(attributeProperties.__webglBuffer===undefined){\n\ncreateBuffer(attributeProperties,data,bufferType);\n\n}else if(attributeProperties.version!==data.version){\n\nupdateBuffer(attributeProperties,data,bufferType);\n\n}\n\n}\n\nfunction createBuffer(attributeProperties,data,bufferType){\n\nattributeProperties.__webglBuffer=gl.createBuffer();\ngl.bindBuffer(bufferType,attributeProperties.__webglBuffer);\n\nvar usage=data.dynamic?gl.DYNAMIC_DRAW:gl.STATIC_DRAW;\n\ngl.bufferData(bufferType,data.array,usage);\n\nvar type=gl.FLOAT;\nvar array=data.array;\n\nif(array instanceof Float32Array){\n\ntype=gl.FLOAT;\n\n}else if(array instanceof Float64Array){\n\nconsole.warn(\"Unsupported data buffer format: Float64Array\");\n\n}else if(array instanceof Uint16Array){\n\ntype=gl.UNSIGNED_SHORT;\n\n}else if(array instanceof Int16Array){\n\ntype=gl.SHORT;\n\n}else if(array instanceof Uint32Array){\n\ntype=gl.UNSIGNED_INT;\n\n}else if(array instanceof Int32Array){\n\ntype=gl.INT;\n\n}else if(array instanceof Int8Array){\n\ntype=gl.BYTE;\n\n}else if(array instanceof Uint8Array){\n\ntype=gl.UNSIGNED_BYTE;\n\n}\n\nattributeProperties.bytesPerElement=array.BYTES_PER_ELEMENT;\nattributeProperties.type=type;\nattributeProperties.version=data.version;\n\ndata.onUploadCallback();\n\n}\n\nfunction updateBuffer(attributeProperties,data,bufferType){\n\ngl.bindBuffer(bufferType,attributeProperties.__webglBuffer);\n\nif(data.dynamic===false){\n\ngl.bufferData(bufferType,data.array,gl.STATIC_DRAW);\n\n}else if(data.updateRange.count===-1){\n\n// Not using update ranges\n\ngl.bufferSubData(bufferType,0,data.array);\n\n}else if(data.updateRange.count===0){\n\nconsole.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');\n\n}else{\n\ngl.bufferSubData(bufferType,data.updateRange.offset*data.array.BYTES_PER_ELEMENT,\ndata.array.subarray(data.updateRange.offset,data.updateRange.offset+data.updateRange.count));\n\ndata.updateRange.count=0;// reset range\n\n}\n\nattributeProperties.version=data.version;\n\n}\n\nfunction getAttributeBuffer(attribute){\n\nif(attribute.isInterleavedBufferAttribute){\n\nreturn properties.get(attribute.data).__webglBuffer;\n\n}\n\nreturn properties.get(attribute).__webglBuffer;\n\n}\n\nfunction getAttributeProperties(attribute){\n\nif(attribute.isInterleavedBufferAttribute){\n\nreturn properties.get(attribute.data);\n\n}\n\nreturn properties.get(attribute);\n\n}\n\nfunction getWireframeAttribute(geometry){\n\nvar property=properties.get(geometry);\n\nif(property.wireframe!==undefined){\n\nreturn property.wireframe;\n\n}\n\nvar indices=[];\n\nvar index=geometry.index;\nvar attributes=geometry.attributes;\n\n// console.time( 'wireframe' );\n\nif(index!==null){\n\nvar array=index.array;\n\nfor(var i=0,l=array.length;i<l;i+=3){\n\nvar a=array[i+0];\nvar b=array[i+1];\nvar c=array[i+2];\n\nindices.push(a,b,b,c,c,a);\n\n}\n\n}else{\n\nvar array=attributes.position.array;\n\nfor(var i=0,l=array.length/3-1;i<l;i+=3){\n\nvar a=i+0;\nvar b=i+1;\nvar c=i+2;\n\nindices.push(a,b,b,c,c,a);\n\n}\n\n}\n\n// console.timeEnd( 'wireframe' );\n\nvar attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);\n\nupdateAttribute(attribute,gl.ELEMENT_ARRAY_BUFFER);\n\nproperty.wireframe=attribute;\n\nreturn attribute;\n\n}\n\nreturn{\n\ngetAttributeBuffer:getAttributeBuffer,\ngetAttributeProperties:getAttributeProperties,\ngetWireframeAttribute:getWireframeAttribute,\n\nupdate:update};\n\n\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,info){\n\nvar _infoMemory=info.memory;\nvar _isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&_gl instanceof WebGL2RenderingContext;\n\n//\n\nfunction clampToMaxSize(image,maxSize){\n\nif(image.width>maxSize||image.height>maxSize){\n\n// Warning: Scaling through the canvas will only work with images that use\n// premultiplied alpha.\n\nvar scale=maxSize/Math.max(image.width,image.height);\n\nvar canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');\ncanvas.width=Math.floor(image.width*scale);\ncanvas.height=Math.floor(image.height*scale);\n\nvar context=canvas.getContext('2d');\ncontext.drawImage(image,0,0,image.width,image.height,0,0,canvas.width,canvas.height);\n\nconsole.warn('THREE.WebGLRenderer: image is too big ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);\n\nreturn canvas;\n\n}\n\nreturn image;\n\n}\n\nfunction isPowerOfTwo(image){\n\nreturn _Math.isPowerOfTwo(image.width)&&_Math.isPowerOfTwo(image.height);\n\n}\n\nfunction makePowerOfTwo(image){\n\nif(image instanceof HTMLImageElement||image instanceof HTMLCanvasElement){\n\nvar canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');\ncanvas.width=_Math.nearestPowerOfTwo(image.width);\ncanvas.height=_Math.nearestPowerOfTwo(image.height);\n\nvar context=canvas.getContext('2d');\ncontext.drawImage(image,0,0,canvas.width,canvas.height);\n\nconsole.warn('THREE.WebGLRenderer: image is not power of two ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);\n\nreturn canvas;\n\n}\n\nreturn image;\n\n}\n\nfunction textureNeedsPowerOfTwo(texture){\n\nreturn texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||\ntexture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;\n\n}\n\n// Fallback filters for non-power-of-2 textures\n\nfunction filterFallback(f){\n\nif(f===NearestFilter||f===NearestMipMapNearestFilter||f===NearestMipMapLinearFilter){\n\nreturn _gl.NEAREST;\n\n}\n\nreturn _gl.LINEAR;\n\n}\n\n//\n\nfunction onTextureDispose(event){\n\nvar texture=event.target;\n\ntexture.removeEventListener('dispose',onTextureDispose);\n\ndeallocateTexture(texture);\n\n_infoMemory.textures--;\n\n\n}\n\nfunction onRenderTargetDispose(event){\n\nvar renderTarget=event.target;\n\nrenderTarget.removeEventListener('dispose',onRenderTargetDispose);\n\ndeallocateRenderTarget(renderTarget);\n\n_infoMemory.textures--;\n\n}\n\n//\n\nfunction deallocateTexture(texture){\n\nvar textureProperties=properties.get(texture);\n\nif(texture.image&&textureProperties.__image__webglTextureCube){\n\n// cube texture\n\n_gl.deleteTexture(textureProperties.__image__webglTextureCube);\n\n}else{\n\n// 2D texture\n\nif(textureProperties.__webglInit===undefined)return;\n\n_gl.deleteTexture(textureProperties.__webglTexture);\n\n}\n\n// remove all webgl properties\nproperties.delete(texture);\n\n}\n\nfunction deallocateRenderTarget(renderTarget){\n\nvar renderTargetProperties=properties.get(renderTarget);\nvar textureProperties=properties.get(renderTarget.texture);\n\nif(!renderTarget)return;\n\nif(textureProperties.__webglTexture!==undefined){\n\n_gl.deleteTexture(textureProperties.__webglTexture);\n\n}\n\nif(renderTarget.depthTexture){\n\nrenderTarget.depthTexture.dispose();\n\n}\n\nif(renderTarget.isWebGLRenderTargetCube){\n\nfor(var i=0;i<6;i++){\n\n_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\nif(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n\n}\n\n}else{\n\n_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\nif(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n\n}\n\nproperties.delete(renderTarget.texture);\nproperties.delete(renderTarget);\n\n}\n\n//\n\n\n\nfunction setTexture2D(texture,slot){\n\nvar textureProperties=properties.get(texture);\n\nif(texture.version>0&&textureProperties.__version!==texture.version){\n\nvar image=texture.image;\n\nif(image===undefined){\n\nconsole.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined',texture);\n\n}else if(image.complete===false){\n\nconsole.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete',texture);\n\n}else{\n\nuploadTexture(textureProperties,texture,slot);\nreturn;\n\n}\n\n}\n\nstate.activeTexture(_gl.TEXTURE0+slot);\nstate.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);\n\n}\n\nfunction setTextureCube(texture,slot){\n\nvar textureProperties=properties.get(texture);\n\nif(texture.image.length===6){\n\nif(texture.version>0&&textureProperties.__version!==texture.version){\n\nif(!textureProperties.__image__webglTextureCube){\n\ntexture.addEventListener('dispose',onTextureDispose);\n\ntextureProperties.__image__webglTextureCube=_gl.createTexture();\n\n_infoMemory.textures++;\n\n}\n\nstate.activeTexture(_gl.TEXTURE0+slot);\nstate.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);\n\n_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);\n\nvar isCompressed=texture&&texture.isCompressedTexture;\nvar isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;\n\nvar cubeImage=[];\n\nfor(var i=0;i<6;i++){\n\nif(!isCompressed&&!isDataTexture){\n\ncubeImage[i]=clampToMaxSize(texture.image[i],capabilities.maxCubemapSize);\n\n}else{\n\ncubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];\n\n}\n\n}\n\nvar image=cubeImage[0],\nisPowerOfTwoImage=isPowerOfTwo(image),\nglFormat=paramThreeToGL(texture.format),\nglType=paramThreeToGL(texture.type);\n\nsetTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,isPowerOfTwoImage);\n\nfor(var i=0;i<6;i++){\n\nif(!isCompressed){\n\nif(isDataTexture){\n\nstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);\n\n}else{\n\nstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,glFormat,glType,cubeImage[i]);\n\n}\n\n}else{\n\nvar mipmap,mipmaps=cubeImage[i].mipmaps;\n\nfor(var j=0,jl=mipmaps.length;j<jl;j++){\n\nmipmap=mipmaps[j];\n\nif(texture.format!==RGBAFormat&&texture.format!==RGBFormat){\n\nif(state.getCompressedTextureFormats().indexOf(glFormat)>-1){\n\nstate.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,mipmap.data);\n\n}else{\n\nconsole.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\");\n\n}\n\n}else{\n\nstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);\n\n}\n\n}\n\n}\n\n}\n\nif(texture.generateMipmaps&&isPowerOfTwoImage){\n\n_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);\n\n}\n\ntextureProperties.__version=texture.version;\n\nif(texture.onUpdate)texture.onUpdate(texture);\n\n}else{\n\nstate.activeTexture(_gl.TEXTURE0+slot);\nstate.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);\n\n}\n\n}\n\n}\n\nfunction setTextureCubeDynamic(texture,slot){\n\nstate.activeTexture(_gl.TEXTURE0+slot);\nstate.bindTexture(_gl.TEXTURE_CUBE_MAP,properties.get(texture).__webglTexture);\n\n}\n\nfunction setTextureParameters(textureType,texture,isPowerOfTwoImage){\n\nvar extension;\n\nif(isPowerOfTwoImage){\n\n_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,paramThreeToGL(texture.wrapS));\n_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,paramThreeToGL(texture.wrapT));\n\n_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,paramThreeToGL(texture.magFilter));\n_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,paramThreeToGL(texture.minFilter));\n\n}else{\n\n_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,_gl.CLAMP_TO_EDGE);\n_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,_gl.CLAMP_TO_EDGE);\n\nif(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){\n\nconsole.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',texture);\n\n}\n\n_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterFallback(texture.magFilter));\n_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterFallback(texture.minFilter));\n\nif(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){\n\nconsole.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',texture);\n\n}\n\n}\n\nextension=extensions.get('EXT_texture_filter_anisotropic');\n\nif(extension){\n\nif(texture.type===FloatType&&extensions.get('OES_texture_float_linear')===null)return;\nif(texture.type===HalfFloatType&&extensions.get('OES_texture_half_float_linear')===null)return;\n\nif(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){\n\n_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));\nproperties.get(texture).__currentAnisotropy=texture.anisotropy;\n\n}\n\n}\n\n}\n\nfunction uploadTexture(textureProperties,texture,slot){\n\nif(textureProperties.__webglInit===undefined){\n\ntextureProperties.__webglInit=true;\n\ntexture.addEventListener('dispose',onTextureDispose);\n\ntextureProperties.__webglTexture=_gl.createTexture();\n\n_infoMemory.textures++;\n\n}\n\nstate.activeTexture(_gl.TEXTURE0+slot);\nstate.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);\n\n_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);\n_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);\n_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);\n\nvar image=clampToMaxSize(texture.image,capabilities.maxTextureSize);\n\nif(textureNeedsPowerOfTwo(texture)&&isPowerOfTwo(image)===false){\n\nimage=makePowerOfTwo(image);\n\n}\n\nvar isPowerOfTwoImage=isPowerOfTwo(image),\nglFormat=paramThreeToGL(texture.format),\nglType=paramThreeToGL(texture.type);\n\nsetTextureParameters(_gl.TEXTURE_2D,texture,isPowerOfTwoImage);\n\nvar mipmap,mipmaps=texture.mipmaps;\n\nif(texture.isDepthTexture){\n\n// populate depth texture with dummy data\n\nvar internalFormat=_gl.DEPTH_COMPONENT;\n\nif(texture.type===FloatType){\n\nif(!_isWebGL2)throw new Error('Float Depth Texture only supported in WebGL2.0');\ninternalFormat=_gl.DEPTH_COMPONENT32F;\n\n}else if(_isWebGL2){\n\n// WebGL 2.0 requires signed internalformat for glTexImage2D\ninternalFormat=_gl.DEPTH_COMPONENT16;\n\n}\n\nif(texture.format===DepthFormat&&internalFormat===_gl.DEPTH_COMPONENT){\n\n// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\nif(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){\n\nconsole.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');\n\ntexture.type=UnsignedShortType;\nglType=paramThreeToGL(texture.type);\n\n}\n\n}\n\n// Depth stencil textures need the DEPTH_STENCIL internal format\n// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\nif(texture.format===DepthStencilFormat){\n\ninternalFormat=_gl.DEPTH_STENCIL;\n\n// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\nif(texture.type!==UnsignedInt248Type){\n\nconsole.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');\n\ntexture.type=UnsignedInt248Type;\nglType=paramThreeToGL(texture.type);\n\n}\n\n}\n\nstate.texImage2D(_gl.TEXTURE_2D,0,internalFormat,image.width,image.height,0,glFormat,glType,null);\n\n}else if(texture.isDataTexture){\n\n// use manually created mipmaps if available\n// if there are no manual mipmaps\n// set 0 level mipmap and then use GL to generate other mipmap levels\n\nif(mipmaps.length>0&&isPowerOfTwoImage){\n\nfor(var i=0,il=mipmaps.length;i<il;i++){\n\nmipmap=mipmaps[i];\nstate.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);\n\n}\n\ntexture.generateMipmaps=false;\n\n}else{\n\nstate.texImage2D(_gl.TEXTURE_2D,0,glFormat,image.width,image.height,0,glFormat,glType,image.data);\n\n}\n\n}else if(texture.isCompressedTexture){\n\nfor(var i=0,il=mipmaps.length;i<il;i++){\n\nmipmap=mipmaps[i];\n\nif(texture.format!==RGBAFormat&&texture.format!==RGBFormat){\n\nif(state.getCompressedTextureFormats().indexOf(glFormat)>-1){\n\nstate.compressedTexImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,mipmap.data);\n\n}else{\n\nconsole.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\");\n\n}\n\n}else{\n\nstate.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);\n\n}\n\n}\n\n}else{\n\n// regular Texture (image, video, canvas)\n\n// use manually created mipmaps if available\n// if there are no manual mipmaps\n// set 0 level mipmap and then use GL to generate other mipmap levels\n\nif(mipmaps.length>0&&isPowerOfTwoImage){\n\nfor(var i=0,il=mipmaps.length;i<il;i++){\n\nmipmap=mipmaps[i];\nstate.texImage2D(_gl.TEXTURE_2D,i,glFormat,glFormat,glType,mipmap);\n\n}\n\ntexture.generateMipmaps=false;\n\n}else{\n\nstate.texImage2D(_gl.TEXTURE_2D,0,glFormat,glFormat,glType,image);\n\n}\n\n}\n\nif(texture.generateMipmaps&&isPowerOfTwoImage)_gl.generateMipmap(_gl.TEXTURE_2D);\n\ntextureProperties.__version=texture.version;\n\nif(texture.onUpdate)texture.onUpdate(texture);\n\n}\n\n// Render targets\n\n// Setup storage for target texture and bind it to correct framebuffer\nfunction setupFrameBufferTexture(framebuffer,renderTarget,attachment,textureTarget){\n\nvar glFormat=paramThreeToGL(renderTarget.texture.format);\nvar glType=paramThreeToGL(renderTarget.texture.type);\nstate.texImage2D(textureTarget,0,glFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);\n_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(renderTarget.texture).__webglTexture,0);\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);\n\n}\n\n// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\nfunction setupRenderBufferStorage(renderbuffer,renderTarget){\n\n_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);\n\nif(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){\n\n_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_COMPONENT16,renderTarget.width,renderTarget.height);\n_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);\n\n}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){\n\n_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_STENCIL,renderTarget.width,renderTarget.height);\n_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);\n\n}else{\n\n// FIXME: We don't support !depth !stencil\n_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.RGBA4,renderTarget.width,renderTarget.height);\n\n}\n\n_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);\n\n}\n\n// Setup resources for a Depth Texture for a FBO (needs an extension)\nfunction setupDepthTexture(framebuffer,renderTarget){\n\nvar isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;\nif(isCube)throw new Error('Depth Texture with cube render targets is not supported!');\n\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);\n\nif(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){\n\nthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\n}\n\n// upload an empty depth texture with framebuffer size\nif(!properties.get(renderTarget.depthTexture).__webglTexture||\nrenderTarget.depthTexture.image.width!==renderTarget.width||\nrenderTarget.depthTexture.image.height!==renderTarget.height){\nrenderTarget.depthTexture.image.width=renderTarget.width;\nrenderTarget.depthTexture.image.height=renderTarget.height;\nrenderTarget.depthTexture.needsUpdate=true;\n}\n\nsetTexture2D(renderTarget.depthTexture,0);\n\nvar webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;\n\nif(renderTarget.depthTexture.format===DepthFormat){\n\n_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);\n\n}else if(renderTarget.depthTexture.format===DepthStencilFormat){\n\n_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);\n\n}else{\n\nthrow new Error('Unknown depthTexture format');\n\n}\n\n}\n\n// Setup GL resources for a non-texture depth buffer\nfunction setupDepthRenderbuffer(renderTarget){\n\nvar renderTargetProperties=properties.get(renderTarget);\n\nvar isCube=renderTarget.isWebGLRenderTargetCube===true;\n\nif(renderTarget.depthTexture){\n\nif(isCube)throw new Error('target.depthTexture not supported in Cube render targets');\n\nsetupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);\n\n}else{\n\nif(isCube){\n\nrenderTargetProperties.__webglDepthbuffer=[];\n\nfor(var i=0;i<6;i++){\n\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i]);\nrenderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();\nsetupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget);\n\n}\n\n}else{\n\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);\nrenderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();\nsetupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget);\n\n}\n\n}\n\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);\n\n}\n\n// Set up GL resources for the render target\nfunction setupRenderTarget(renderTarget){\n\nvar renderTargetProperties=properties.get(renderTarget);\nvar textureProperties=properties.get(renderTarget.texture);\n\nrenderTarget.addEventListener('dispose',onRenderTargetDispose);\n\ntextureProperties.__webglTexture=_gl.createTexture();\n\n_infoMemory.textures++;\n\nvar isCube=renderTarget.isWebGLRenderTargetCube===true;\nvar isTargetPowerOfTwo=isPowerOfTwo(renderTarget);\n\n// Setup framebuffer\n\nif(isCube){\n\nrenderTargetProperties.__webglFramebuffer=[];\n\nfor(var i=0;i<6;i++){\n\nrenderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();\n\n}\n\n}else{\n\nrenderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();\n\n}\n\n// Setup color buffer\n\nif(isCube){\n\nstate.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture);\nsetTextureParameters(_gl.TEXTURE_CUBE_MAP,renderTarget.texture,isTargetPowerOfTwo);\n\nfor(var i=0;i<6;i++){\n\nsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i);\n\n}\n\nif(renderTarget.texture.generateMipmaps&&isTargetPowerOfTwo)_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);\nstate.bindTexture(_gl.TEXTURE_CUBE_MAP,null);\n\n}else{\n\nstate.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);\nsetTextureParameters(_gl.TEXTURE_2D,renderTarget.texture,isTargetPowerOfTwo);\nsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D);\n\nif(renderTarget.texture.generateMipmaps&&isTargetPowerOfTwo)_gl.generateMipmap(_gl.TEXTURE_2D);\nstate.bindTexture(_gl.TEXTURE_2D,null);\n\n}\n\n// Setup depth and stencil buffers\n\nif(renderTarget.depthBuffer){\n\nsetupDepthRenderbuffer(renderTarget);\n\n}\n\n}\n\nfunction updateRenderTargetMipmap(renderTarget){\n\nvar texture=renderTarget.texture;\n\nif(texture.generateMipmaps&&isPowerOfTwo(renderTarget)&&\ntexture.minFilter!==NearestFilter&&\ntexture.minFilter!==LinearFilter){\n\nvar target=renderTarget&&renderTarget.isWebGLRenderTargetCube?_gl.TEXTURE_CUBE_MAP:_gl.TEXTURE_2D;\nvar webglTexture=properties.get(texture).__webglTexture;\n\nstate.bindTexture(target,webglTexture);\n_gl.generateMipmap(target);\nstate.bindTexture(target,null);\n\n}\n\n}\n\nthis.setTexture2D=setTexture2D;\nthis.setTextureCube=setTextureCube;\nthis.setTextureCubeDynamic=setTextureCubeDynamic;\nthis.setupRenderTarget=setupRenderTarget;\nthis.updateRenderTargetMipmap=updateRenderTargetMipmap;\n\n}\n\n/**\n\t * @author fordacious / fordacious.github.io\n\t */\n\nfunction WebGLProperties(){\n\nvar properties={};\n\nreturn{\n\nget:function get(object){\n\nvar uuid=object.uuid;\nvar map=properties[uuid];\n\nif(map===undefined){\n\nmap={};\nproperties[uuid]=map;\n\n}\n\nreturn map;\n\n},\n\ndelete:function _delete(object){\n\ndelete properties[object.uuid];\n\n},\n\nclear:function clear(){\n\nproperties={};\n\n}};\n\n\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLState(gl,extensions,paramThreeToGL){\n\nfunction ColorBuffer(){\n\nvar locked=false;\n\nvar color=new Vector4();\nvar currentColorMask=null;\nvar currentColorClear=new Vector4();\n\nreturn{\n\nsetMask:function setMask(colorMask){\n\nif(currentColorMask!==colorMask&&!locked){\n\ngl.colorMask(colorMask,colorMask,colorMask,colorMask);\ncurrentColorMask=colorMask;\n\n}\n\n},\n\nsetLocked:function setLocked(lock){\n\nlocked=lock;\n\n},\n\nsetClear:function setClear(r,g,b,a,premultipliedAlpha){\n\nif(premultipliedAlpha===true){\n\nr*=a;g*=a;b*=a;\n\n}\n\ncolor.set(r,g,b,a);\n\nif(currentColorClear.equals(color)===false){\n\ngl.clearColor(r,g,b,a);\ncurrentColorClear.copy(color);\n\n}\n\n},\n\nreset:function reset(){\n\nlocked=false;\n\ncurrentColorMask=null;\ncurrentColorClear.set(0,0,0,1);\n\n}};\n\n\n\n}\n\nfunction DepthBuffer(){\n\nvar locked=false;\n\nvar currentDepthMask=null;\nvar currentDepthFunc=null;\nvar currentDepthClear=null;\n\nreturn{\n\nsetTest:function setTest(depthTest){\n\nif(depthTest){\n\nenable(gl.DEPTH_TEST);\n\n}else{\n\ndisable(gl.DEPTH_TEST);\n\n}\n\n},\n\nsetMask:function setMask(depthMask){\n\nif(currentDepthMask!==depthMask&&!locked){\n\ngl.depthMask(depthMask);\ncurrentDepthMask=depthMask;\n\n}\n\n},\n\nsetFunc:function setFunc(depthFunc){\n\nif(currentDepthFunc!==depthFunc){\n\nif(depthFunc){\n\nswitch(depthFunc){\n\ncase NeverDepth:\n\ngl.depthFunc(gl.NEVER);\nbreak;\n\ncase AlwaysDepth:\n\ngl.depthFunc(gl.ALWAYS);\nbreak;\n\ncase LessDepth:\n\ngl.depthFunc(gl.LESS);\nbreak;\n\ncase LessEqualDepth:\n\ngl.depthFunc(gl.LEQUAL);\nbreak;\n\ncase EqualDepth:\n\ngl.depthFunc(gl.EQUAL);\nbreak;\n\ncase GreaterEqualDepth:\n\ngl.depthFunc(gl.GEQUAL);\nbreak;\n\ncase GreaterDepth:\n\ngl.depthFunc(gl.GREATER);\nbreak;\n\ncase NotEqualDepth:\n\ngl.depthFunc(gl.NOTEQUAL);\nbreak;\n\ndefault:\n\ngl.depthFunc(gl.LEQUAL);}\n\n\n\n}else{\n\ngl.depthFunc(gl.LEQUAL);\n\n}\n\ncurrentDepthFunc=depthFunc;\n\n}\n\n},\n\nsetLocked:function setLocked(lock){\n\nlocked=lock;\n\n},\n\nsetClear:function setClear(depth){\n\nif(currentDepthClear!==depth){\n\ngl.clearDepth(depth);\ncurrentDepthClear=depth;\n\n}\n\n},\n\nreset:function reset(){\n\nlocked=false;\n\ncurrentDepthMask=null;\ncurrentDepthFunc=null;\ncurrentDepthClear=null;\n\n}};\n\n\n\n}\n\nfunction StencilBuffer(){\n\nvar locked=false;\n\nvar currentStencilMask=null;\nvar currentStencilFunc=null;\nvar currentStencilRef=null;\nvar currentStencilFuncMask=null;\nvar currentStencilFail=null;\nvar currentStencilZFail=null;\nvar currentStencilZPass=null;\nvar currentStencilClear=null;\n\nreturn{\n\nsetTest:function setTest(stencilTest){\n\nif(stencilTest){\n\nenable(gl.STENCIL_TEST);\n\n}else{\n\ndisable(gl.STENCIL_TEST);\n\n}\n\n},\n\nsetMask:function setMask(stencilMask){\n\nif(currentStencilMask!==stencilMask&&!locked){\n\ngl.stencilMask(stencilMask);\ncurrentStencilMask=stencilMask;\n\n}\n\n},\n\nsetFunc:function setFunc(stencilFunc,stencilRef,stencilMask){\n\nif(currentStencilFunc!==stencilFunc||\ncurrentStencilRef!==stencilRef||\ncurrentStencilFuncMask!==stencilMask){\n\ngl.stencilFunc(stencilFunc,stencilRef,stencilMask);\n\ncurrentStencilFunc=stencilFunc;\ncurrentStencilRef=stencilRef;\ncurrentStencilFuncMask=stencilMask;\n\n}\n\n},\n\nsetOp:function setOp(stencilFail,stencilZFail,stencilZPass){\n\nif(currentStencilFail!==stencilFail||\ncurrentStencilZFail!==stencilZFail||\ncurrentStencilZPass!==stencilZPass){\n\ngl.stencilOp(stencilFail,stencilZFail,stencilZPass);\n\ncurrentStencilFail=stencilFail;\ncurrentStencilZFail=stencilZFail;\ncurrentStencilZPass=stencilZPass;\n\n}\n\n},\n\nsetLocked:function setLocked(lock){\n\nlocked=lock;\n\n},\n\nsetClear:function setClear(stencil){\n\nif(currentStencilClear!==stencil){\n\ngl.clearStencil(stencil);\ncurrentStencilClear=stencil;\n\n}\n\n},\n\nreset:function reset(){\n\nlocked=false;\n\ncurrentStencilMask=null;\ncurrentStencilFunc=null;\ncurrentStencilRef=null;\ncurrentStencilFuncMask=null;\ncurrentStencilFail=null;\ncurrentStencilZFail=null;\ncurrentStencilZPass=null;\ncurrentStencilClear=null;\n\n}};\n\n\n\n}\n\n//\n\nvar colorBuffer=new ColorBuffer();\nvar depthBuffer=new DepthBuffer();\nvar stencilBuffer=new StencilBuffer();\n\nvar maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\nvar newAttributes=new Uint8Array(maxVertexAttributes);\nvar enabledAttributes=new Uint8Array(maxVertexAttributes);\nvar attributeDivisors=new Uint8Array(maxVertexAttributes);\n\nvar capabilities={};\n\nvar compressedTextureFormats=null;\n\nvar currentBlending=null;\nvar currentBlendEquation=null;\nvar currentBlendSrc=null;\nvar currentBlendDst=null;\nvar currentBlendEquationAlpha=null;\nvar currentBlendSrcAlpha=null;\nvar currentBlendDstAlpha=null;\nvar currentPremultipledAlpha=false;\n\nvar currentFlipSided=null;\nvar currentCullFace=null;\n\nvar currentLineWidth=null;\n\nvar currentPolygonOffsetFactor=null;\nvar currentPolygonOffsetUnits=null;\n\nvar currentScissorTest=null;\n\nvar maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\nvar version=parseFloat(/^WebGL\\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);\nvar lineWidthAvailable=parseFloat(version)>=1.0;\n\nvar currentTextureSlot=null;\nvar currentBoundTextures={};\n\nvar currentScissor=new Vector4();\nvar currentViewport=new Vector4();\n\nfunction createTexture(type,target,count){\n\nvar data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.\nvar texture=gl.createTexture();\n\ngl.bindTexture(type,texture);\ngl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);\ngl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);\n\nfor(var i=0;i<count;i++){\n\ngl.texImage2D(target+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);\n\n}\n\nreturn texture;\n\n}\n\nvar emptyTextures={};\nemptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);\nemptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);\n\n//\n\nfunction init(){\n\ncolorBuffer.setClear(0,0,0,1);\ndepthBuffer.setClear(1);\nstencilBuffer.setClear(0);\n\nenable(gl.DEPTH_TEST);\nsetDepthFunc(LessEqualDepth);\n\nsetFlipSided(false);\nsetCullFace(CullFaceBack);\nenable(gl.CULL_FACE);\n\nenable(gl.BLEND);\nsetBlending(NormalBlending);\n\n}\n\nfunction initAttributes(){\n\nfor(var i=0,l=newAttributes.length;i<l;i++){\n\nnewAttributes[i]=0;\n\n}\n\n}\n\nfunction enableAttribute(attribute){\n\nnewAttributes[attribute]=1;\n\nif(enabledAttributes[attribute]===0){\n\ngl.enableVertexAttribArray(attribute);\nenabledAttributes[attribute]=1;\n\n}\n\nif(attributeDivisors[attribute]!==0){\n\nvar extension=extensions.get('ANGLE_instanced_arrays');\n\nextension.vertexAttribDivisorANGLE(attribute,0);\nattributeDivisors[attribute]=0;\n\n}\n\n}\n\nfunction enableAttributeAndDivisor(attribute,meshPerAttribute,extension){\n\nnewAttributes[attribute]=1;\n\nif(enabledAttributes[attribute]===0){\n\ngl.enableVertexAttribArray(attribute);\nenabledAttributes[attribute]=1;\n\n}\n\nif(attributeDivisors[attribute]!==meshPerAttribute){\n\nextension.vertexAttribDivisorANGLE(attribute,meshPerAttribute);\nattributeDivisors[attribute]=meshPerAttribute;\n\n}\n\n}\n\nfunction disableUnusedAttributes(){\n\nfor(var i=0,l=enabledAttributes.length;i!==l;++i){\n\nif(enabledAttributes[i]!==newAttributes[i]){\n\ngl.disableVertexAttribArray(i);\nenabledAttributes[i]=0;\n\n}\n\n}\n\n}\n\nfunction enable(id){\n\nif(capabilities[id]!==true){\n\ngl.enable(id);\ncapabilities[id]=true;\n\n}\n\n}\n\nfunction disable(id){\n\nif(capabilities[id]!==false){\n\ngl.disable(id);\ncapabilities[id]=false;\n\n}\n\n}\n\nfunction getCompressedTextureFormats(){\n\nif(compressedTextureFormats===null){\n\ncompressedTextureFormats=[];\n\nif(extensions.get('WEBGL_compressed_texture_pvrtc')||\nextensions.get('WEBGL_compressed_texture_s3tc')||\nextensions.get('WEBGL_compressed_texture_etc1')){\n\nvar formats=gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);\n\nfor(var i=0;i<formats.length;i++){\n\ncompressedTextureFormats.push(formats[i]);\n\n}\n\n}\n\n}\n\nreturn compressedTextureFormats;\n\n}\n\nfunction setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){\n\nif(blending!==NoBlending){\n\nenable(gl.BLEND);\n\n}else{\n\ndisable(gl.BLEND);\n\n}\n\nif(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){\n\nif(blending===AdditiveBlending){\n\nif(premultipliedAlpha){\n\ngl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);\ngl.blendFuncSeparate(gl.ONE,gl.ONE,gl.ONE,gl.ONE);\n\n}else{\n\ngl.blendEquation(gl.FUNC_ADD);\ngl.blendFunc(gl.SRC_ALPHA,gl.ONE);\n\n}\n\n}else if(blending===SubtractiveBlending){\n\nif(premultipliedAlpha){\n\ngl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);\ngl.blendFuncSeparate(gl.ZERO,gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ONE_MINUS_SRC_ALPHA);\n\n}else{\n\ngl.blendEquation(gl.FUNC_ADD);\ngl.blendFunc(gl.ZERO,gl.ONE_MINUS_SRC_COLOR);\n\n}\n\n}else if(blending===MultiplyBlending){\n\nif(premultipliedAlpha){\n\ngl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);\ngl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);\n\n}else{\n\ngl.blendEquation(gl.FUNC_ADD);\ngl.blendFunc(gl.ZERO,gl.SRC_COLOR);\n\n}\n\n}else{\n\nif(premultipliedAlpha){\n\ngl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);\ngl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);\n\n}else{\n\ngl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);\ngl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);\n\n}\n\n}\n\ncurrentBlending=blending;\ncurrentPremultipledAlpha=premultipliedAlpha;\n\n}\n\nif(blending===CustomBlending){\n\nblendEquationAlpha=blendEquationAlpha||blendEquation;\nblendSrcAlpha=blendSrcAlpha||blendSrc;\nblendDstAlpha=blendDstAlpha||blendDst;\n\nif(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){\n\ngl.blendEquationSeparate(paramThreeToGL(blendEquation),paramThreeToGL(blendEquationAlpha));\n\ncurrentBlendEquation=blendEquation;\ncurrentBlendEquationAlpha=blendEquationAlpha;\n\n}\n\nif(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){\n\ngl.blendFuncSeparate(paramThreeToGL(blendSrc),paramThreeToGL(blendDst),paramThreeToGL(blendSrcAlpha),paramThreeToGL(blendDstAlpha));\n\ncurrentBlendSrc=blendSrc;\ncurrentBlendDst=blendDst;\ncurrentBlendSrcAlpha=blendSrcAlpha;\ncurrentBlendDstAlpha=blendDstAlpha;\n\n}\n\n}else{\n\ncurrentBlendEquation=null;\ncurrentBlendSrc=null;\ncurrentBlendDst=null;\ncurrentBlendEquationAlpha=null;\ncurrentBlendSrcAlpha=null;\ncurrentBlendDstAlpha=null;\n\n}\n\n}\n\n// TODO Deprecate\n\nfunction setColorWrite(colorWrite){\n\ncolorBuffer.setMask(colorWrite);\n\n}\n\nfunction setDepthTest(depthTest){\n\ndepthBuffer.setTest(depthTest);\n\n}\n\nfunction setDepthWrite(depthWrite){\n\ndepthBuffer.setMask(depthWrite);\n\n}\n\nfunction setDepthFunc(depthFunc){\n\ndepthBuffer.setFunc(depthFunc);\n\n}\n\nfunction setStencilTest(stencilTest){\n\nstencilBuffer.setTest(stencilTest);\n\n}\n\nfunction setStencilWrite(stencilWrite){\n\nstencilBuffer.setMask(stencilWrite);\n\n}\n\nfunction setStencilFunc(stencilFunc,stencilRef,stencilMask){\n\nstencilBuffer.setFunc(stencilFunc,stencilRef,stencilMask);\n\n}\n\nfunction setStencilOp(stencilFail,stencilZFail,stencilZPass){\n\nstencilBuffer.setOp(stencilFail,stencilZFail,stencilZPass);\n\n}\n\n//\n\nfunction setFlipSided(flipSided){\n\nif(currentFlipSided!==flipSided){\n\nif(flipSided){\n\ngl.frontFace(gl.CW);\n\n}else{\n\ngl.frontFace(gl.CCW);\n\n}\n\ncurrentFlipSided=flipSided;\n\n}\n\n}\n\nfunction setCullFace(cullFace){\n\nif(cullFace!==CullFaceNone){\n\nenable(gl.CULL_FACE);\n\nif(cullFace!==currentCullFace){\n\nif(cullFace===CullFaceBack){\n\ngl.cullFace(gl.BACK);\n\n}else if(cullFace===CullFaceFront){\n\ngl.cullFace(gl.FRONT);\n\n}else{\n\ngl.cullFace(gl.FRONT_AND_BACK);\n\n}\n\n}\n\n}else{\n\ndisable(gl.CULL_FACE);\n\n}\n\ncurrentCullFace=cullFace;\n\n}\n\nfunction setLineWidth(width){\n\nif(width!==currentLineWidth){\n\nif(lineWidthAvailable)gl.lineWidth(width);\n\ncurrentLineWidth=width;\n\n}\n\n}\n\nfunction setPolygonOffset(polygonOffset,factor,units){\n\nif(polygonOffset){\n\nenable(gl.POLYGON_OFFSET_FILL);\n\nif(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){\n\ngl.polygonOffset(factor,units);\n\ncurrentPolygonOffsetFactor=factor;\ncurrentPolygonOffsetUnits=units;\n\n}\n\n}else{\n\ndisable(gl.POLYGON_OFFSET_FILL);\n\n}\n\n}\n\nfunction getScissorTest(){\n\nreturn currentScissorTest;\n\n}\n\nfunction setScissorTest(scissorTest){\n\ncurrentScissorTest=scissorTest;\n\nif(scissorTest){\n\nenable(gl.SCISSOR_TEST);\n\n}else{\n\ndisable(gl.SCISSOR_TEST);\n\n}\n\n}\n\n// texture\n\nfunction activeTexture(webglSlot){\n\nif(webglSlot===undefined)webglSlot=gl.TEXTURE0+maxTextures-1;\n\nif(currentTextureSlot!==webglSlot){\n\ngl.activeTexture(webglSlot);\ncurrentTextureSlot=webglSlot;\n\n}\n\n}\n\nfunction bindTexture(webglType,webglTexture){\n\nif(currentTextureSlot===null){\n\nactiveTexture();\n\n}\n\nvar boundTexture=currentBoundTextures[currentTextureSlot];\n\nif(boundTexture===undefined){\n\nboundTexture={type:undefined,texture:undefined};\ncurrentBoundTextures[currentTextureSlot]=boundTexture;\n\n}\n\nif(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){\n\ngl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);\n\nboundTexture.type=webglType;\nboundTexture.texture=webglTexture;\n\n}\n\n}\n\nfunction compressedTexImage2D(){\n\ntry{\n\ngl.compressedTexImage2D.apply(gl,arguments);\n\n}catch(error){\n\nconsole.error(error);\n\n}\n\n}\n\nfunction texImage2D(){\n\ntry{\n\ngl.texImage2D.apply(gl,arguments);\n\n}catch(error){\n\nconsole.error(error);\n\n}\n\n}\n\n//\n\nfunction scissor(scissor){\n\nif(currentScissor.equals(scissor)===false){\n\ngl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);\ncurrentScissor.copy(scissor);\n\n}\n\n}\n\nfunction viewport(viewport){\n\nif(currentViewport.equals(viewport)===false){\n\ngl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);\ncurrentViewport.copy(viewport);\n\n}\n\n}\n\n//\n\nfunction reset(){\n\nfor(var i=0;i<enabledAttributes.length;i++){\n\nif(enabledAttributes[i]===1){\n\ngl.disableVertexAttribArray(i);\nenabledAttributes[i]=0;\n\n}\n\n}\n\ncapabilities={};\n\ncompressedTextureFormats=null;\n\ncurrentTextureSlot=null;\ncurrentBoundTextures={};\n\ncurrentBlending=null;\n\ncurrentFlipSided=null;\ncurrentCullFace=null;\n\ncolorBuffer.reset();\ndepthBuffer.reset();\nstencilBuffer.reset();\n\n}\n\nreturn{\n\nbuffers:{\ncolor:colorBuffer,\ndepth:depthBuffer,\nstencil:stencilBuffer},\n\n\ninit:init,\ninitAttributes:initAttributes,\nenableAttribute:enableAttribute,\nenableAttributeAndDivisor:enableAttributeAndDivisor,\ndisableUnusedAttributes:disableUnusedAttributes,\nenable:enable,\ndisable:disable,\ngetCompressedTextureFormats:getCompressedTextureFormats,\n\nsetBlending:setBlending,\n\nsetColorWrite:setColorWrite,\nsetDepthTest:setDepthTest,\nsetDepthWrite:setDepthWrite,\nsetDepthFunc:setDepthFunc,\nsetStencilTest:setStencilTest,\nsetStencilWrite:setStencilWrite,\nsetStencilFunc:setStencilFunc,\nsetStencilOp:setStencilOp,\n\nsetFlipSided:setFlipSided,\nsetCullFace:setCullFace,\n\nsetLineWidth:setLineWidth,\nsetPolygonOffset:setPolygonOffset,\n\ngetScissorTest:getScissorTest,\nsetScissorTest:setScissorTest,\n\nactiveTexture:activeTexture,\nbindTexture:bindTexture,\ncompressedTexImage2D:compressedTexImage2D,\ntexImage2D:texImage2D,\n\nscissor:scissor,\nviewport:viewport,\n\nreset:reset};\n\n\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLCapabilities(gl,extensions,parameters){\n\nvar maxAnisotropy;\n\nfunction getMaxAnisotropy(){\n\nif(maxAnisotropy!==undefined)return maxAnisotropy;\n\nvar extension=extensions.get('EXT_texture_filter_anisotropic');\n\nif(extension!==null){\n\nmaxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\n}else{\n\nmaxAnisotropy=0;\n\n}\n\nreturn maxAnisotropy;\n\n}\n\nfunction getMaxPrecision(precision){\n\nif(precision==='highp'){\n\nif(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&\ngl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){\n\nreturn'highp';\n\n}\n\nprecision='mediump';\n\n}\n\nif(precision==='mediump'){\n\nif(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&\ngl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){\n\nreturn'mediump';\n\n}\n\n}\n\nreturn'lowp';\n\n}\n\nvar precision=parameters.precision!==undefined?parameters.precision:'highp';\nvar maxPrecision=getMaxPrecision(precision);\n\nif(maxPrecision!==precision){\n\nconsole.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');\nprecision=maxPrecision;\n\n}\n\nvar logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true&&!!extensions.get('EXT_frag_depth');\n\nvar maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\nvar maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\nvar maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);\nvar maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n\nvar maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\nvar maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\nvar maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS);\nvar maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\nvar vertexTextures=maxVertexTextures>0;\nvar floatFragmentTextures=!!extensions.get('OES_texture_float');\nvar floatVertexTextures=vertexTextures&&floatFragmentTextures;\n\nreturn{\n\ngetMaxAnisotropy:getMaxAnisotropy,\ngetMaxPrecision:getMaxPrecision,\n\nprecision:precision,\nlogarithmicDepthBuffer:logarithmicDepthBuffer,\n\nmaxTextures:maxTextures,\nmaxVertexTextures:maxVertexTextures,\nmaxTextureSize:maxTextureSize,\nmaxCubemapSize:maxCubemapSize,\n\nmaxAttributes:maxAttributes,\nmaxVertexUniforms:maxVertexUniforms,\nmaxVaryings:maxVaryings,\nmaxFragmentUniforms:maxFragmentUniforms,\n\nvertexTextures:vertexTextures,\nfloatFragmentTextures:floatFragmentTextures,\nfloatVertexTextures:floatVertexTextures};\n\n\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction WebGLExtensions(gl){\n\nvar extensions={};\n\nreturn{\n\nget:function get(name){\n\nif(extensions[name]!==undefined){\n\nreturn extensions[name];\n\n}\n\nvar extension;\n\nswitch(name){\n\ncase'WEBGL_depth_texture':\nextension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');\nbreak;\n\ncase'EXT_texture_filter_anisotropic':\nextension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\nbreak;\n\ncase'WEBGL_compressed_texture_s3tc':\nextension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\nbreak;\n\ncase'WEBGL_compressed_texture_pvrtc':\nextension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\nbreak;\n\ncase'WEBGL_compressed_texture_etc1':\nextension=gl.getExtension('WEBGL_compressed_texture_etc1');\nbreak;\n\ndefault:\nextension=gl.getExtension(name);}\n\n\n\nif(extension===null){\n\nconsole.warn('THREE.WebGLRenderer: '+name+' extension not supported.');\n\n}\n\nextensions[name]=extension;\n\nreturn extension;\n\n}};\n\n\n\n}\n\n/**\n\t * @author tschw\n\t */\n\nfunction WebGLClipping(){\n\nvar scope=this,\n\nglobalState=null,\nnumGlobalPlanes=0,\nlocalClippingEnabled=false,\nrenderingShadows=false,\n\nplane=new Plane(),\nviewNormalMatrix=new Matrix3(),\n\nuniform={value:null,needsUpdate:false};\n\nthis.uniform=uniform;\nthis.numPlanes=0;\nthis.numIntersection=0;\n\nthis.init=function(planes,enableLocalClipping,camera){\n\nvar enabled=\nplanes.length!==0||\nenableLocalClipping||\n// enable state of previous frame - the clipping code has to\n// run another frame in order to reset the state:\nnumGlobalPlanes!==0||\nlocalClippingEnabled;\n\nlocalClippingEnabled=enableLocalClipping;\n\nglobalState=projectPlanes(planes,camera,0);\nnumGlobalPlanes=planes.length;\n\nreturn enabled;\n\n};\n\nthis.beginShadows=function(){\n\nrenderingShadows=true;\nprojectPlanes(null);\n\n};\n\nthis.endShadows=function(){\n\nrenderingShadows=false;\nresetGlobalState();\n\n};\n\nthis.setState=function(planes,clipIntersection,clipShadows,camera,cache,fromCache){\n\nif(!localClippingEnabled||\nplanes===null||planes.length===0||\nrenderingShadows&&!clipShadows){\n// there's no local clipping\n\nif(renderingShadows){\n// there's no global clipping\n\nprojectPlanes(null);\n\n}else{\n\nresetGlobalState();\n}\n\n}else{\n\nvar nGlobal=renderingShadows?0:numGlobalPlanes,\nlGlobal=nGlobal*4,\n\ndstArray=cache.clippingState||null;\n\nuniform.value=dstArray;// ensure unique state\n\ndstArray=projectPlanes(planes,camera,lGlobal,fromCache);\n\nfor(var i=0;i!==lGlobal;++i){\n\ndstArray[i]=globalState[i];\n\n}\n\ncache.clippingState=dstArray;\nthis.numIntersection=clipIntersection?this.numPlanes:0;\nthis.numPlanes+=nGlobal;\n\n}\n\n\n};\n\nfunction resetGlobalState(){\n\nif(uniform.value!==globalState){\n\nuniform.value=globalState;\nuniform.needsUpdate=numGlobalPlanes>0;\n\n}\n\nscope.numPlanes=numGlobalPlanes;\nscope.numIntersection=0;\n\n}\n\nfunction projectPlanes(planes,camera,dstOffset,skipTransform){\n\nvar nPlanes=planes!==null?planes.length:0,\ndstArray=null;\n\nif(nPlanes!==0){\n\ndstArray=uniform.value;\n\nif(skipTransform!==true||dstArray===null){\n\nvar flatSize=dstOffset+nPlanes*4,\nviewMatrix=camera.matrixWorldInverse;\n\nviewNormalMatrix.getNormalMatrix(viewMatrix);\n\nif(dstArray===null||dstArray.length<flatSize){\n\ndstArray=new Float32Array(flatSize);\n\n}\n\nfor(var i=0,i4=dstOffset;\ni!==nPlanes;++i,i4+=4){\n\nplane.copy(planes[i]).\napplyMatrix4(viewMatrix,viewNormalMatrix);\n\nplane.normal.toArray(dstArray,i4);\ndstArray[i4+3]=plane.constant;\n\n}\n\n}\n\nuniform.value=dstArray;\nuniform.needsUpdate=true;\n\n}\n\nscope.numPlanes=nPlanes;\n\nreturn dstArray;\n\n}\n\n}\n\n/**\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author szimek / https://github.com/szimek/\n\t * @author tschw\n\t */\n\nfunction WebGLRenderer(parameters){\n\nconsole.log('THREE.WebGLRenderer',REVISION);\n\nparameters=parameters||{};\n\nvar _canvas=parameters.canvas!==undefined?parameters.canvas:document.createElementNS('http://www.w3.org/1999/xhtml','canvas'),\n_context=parameters.context!==undefined?parameters.context:null,\n\n_alpha=parameters.alpha!==undefined?parameters.alpha:false,\n_depth=parameters.depth!==undefined?parameters.depth:true,\n_stencil=parameters.stencil!==undefined?parameters.stencil:true,\n_antialias=parameters.antialias!==undefined?parameters.antialias:false,\n_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,\n_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false;\n\nvar lights=[];\n\nvar opaqueObjects=[];\nvar opaqueObjectsLastIndex=-1;\nvar transparentObjects=[];\nvar transparentObjectsLastIndex=-1;\n\nvar morphInfluences=new Float32Array(8);\n\nvar sprites=[];\nvar lensFlares=[];\n\n// public properties\n\nthis.domElement=_canvas;\nthis.context=null;\n\n// clearing\n\nthis.autoClear=true;\nthis.autoClearColor=true;\nthis.autoClearDepth=true;\nthis.autoClearStencil=true;\n\n// scene graph\n\nthis.sortObjects=true;\n\n// user-defined clipping\n\nthis.clippingPlanes=[];\nthis.localClippingEnabled=false;\n\n// physically based shading\n\nthis.gammaFactor=2.0;// for backwards compatibility\nthis.gammaInput=false;\nthis.gammaOutput=false;\n\n// physical lights\n\nthis.physicallyCorrectLights=false;\n\n// tone mapping\n\nthis.toneMapping=LinearToneMapping;\nthis.toneMappingExposure=1.0;\nthis.toneMappingWhitePoint=1.0;\n\n// morphs\n\nthis.maxMorphTargets=8;\nthis.maxMorphNormals=4;\n\n// internal properties\n\nvar _this=this,\n\n// internal state cache\n\n_currentProgram=null,\n_currentRenderTarget=null,\n_currentFramebuffer=null,\n_currentMaterialId=-1,\n_currentGeometryProgram='',\n_currentCamera=null,\n\n_currentScissor=new Vector4(),\n_currentScissorTest=null,\n\n_currentViewport=new Vector4(),\n\n//\n\n_usedTextureUnits=0,\n\n//\n\n_clearColor=new Color(0x000000),\n_clearAlpha=0,\n\n_width=_canvas.width,\n_height=_canvas.height,\n\n_pixelRatio=1,\n\n_scissor=new Vector4(0,0,_width,_height),\n_scissorTest=false,\n\n_viewport=new Vector4(0,0,_width,_height),\n\n// frustum\n\n_frustum=new Frustum(),\n\n// clipping\n\n_clipping=new WebGLClipping(),\n_clippingEnabled=false,\n_localClippingEnabled=false,\n\n_sphere=new Sphere(),\n\n// camera matrices cache\n\n_projScreenMatrix=new Matrix4(),\n\n_vector3=new Vector3(),\n_matrix4=new Matrix4(),\n_matrix42=new Matrix4(),\n\n// light arrays cache\n\n_lights={\n\nhash:'',\n\nambient:[0,0,0],\ndirectional:[],\ndirectionalShadowMap:[],\ndirectionalShadowMatrix:[],\nspot:[],\nspotShadowMap:[],\nspotShadowMatrix:[],\nrectArea:[],\npoint:[],\npointShadowMap:[],\npointShadowMatrix:[],\nhemi:[],\n\nshadows:[]},\n\n\n\n// info\n\n_infoRender={\n\ncalls:0,\nvertices:0,\nfaces:0,\npoints:0};\n\n\n\nthis.info={\n\nrender:_infoRender,\nmemory:{\n\ngeometries:0,\ntextures:0},\n\n\nprograms:null};\n\n\n\n\n// initialize\n\nvar _gl;\n\ntry{\n\nvar attributes={\nalpha:_alpha,\ndepth:_depth,\nstencil:_stencil,\nantialias:_antialias,\npremultipliedAlpha:_premultipliedAlpha,\npreserveDrawingBuffer:_preserveDrawingBuffer};\n\n\n_gl=_context||_canvas.getContext('webgl',attributes)||_canvas.getContext('experimental-webgl',attributes);\n\nif(_gl===null){\n\nif(_canvas.getContext('webgl')!==null){\n\nthrow'Error creating WebGL context with your selected attributes.';\n\n}else{\n\nthrow'Error creating WebGL context.';\n\n}\n\n}\n\n// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\nif(_gl.getShaderPrecisionFormat===undefined){\n\n_gl.getShaderPrecisionFormat=function(){\n\nreturn{'rangeMin':1,'rangeMax':1,'precision':1};\n\n};\n\n}\n\n_canvas.addEventListener('webglcontextlost',onContextLost,false);\n\n}catch(error){\n\nconsole.error('THREE.WebGLRenderer: '+error);\n\n}\n\nvar extensions=new WebGLExtensions(_gl);\n\nextensions.get('WEBGL_depth_texture');\nextensions.get('OES_texture_float');\nextensions.get('OES_texture_float_linear');\nextensions.get('OES_texture_half_float');\nextensions.get('OES_texture_half_float_linear');\nextensions.get('OES_standard_derivatives');\nextensions.get('ANGLE_instanced_arrays');\n\nif(extensions.get('OES_element_index_uint')){\n\nBufferGeometry.MaxIndex=4294967296;\n\n}\n\nvar capabilities=new WebGLCapabilities(_gl,extensions,parameters);\n\nvar state=new WebGLState(_gl,extensions,paramThreeToGL);\nvar properties=new WebGLProperties();\nvar textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,paramThreeToGL,this.info);\nvar objects=new WebGLObjects(_gl,properties,this.info);\nvar programCache=new WebGLPrograms(this,capabilities);\nvar lightCache=new WebGLLights();\n\nthis.info.programs=programCache.programs;\n\nvar bufferRenderer=new WebGLBufferRenderer(_gl,extensions,_infoRender);\nvar indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,_infoRender);\n\n//\n\nvar backgroundPlaneCamera,backgroundPlaneMesh;\nvar backgroundBoxCamera,backgroundBoxMesh;\n\n//\n\nfunction getTargetPixelRatio(){\n\nreturn _currentRenderTarget===null?_pixelRatio:1;\n\n}\n\nfunction setDefaultGLState(){\n\nstate.init();\n\nstate.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));\nstate.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));\n\nstate.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);\n\n}\n\nfunction resetGLState(){\n\n_currentProgram=null;\n_currentCamera=null;\n\n_currentGeometryProgram='';\n_currentMaterialId=-1;\n\nstate.reset();\n\n}\n\nsetDefaultGLState();\n\nthis.context=_gl;\nthis.capabilities=capabilities;\nthis.extensions=extensions;\nthis.properties=properties;\nthis.state=state;\n\n// shadow map\n\nvar shadowMap=new WebGLShadowMap(this,_lights,objects,capabilities);\n\nthis.shadowMap=shadowMap;\n\n\n// Plugins\n\nvar spritePlugin=new SpritePlugin(this,sprites);\nvar lensFlarePlugin=new LensFlarePlugin(this,lensFlares);\n\n// API\n\nthis.getContext=function(){\n\nreturn _gl;\n\n};\n\nthis.getContextAttributes=function(){\n\nreturn _gl.getContextAttributes();\n\n};\n\nthis.forceContextLoss=function(){\n\nextensions.get('WEBGL_lose_context').loseContext();\n\n};\n\nthis.getMaxAnisotropy=function(){\n\nreturn capabilities.getMaxAnisotropy();\n\n};\n\nthis.getPrecision=function(){\n\nreturn capabilities.precision;\n\n};\n\nthis.getPixelRatio=function(){\n\nreturn _pixelRatio;\n\n};\n\nthis.setPixelRatio=function(value){\n\nif(value===undefined)return;\n\n_pixelRatio=value;\n\nthis.setSize(_viewport.z,_viewport.w,false);\n\n};\n\nthis.getSize=function(){\n\nreturn{\nwidth:_width,\nheight:_height};\n\n\n};\n\nthis.setSize=function(width,height,updateStyle){\n\n_width=width;\n_height=height;\n\n_canvas.width=width*_pixelRatio;\n_canvas.height=height*_pixelRatio;\n\nif(updateStyle!==false){\n\n_canvas.style.width=width+'px';\n_canvas.style.height=height+'px';\n\n}\n\nthis.setViewport(0,0,width,height);\n\n};\n\nthis.setViewport=function(x,y,width,height){\n\nstate.viewport(_viewport.set(x,y,width,height));\n\n};\n\nthis.setScissor=function(x,y,width,height){\n\nstate.scissor(_scissor.set(x,y,width,height));\n\n};\n\nthis.setScissorTest=function(boolean){\n\nstate.setScissorTest(_scissorTest=boolean);\n\n};\n\n// Clearing\n\nthis.getClearColor=function(){\n\nreturn _clearColor;\n\n};\n\nthis.setClearColor=function(color,alpha){\n\n_clearColor.set(color);\n\n_clearAlpha=alpha!==undefined?alpha:1;\n\nstate.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);\n\n};\n\nthis.getClearAlpha=function(){\n\nreturn _clearAlpha;\n\n};\n\nthis.setClearAlpha=function(alpha){\n\n_clearAlpha=alpha;\n\nstate.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);\n\n};\n\nthis.clear=function(color,depth,stencil){\n\nvar bits=0;\n\nif(color===undefined||color)bits|=_gl.COLOR_BUFFER_BIT;\nif(depth===undefined||depth)bits|=_gl.DEPTH_BUFFER_BIT;\nif(stencil===undefined||stencil)bits|=_gl.STENCIL_BUFFER_BIT;\n\n_gl.clear(bits);\n\n};\n\nthis.clearColor=function(){\n\nthis.clear(true,false,false);\n\n};\n\nthis.clearDepth=function(){\n\nthis.clear(false,true,false);\n\n};\n\nthis.clearStencil=function(){\n\nthis.clear(false,false,true);\n\n};\n\nthis.clearTarget=function(renderTarget,color,depth,stencil){\n\nthis.setRenderTarget(renderTarget);\nthis.clear(color,depth,stencil);\n\n};\n\n// Reset\n\nthis.resetGLState=resetGLState;\n\nthis.dispose=function(){\n\ntransparentObjects=[];\ntransparentObjectsLastIndex=-1;\nopaqueObjects=[];\nopaqueObjectsLastIndex=-1;\n\n_canvas.removeEventListener('webglcontextlost',onContextLost,false);\n\n};\n\n// Events\n\nfunction onContextLost(event){\n\nevent.preventDefault();\n\nresetGLState();\nsetDefaultGLState();\n\nproperties.clear();\n\n}\n\nfunction onMaterialDispose(event){\n\nvar material=event.target;\n\nmaterial.removeEventListener('dispose',onMaterialDispose);\n\ndeallocateMaterial(material);\n\n}\n\n// Buffer deallocation\n\nfunction deallocateMaterial(material){\n\nreleaseMaterialProgramReference(material);\n\nproperties.delete(material);\n\n}\n\n\nfunction releaseMaterialProgramReference(material){\n\nvar programInfo=properties.get(material).program;\n\nmaterial.program=undefined;\n\nif(programInfo!==undefined){\n\nprogramCache.releaseProgram(programInfo);\n\n}\n\n}\n\n// Buffer rendering\n\nthis.renderBufferImmediate=function(object,program,material){\n\nstate.initAttributes();\n\nvar buffers=properties.get(object);\n\nif(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();\nif(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();\nif(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();\nif(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();\n\nvar attributes=program.getAttributes();\n\nif(object.hasPositions){\n\n_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.position);\n_gl.bufferData(_gl.ARRAY_BUFFER,object.positionArray,_gl.DYNAMIC_DRAW);\n\nstate.enableAttribute(attributes.position);\n_gl.vertexAttribPointer(attributes.position,3,_gl.FLOAT,false,0,0);\n\n}\n\nif(object.hasNormals){\n\n_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.normal);\n\nif(!material.isMeshPhongMaterial&&\n!material.isMeshStandardMaterial&&\n!material.isMeshNormalMaterial&&\nmaterial.shading===FlatShading){\n\nfor(var i=0,l=object.count*3;i<l;i+=9){\n\nvar array=object.normalArray;\n\nvar nx=(array[i+0]+array[i+3]+array[i+6])/3;\nvar ny=(array[i+1]+array[i+4]+array[i+7])/3;\nvar nz=(array[i+2]+array[i+5]+array[i+8])/3;\n\narray[i+0]=nx;\narray[i+1]=ny;\narray[i+2]=nz;\n\narray[i+3]=nx;\narray[i+4]=ny;\narray[i+5]=nz;\n\narray[i+6]=nx;\narray[i+7]=ny;\narray[i+8]=nz;\n\n}\n\n}\n\n_gl.bufferData(_gl.ARRAY_BUFFER,object.normalArray,_gl.DYNAMIC_DRAW);\n\nstate.enableAttribute(attributes.normal);\n\n_gl.vertexAttribPointer(attributes.normal,3,_gl.FLOAT,false,0,0);\n\n}\n\nif(object.hasUvs&&material.map){\n\n_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.uv);\n_gl.bufferData(_gl.ARRAY_BUFFER,object.uvArray,_gl.DYNAMIC_DRAW);\n\nstate.enableAttribute(attributes.uv);\n\n_gl.vertexAttribPointer(attributes.uv,2,_gl.FLOAT,false,0,0);\n\n}\n\nif(object.hasColors&&material.vertexColors!==NoColors){\n\n_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.color);\n_gl.bufferData(_gl.ARRAY_BUFFER,object.colorArray,_gl.DYNAMIC_DRAW);\n\nstate.enableAttribute(attributes.color);\n\n_gl.vertexAttribPointer(attributes.color,3,_gl.FLOAT,false,0,0);\n\n}\n\nstate.disableUnusedAttributes();\n\n_gl.drawArrays(_gl.TRIANGLES,0,object.count);\n\nobject.count=0;\n\n};\n\nthis.renderBufferDirect=function(camera,fog,geometry,material,object,group){\n\nsetMaterial(material);\n\nvar program=setProgram(camera,fog,material,object);\n\nvar updateBuffers=false;\nvar geometryProgram=geometry.id+'_'+program.id+'_'+material.wireframe;\n\nif(geometryProgram!==_currentGeometryProgram){\n\n_currentGeometryProgram=geometryProgram;\nupdateBuffers=true;\n\n}\n\n// morph targets\n\nvar morphTargetInfluences=object.morphTargetInfluences;\n\nif(morphTargetInfluences!==undefined){\n\nvar activeInfluences=[];\n\nfor(var i=0,l=morphTargetInfluences.length;i<l;i++){\n\nvar influence=morphTargetInfluences[i];\nactiveInfluences.push([influence,i]);\n\n}\n\nactiveInfluences.sort(absNumericalSort);\n\nif(activeInfluences.length>8){\n\nactiveInfluences.length=8;\n\n}\n\nvar morphAttributes=geometry.morphAttributes;\n\nfor(var i=0,l=activeInfluences.length;i<l;i++){\n\nvar influence=activeInfluences[i];\nmorphInfluences[i]=influence[0];\n\nif(influence[0]!==0){\n\nvar index=influence[1];\n\nif(material.morphTargets===true&&morphAttributes.position)geometry.addAttribute('morphTarget'+i,morphAttributes.position[index]);\nif(material.morphNormals===true&&morphAttributes.normal)geometry.addAttribute('morphNormal'+i,morphAttributes.normal[index]);\n\n}else{\n\nif(material.morphTargets===true)geometry.removeAttribute('morphTarget'+i);\nif(material.morphNormals===true)geometry.removeAttribute('morphNormal'+i);\n\n}\n\n}\n\nfor(var i=activeInfluences.length,il=morphInfluences.length;i<il;i++){\n\nmorphInfluences[i]=0.0;\n\n}\n\nprogram.getUniforms().setValue(\n_gl,'morphTargetInfluences',morphInfluences);\n\nupdateBuffers=true;\n\n}\n\n//\n\nvar index=geometry.index;\nvar position=geometry.attributes.position;\nvar rangeFactor=1;\n\nif(material.wireframe===true){\n\nindex=objects.getWireframeAttribute(geometry);\nrangeFactor=2;\n\n}\n\nvar renderer;\n\nif(index!==null){\n\nrenderer=indexedBufferRenderer;\nrenderer.setIndex(index);\n\n}else{\n\nrenderer=bufferRenderer;\n\n}\n\nif(updateBuffers){\n\nsetupVertexAttributes(material,program,geometry);\n\nif(index!==null){\n\n_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,objects.getAttributeBuffer(index));\n\n}\n\n}\n\n//\n\nvar dataCount=0;\n\nif(index!==null){\n\ndataCount=index.count;\n\n}else if(position!==undefined){\n\ndataCount=position.count;\n\n}\n\nvar rangeStart=geometry.drawRange.start*rangeFactor;\nvar rangeCount=geometry.drawRange.count*rangeFactor;\n\nvar groupStart=group!==null?group.start*rangeFactor:0;\nvar groupCount=group!==null?group.count*rangeFactor:Infinity;\n\nvar drawStart=Math.max(rangeStart,groupStart);\nvar drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;\n\nvar drawCount=Math.max(0,drawEnd-drawStart+1);\n\nif(drawCount===0)return;\n\n//\n\nif(object.isMesh){\n\nif(material.wireframe===true){\n\nstate.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());\nrenderer.setMode(_gl.LINES);\n\n}else{\n\nswitch(object.drawMode){\n\ncase TrianglesDrawMode:\nrenderer.setMode(_gl.TRIANGLES);\nbreak;\n\ncase TriangleStripDrawMode:\nrenderer.setMode(_gl.TRIANGLE_STRIP);\nbreak;\n\ncase TriangleFanDrawMode:\nrenderer.setMode(_gl.TRIANGLE_FAN);\nbreak;}\n\n\n\n}\n\n\n}else if(object.isLine){\n\nvar lineWidth=material.linewidth;\n\nif(lineWidth===undefined)lineWidth=1;// Not using Line*Material\n\nstate.setLineWidth(lineWidth*getTargetPixelRatio());\n\nif(object.isLineSegments){\n\nrenderer.setMode(_gl.LINES);\n\n}else{\n\nrenderer.setMode(_gl.LINE_STRIP);\n\n}\n\n}else if(object.isPoints){\n\nrenderer.setMode(_gl.POINTS);\n\n}\n\nif(geometry&&geometry.isInstancedBufferGeometry){\n\nif(geometry.maxInstancedCount>0){\n\nrenderer.renderInstances(geometry,drawStart,drawCount);\n\n}\n\n}else{\n\nrenderer.render(drawStart,drawCount);\n\n}\n\n};\n\nfunction setupVertexAttributes(material,program,geometry,startIndex){\n\nvar extension;\n\nif(geometry&&geometry.isInstancedBufferGeometry){\n\nextension=extensions.get('ANGLE_instanced_arrays');\n\nif(extension===null){\n\nconsole.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\nreturn;\n\n}\n\n}\n\nif(startIndex===undefined)startIndex=0;\n\nstate.initAttributes();\n\nvar geometryAttributes=geometry.attributes;\n\nvar programAttributes=program.getAttributes();\n\nvar materialDefaultAttributeValues=material.defaultAttributeValues;\n\nfor(var name in programAttributes){\n\nvar programAttribute=programAttributes[name];\n\nif(programAttribute>=0){\n\nvar geometryAttribute=geometryAttributes[name];\n\nif(geometryAttribute!==undefined){\n\nvar normalized=geometryAttribute.normalized;\nvar size=geometryAttribute.itemSize;\n\nvar attributeProperties=objects.getAttributeProperties(geometryAttribute);\n\nvar buffer=attributeProperties.__webglBuffer;\nvar type=attributeProperties.type;\nvar bytesPerElement=attributeProperties.bytesPerElement;\n\nif(geometryAttribute.isInterleavedBufferAttribute){\n\nvar data=geometryAttribute.data;\nvar stride=data.stride;\nvar offset=geometryAttribute.offset;\n\nif(data&&data.isInstancedInterleavedBuffer){\n\nstate.enableAttributeAndDivisor(programAttribute,data.meshPerAttribute,extension);\n\nif(geometry.maxInstancedCount===undefined){\n\ngeometry.maxInstancedCount=data.meshPerAttribute*data.count;\n\n}\n\n}else{\n\nstate.enableAttribute(programAttribute);\n\n}\n\n_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);\n_gl.vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,(startIndex*stride+offset)*bytesPerElement);\n\n}else{\n\nif(geometryAttribute.isInstancedBufferAttribute){\n\nstate.enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute,extension);\n\nif(geometry.maxInstancedCount===undefined){\n\ngeometry.maxInstancedCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;\n\n}\n\n}else{\n\nstate.enableAttribute(programAttribute);\n\n}\n\n_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);\n_gl.vertexAttribPointer(programAttribute,size,type,normalized,0,startIndex*size*bytesPerElement);\n\n}\n\n}else if(materialDefaultAttributeValues!==undefined){\n\nvar value=materialDefaultAttributeValues[name];\n\nif(value!==undefined){\n\nswitch(value.length){\n\ncase 2:\n_gl.vertexAttrib2fv(programAttribute,value);\nbreak;\n\ncase 3:\n_gl.vertexAttrib3fv(programAttribute,value);\nbreak;\n\ncase 4:\n_gl.vertexAttrib4fv(programAttribute,value);\nbreak;\n\ndefault:\n_gl.vertexAttrib1fv(programAttribute,value);}\n\n\n\n}\n\n}\n\n}\n\n}\n\nstate.disableUnusedAttributes();\n\n}\n\n// Sorting\n\nfunction absNumericalSort(a,b){\n\nreturn Math.abs(b[0])-Math.abs(a[0]);\n\n}\n\nfunction painterSortStable(a,b){\n\nif(a.object.renderOrder!==b.object.renderOrder){\n\nreturn a.object.renderOrder-b.object.renderOrder;\n\n}else if(a.material.program&&b.material.program&&a.material.program!==b.material.program){\n\nreturn a.material.program.id-b.material.program.id;\n\n}else if(a.material.id!==b.material.id){\n\nreturn a.material.id-b.material.id;\n\n}else if(a.z!==b.z){\n\nreturn a.z-b.z;\n\n}else{\n\nreturn a.id-b.id;\n\n}\n\n}\n\nfunction reversePainterSortStable(a,b){\n\nif(a.object.renderOrder!==b.object.renderOrder){\n\nreturn a.object.renderOrder-b.object.renderOrder;\n\n}if(a.z!==b.z){\n\nreturn b.z-a.z;\n\n}else{\n\nreturn a.id-b.id;\n\n}\n\n}\n\n// Rendering\n\nthis.render=function(scene,camera,renderTarget,forceClear){\n\nif(camera!==undefined&&camera.isCamera!==true){\n\nconsole.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\nreturn;\n\n}\n\n// reset caching for this frame\n\n_currentGeometryProgram='';\n_currentMaterialId=-1;\n_currentCamera=null;\n\n// update scene graph\n\nif(scene.autoUpdate===true)scene.updateMatrixWorld();\n\n// update camera matrices and frustum\n\nif(camera.parent===null)camera.updateMatrixWorld();\n\ncamera.matrixWorldInverse.getInverse(camera.matrixWorld);\n\n_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);\n_frustum.setFromMatrix(_projScreenMatrix);\n\nlights.length=0;\n\nopaqueObjectsLastIndex=-1;\ntransparentObjectsLastIndex=-1;\n\nsprites.length=0;\nlensFlares.length=0;\n\n_localClippingEnabled=this.localClippingEnabled;\n_clippingEnabled=_clipping.init(this.clippingPlanes,_localClippingEnabled,camera);\n\nprojectObject(scene,camera);\n\nopaqueObjects.length=opaqueObjectsLastIndex+1;\ntransparentObjects.length=transparentObjectsLastIndex+1;\n\nif(_this.sortObjects===true){\n\nopaqueObjects.sort(painterSortStable);\ntransparentObjects.sort(reversePainterSortStable);\n\n}\n\n//\n\nif(_clippingEnabled)_clipping.beginShadows();\n\nsetupShadows(lights);\n\nshadowMap.render(scene,camera);\n\nsetupLights(lights,camera);\n\nif(_clippingEnabled)_clipping.endShadows();\n\n//\n\n_infoRender.calls=0;\n_infoRender.vertices=0;\n_infoRender.faces=0;\n_infoRender.points=0;\n\nif(renderTarget===undefined){\n\nrenderTarget=null;\n\n}\n\nthis.setRenderTarget(renderTarget);\n\n//\n\nvar background=scene.background;\n\nif(background===null){\n\nstate.buffers.color.setClear(_clearColor.r,_clearColor.g,_clearColor.b,_clearAlpha,_premultipliedAlpha);\n\n}else if(background&&background.isColor){\n\nstate.buffers.color.setClear(background.r,background.g,background.b,1,_premultipliedAlpha);\nforceClear=true;\n\n}\n\nif(this.autoClear||forceClear){\n\nthis.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);\n\n}\n\nif(background&&background.isCubeTexture){\n\nif(backgroundBoxCamera===undefined){\n\nbackgroundBoxCamera=new PerspectiveCamera();\n\nbackgroundBoxMesh=new Mesh(\nnew BoxBufferGeometry(5,5,5),\nnew ShaderMaterial({\nuniforms:ShaderLib.cube.uniforms,\nvertexShader:ShaderLib.cube.vertexShader,\nfragmentShader:ShaderLib.cube.fragmentShader,\nside:BackSide,\ndepthTest:false,\ndepthWrite:false,\nfog:false}));\n\n\n\n}\n\nbackgroundBoxCamera.projectionMatrix.copy(camera.projectionMatrix);\n\nbackgroundBoxCamera.matrixWorld.extractRotation(camera.matrixWorld);\nbackgroundBoxCamera.matrixWorldInverse.getInverse(backgroundBoxCamera.matrixWorld);\n\n\nbackgroundBoxMesh.material.uniforms[\"tCube\"].value=background;\nbackgroundBoxMesh.modelViewMatrix.multiplyMatrices(backgroundBoxCamera.matrixWorldInverse,backgroundBoxMesh.matrixWorld);\n\nobjects.update(backgroundBoxMesh);\n\n_this.renderBufferDirect(backgroundBoxCamera,null,backgroundBoxMesh.geometry,backgroundBoxMesh.material,backgroundBoxMesh,null);\n\n}else if(background&&background.isTexture){\n\nif(backgroundPlaneCamera===undefined){\n\nbackgroundPlaneCamera=new OrthographicCamera(-1,1,1,-1,0,1);\n\nbackgroundPlaneMesh=new Mesh(\nnew PlaneBufferGeometry(2,2),\nnew MeshBasicMaterial({depthTest:false,depthWrite:false,fog:false}));\n\n\n}\n\nbackgroundPlaneMesh.material.map=background;\n\nobjects.update(backgroundPlaneMesh);\n\n_this.renderBufferDirect(backgroundPlaneCamera,null,backgroundPlaneMesh.geometry,backgroundPlaneMesh.material,backgroundPlaneMesh,null);\n\n}\n\n//\n\nif(scene.overrideMaterial){\n\nvar overrideMaterial=scene.overrideMaterial;\n\nrenderObjects(opaqueObjects,scene,camera,overrideMaterial);\nrenderObjects(transparentObjects,scene,camera,overrideMaterial);\n\n}else{\n\n// opaque pass (front-to-back order)\n\nstate.setBlending(NoBlending);\nrenderObjects(opaqueObjects,scene,camera);\n\n// transparent pass (back-to-front order)\n\nrenderObjects(transparentObjects,scene,camera);\n\n}\n\n// custom render plugins (post pass)\n\nspritePlugin.render(scene,camera);\nlensFlarePlugin.render(scene,camera,_currentViewport);\n\n// Generate mipmap if we're using any kind of mipmap filtering\n\nif(renderTarget){\n\ntextures.updateRenderTargetMipmap(renderTarget);\n\n}\n\n// Ensure depth buffer writing is enabled so it can be cleared on next render\n\nstate.setDepthTest(true);\nstate.setDepthWrite(true);\nstate.setColorWrite(true);\n\n// _gl.finish();\n\n};\n\nfunction pushRenderItem(object,geometry,material,z,group){\n\nvar array,index;\n\n// allocate the next position in the appropriate array\n\nif(material.transparent){\n\narray=transparentObjects;\nindex=++transparentObjectsLastIndex;\n\n}else{\n\narray=opaqueObjects;\nindex=++opaqueObjectsLastIndex;\n\n}\n\n// recycle existing render item or grow the array\n\nvar renderItem=array[index];\n\nif(renderItem!==undefined){\n\nrenderItem.id=object.id;\nrenderItem.object=object;\nrenderItem.geometry=geometry;\nrenderItem.material=material;\nrenderItem.z=_vector3.z;\nrenderItem.group=group;\n\n}else{\n\nrenderItem={\nid:object.id,\nobject:object,\ngeometry:geometry,\nmaterial:material,\nz:_vector3.z,\ngroup:group};\n\n\n// assert( index === array.length );\narray.push(renderItem);\n\n}\n\n}\n\n// TODO Duplicated code (Frustum)\n\nfunction isObjectViewable(object){\n\nvar geometry=object.geometry;\n\nif(geometry.boundingSphere===null)\ngeometry.computeBoundingSphere();\n\n_sphere.copy(geometry.boundingSphere).\napplyMatrix4(object.matrixWorld);\n\nreturn isSphereViewable(_sphere);\n\n}\n\nfunction isSpriteViewable(sprite){\n\n_sphere.center.set(0,0,0);\n_sphere.radius=0.7071067811865476;\n_sphere.applyMatrix4(sprite.matrixWorld);\n\nreturn isSphereViewable(_sphere);\n\n}\n\nfunction isSphereViewable(sphere){\n\nif(!_frustum.intersectsSphere(sphere))return false;\n\nvar numPlanes=_clipping.numPlanes;\n\nif(numPlanes===0)return true;\n\nvar planes=_this.clippingPlanes,\n\ncenter=sphere.center,\nnegRad=-sphere.radius,\ni=0;\n\ndo{\n\n// out when deeper than radius in the negative halfspace\nif(planes[i].distanceToPoint(center)<negRad)return false;\n\n}while(++i!==numPlanes);\n\nreturn true;\n\n}\n\nfunction projectObject(object,camera){\n\nif(object.visible===false)return;\n\nvar visible=(object.layers.mask&camera.layers.mask)!==0;\n\nif(visible){\n\nif(object.isLight){\n\nlights.push(object);\n\n}else if(object.isSprite){\n\nif(object.frustumCulled===false||isSpriteViewable(object)===true){\n\nsprites.push(object);\n\n}\n\n}else if(object.isLensFlare){\n\nlensFlares.push(object);\n\n}else if(object.isImmediateRenderObject){\n\nif(_this.sortObjects===true){\n\n_vector3.setFromMatrixPosition(object.matrixWorld);\n_vector3.applyMatrix4(_projScreenMatrix);\n\n}\n\npushRenderItem(object,null,object.material,_vector3.z,null);\n\n}else if(object.isMesh||object.isLine||object.isPoints){\n\nif(object.isSkinnedMesh){\n\nobject.skeleton.update();\n\n}\n\nif(object.frustumCulled===false||isObjectViewable(object)===true){\n\nvar material=object.material;\n\nif(material.visible===true){\n\nif(_this.sortObjects===true){\n\n_vector3.setFromMatrixPosition(object.matrixWorld);\n_vector3.applyMatrix4(_projScreenMatrix);\n\n}\n\nvar geometry=objects.update(object);\n\nif(material.isMultiMaterial){\n\nvar groups=geometry.groups;\nvar materials=material.materials;\n\nfor(var i=0,l=groups.length;i<l;i++){\n\nvar group=groups[i];\nvar groupMaterial=materials[group.materialIndex];\n\nif(groupMaterial.visible===true){\n\npushRenderItem(object,geometry,groupMaterial,_vector3.z,group);\n\n}\n\n}\n\n}else{\n\npushRenderItem(object,geometry,material,_vector3.z,null);\n\n}\n\n}\n\n}\n\n}\n\n}\n\nvar children=object.children;\n\nfor(var i=0,l=children.length;i<l;i++){\n\nprojectObject(children[i],camera);\n\n}\n\n}\n\nfunction renderObjects(renderList,scene,camera,overrideMaterial){\n\nfor(var i=0,l=renderList.length;i<l;i++){\n\nvar renderItem=renderList[i];\n\nvar object=renderItem.object;\nvar geometry=renderItem.geometry;\nvar material=overrideMaterial===undefined?renderItem.material:overrideMaterial;\nvar group=renderItem.group;\n\nobject.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);\nobject.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n\nobject.onBeforeRender(_this,scene,camera,geometry,material,group);\n\nif(object.isImmediateRenderObject){\n\nsetMaterial(material);\n\nvar program=setProgram(camera,scene.fog,material,object);\n\n_currentGeometryProgram='';\n\nobject.render(function(object){\n\n_this.renderBufferImmediate(object,program,material);\n\n});\n\n}else{\n\n_this.renderBufferDirect(camera,scene.fog,geometry,material,object,group);\n\n}\n\nobject.onAfterRender(_this,scene,camera,geometry,material,group);\n\n\n}\n\n}\n\nfunction initMaterial(material,fog,object){\n\nvar materialProperties=properties.get(material);\n\nvar parameters=programCache.getParameters(\nmaterial,_lights,fog,_clipping.numPlanes,_clipping.numIntersection,object);\n\nvar code=programCache.getProgramCode(material,parameters);\n\nvar program=materialProperties.program;\nvar programChange=true;\n\nif(program===undefined){\n\n// new material\nmaterial.addEventListener('dispose',onMaterialDispose);\n\n}else if(program.code!==code){\n\n// changed glsl or parameters\nreleaseMaterialProgramReference(material);\n\n}else if(parameters.shaderID!==undefined){\n\n// same glsl and uniform list\nreturn;\n\n}else{\n\n// only rebuild uniform list\nprogramChange=false;\n\n}\n\nif(programChange){\n\nif(parameters.shaderID){\n\nvar shader=ShaderLib[parameters.shaderID];\n\nmaterialProperties.__webglShader={\nname:material.type,\nuniforms:UniformsUtils.clone(shader.uniforms),\nvertexShader:shader.vertexShader,\nfragmentShader:shader.fragmentShader};\n\n\n}else{\n\nmaterialProperties.__webglShader={\nname:material.type,\nuniforms:material.uniforms,\nvertexShader:material.vertexShader,\nfragmentShader:material.fragmentShader};\n\n\n}\n\nmaterial.__webglShader=materialProperties.__webglShader;\n\nprogram=programCache.acquireProgram(material,parameters,code);\n\nmaterialProperties.program=program;\nmaterial.program=program;\n\n}\n\nvar attributes=program.getAttributes();\n\nif(material.morphTargets){\n\nmaterial.numSupportedMorphTargets=0;\n\nfor(var i=0;i<_this.maxMorphTargets;i++){\n\nif(attributes['morphTarget'+i]>=0){\n\nmaterial.numSupportedMorphTargets++;\n\n}\n\n}\n\n}\n\nif(material.morphNormals){\n\nmaterial.numSupportedMorphNormals=0;\n\nfor(var i=0;i<_this.maxMorphNormals;i++){\n\nif(attributes['morphNormal'+i]>=0){\n\nmaterial.numSupportedMorphNormals++;\n\n}\n\n}\n\n}\n\nvar uniforms=materialProperties.__webglShader.uniforms;\n\nif(!material.isShaderMaterial&&\n!material.isRawShaderMaterial||\nmaterial.clipping===true){\n\nmaterialProperties.numClippingPlanes=_clipping.numPlanes;\nmaterialProperties.numIntersection=_clipping.numIntersection;\nuniforms.clippingPlanes=_clipping.uniform;\n\n}\n\nmaterialProperties.fog=fog;\n\n// store the light setup it was created for\n\nmaterialProperties.lightsHash=_lights.hash;\n\nif(material.lights){\n\n// wire up the material to this renderer's lighting state\n\nuniforms.ambientLightColor.value=_lights.ambient;\nuniforms.directionalLights.value=_lights.directional;\nuniforms.spotLights.value=_lights.spot;\nuniforms.rectAreaLights.value=_lights.rectArea;\nuniforms.pointLights.value=_lights.point;\nuniforms.hemisphereLights.value=_lights.hemi;\n\nuniforms.directionalShadowMap.value=_lights.directionalShadowMap;\nuniforms.directionalShadowMatrix.value=_lights.directionalShadowMatrix;\nuniforms.spotShadowMap.value=_lights.spotShadowMap;\nuniforms.spotShadowMatrix.value=_lights.spotShadowMatrix;\nuniforms.pointShadowMap.value=_lights.pointShadowMap;\nuniforms.pointShadowMatrix.value=_lights.pointShadowMatrix;\n// TODO (abelnation): add area lights shadow info to uniforms\n\n}\n\nvar progUniforms=materialProperties.program.getUniforms(),\nuniformsList=\nWebGLUniforms.seqWithValue(progUniforms.seq,uniforms);\n\nmaterialProperties.uniformsList=uniformsList;\n\n}\n\nfunction setMaterial(material){\n\nmaterial.side===DoubleSide?\nstate.disable(_gl.CULL_FACE):\nstate.enable(_gl.CULL_FACE);\n\nstate.setFlipSided(material.side===BackSide);\n\nmaterial.transparent===true?\nstate.setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha):\nstate.setBlending(NoBlending);\n\nstate.setDepthFunc(material.depthFunc);\nstate.setDepthTest(material.depthTest);\nstate.setDepthWrite(material.depthWrite);\nstate.setColorWrite(material.colorWrite);\nstate.setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);\n\n}\n\nfunction setProgram(camera,fog,material,object){\n\n_usedTextureUnits=0;\n\nvar materialProperties=properties.get(material);\n\nif(_clippingEnabled){\n\nif(_localClippingEnabled||camera!==_currentCamera){\n\nvar useCache=\ncamera===_currentCamera&&\nmaterial.id===_currentMaterialId;\n\n// we might want to call this function with some ClippingGroup\n// object instead of the material, once it becomes feasible\n// (#8465, #8379)\n_clipping.setState(\nmaterial.clippingPlanes,material.clipIntersection,material.clipShadows,\ncamera,materialProperties,useCache);\n\n}\n\n}\n\nif(material.needsUpdate===false){\n\nif(materialProperties.program===undefined){\n\nmaterial.needsUpdate=true;\n\n}else if(material.fog&&materialProperties.fog!==fog){\n\nmaterial.needsUpdate=true;\n\n}else if(material.lights&&materialProperties.lightsHash!==_lights.hash){\n\nmaterial.needsUpdate=true;\n\n}else if(materialProperties.numClippingPlanes!==undefined&&(\nmaterialProperties.numClippingPlanes!==_clipping.numPlanes||\nmaterialProperties.numIntersection!==_clipping.numIntersection)){\n\nmaterial.needsUpdate=true;\n\n}\n\n}\n\nif(material.needsUpdate){\n\ninitMaterial(material,fog,object);\nmaterial.needsUpdate=false;\n\n}\n\nvar refreshProgram=false;\nvar refreshMaterial=false;\nvar refreshLights=false;\n\nvar program=materialProperties.program,\np_uniforms=program.getUniforms(),\nm_uniforms=materialProperties.__webglShader.uniforms;\n\nif(program.id!==_currentProgram){\n\n_gl.useProgram(program.program);\n_currentProgram=program.id;\n\nrefreshProgram=true;\nrefreshMaterial=true;\nrefreshLights=true;\n\n}\n\nif(material.id!==_currentMaterialId){\n\n_currentMaterialId=material.id;\n\nrefreshMaterial=true;\n\n}\n\nif(refreshProgram||camera!==_currentCamera){\n\np_uniforms.set(_gl,camera,'projectionMatrix');\n\nif(capabilities.logarithmicDepthBuffer){\n\np_uniforms.setValue(_gl,'logDepthBufFC',\n2.0/(Math.log(camera.far+1.0)/Math.LN2));\n\n}\n\n\nif(camera!==_currentCamera){\n\n_currentCamera=camera;\n\n// lighting uniforms depend on the camera so enforce an update\n// now, in case this material supports lights - or later, when\n// the next material that does gets activated:\n\nrefreshMaterial=true;// set to true on material change\nrefreshLights=true;// remains set until update done\n\n}\n\n// load material specific uniforms\n// (shader material also gets them for the sake of genericity)\n\nif(material.isShaderMaterial||\nmaterial.isMeshPhongMaterial||\nmaterial.isMeshStandardMaterial||\nmaterial.envMap){\n\nvar uCamPos=p_uniforms.map.cameraPosition;\n\nif(uCamPos!==undefined){\n\nuCamPos.setValue(_gl,\n_vector3.setFromMatrixPosition(camera.matrixWorld));\n\n}\n\n}\n\nif(material.isMeshPhongMaterial||\nmaterial.isMeshLambertMaterial||\nmaterial.isMeshBasicMaterial||\nmaterial.isMeshStandardMaterial||\nmaterial.isShaderMaterial||\nmaterial.skinning){\n\np_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);\n\n}\n\np_uniforms.set(_gl,_this,'toneMappingExposure');\np_uniforms.set(_gl,_this,'toneMappingWhitePoint');\n\n}\n\n// skinning uniforms must be set even if material didn't change\n// auto-setting of texture unit for bone texture must go before other textures\n// not sure why, but otherwise weird things happen\n\nif(material.skinning){\n\np_uniforms.setOptional(_gl,object,'bindMatrix');\np_uniforms.setOptional(_gl,object,'bindMatrixInverse');\n\nvar skeleton=object.skeleton;\n\nif(skeleton){\n\nif(capabilities.floatVertexTextures&&skeleton.useVertexTexture){\n\np_uniforms.set(_gl,skeleton,'boneTexture');\np_uniforms.set(_gl,skeleton,'boneTextureWidth');\np_uniforms.set(_gl,skeleton,'boneTextureHeight');\n\n}else{\n\np_uniforms.setOptional(_gl,skeleton,'boneMatrices');\n\n}\n\n}\n\n}\n\nif(refreshMaterial){\n\nif(material.lights){\n\n// the current material requires lighting info\n\n// note: all lighting uniforms are always set correctly\n// they simply reference the renderer's state for their\n// values\n//\n// use the current material's .needsUpdate flags to set\n// the GL state when required\n\nmarkUniformsLightsNeedsUpdate(m_uniforms,refreshLights);\n\n}\n\n// refresh uniforms common to several materials\n\nif(fog&&material.fog){\n\nrefreshUniformsFog(m_uniforms,fog);\n\n}\n\nif(material.isMeshBasicMaterial||\nmaterial.isMeshLambertMaterial||\nmaterial.isMeshPhongMaterial||\nmaterial.isMeshStandardMaterial||\nmaterial.isMeshNormalMaterial||\nmaterial.isMeshDepthMaterial){\n\nrefreshUniformsCommon(m_uniforms,material);\n\n}\n\n// refresh single material specific uniforms\n\nif(material.isLineBasicMaterial){\n\nrefreshUniformsLine(m_uniforms,material);\n\n}else if(material.isLineDashedMaterial){\n\nrefreshUniformsLine(m_uniforms,material);\nrefreshUniformsDash(m_uniforms,material);\n\n}else if(material.isPointsMaterial){\n\nrefreshUniformsPoints(m_uniforms,material);\n\n}else if(material.isMeshLambertMaterial){\n\nrefreshUniformsLambert(m_uniforms,material);\n\n}else if(material.isMeshToonMaterial){\n\nrefreshUniformsToon(m_uniforms,material);\n\n}else if(material.isMeshPhongMaterial){\n\nrefreshUniformsPhong(m_uniforms,material);\n\n}else if(material.isMeshPhysicalMaterial){\n\nrefreshUniformsPhysical(m_uniforms,material);\n\n}else if(material.isMeshStandardMaterial){\n\nrefreshUniformsStandard(m_uniforms,material);\n\n}else if(material.isMeshDepthMaterial){\n\nif(material.displacementMap){\n\nm_uniforms.displacementMap.value=material.displacementMap;\nm_uniforms.displacementScale.value=material.displacementScale;\nm_uniforms.displacementBias.value=material.displacementBias;\n\n}\n\n}else if(material.isMeshNormalMaterial){\n\nrefreshUniformsNormal(m_uniforms,material);\n\n}\n\n// RectAreaLight Texture\n// TODO (mrdoob): Find a nicer implementation\n\nif(m_uniforms.ltcMat!==undefined)m_uniforms.ltcMat.value=THREE.UniformsLib.LTC_MAT_TEXTURE;\nif(m_uniforms.ltcMag!==undefined)m_uniforms.ltcMag.value=THREE.UniformsLib.LTC_MAG_TEXTURE;\n\nWebGLUniforms.upload(\n_gl,materialProperties.uniformsList,m_uniforms,_this);\n\n}\n\n\n// common matrices\n\np_uniforms.set(_gl,object,'modelViewMatrix');\np_uniforms.set(_gl,object,'normalMatrix');\np_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);\n\nreturn program;\n\n}\n\n// Uniforms (refresh uniforms objects)\n\nfunction refreshUniformsCommon(uniforms,material){\n\nuniforms.opacity.value=material.opacity;\n\nuniforms.diffuse.value=material.color;\n\nif(material.emissive){\n\nuniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n\n}\n\nuniforms.map.value=material.map;\nuniforms.specularMap.value=material.specularMap;\nuniforms.alphaMap.value=material.alphaMap;\n\nif(material.lightMap){\n\nuniforms.lightMap.value=material.lightMap;\nuniforms.lightMapIntensity.value=material.lightMapIntensity;\n\n}\n\nif(material.aoMap){\n\nuniforms.aoMap.value=material.aoMap;\nuniforms.aoMapIntensity.value=material.aoMapIntensity;\n\n}\n\n// uv repeat and offset setting priorities\n// 1. color map\n// 2. specular map\n// 3. normal map\n// 4. bump map\n// 5. alpha map\n// 6. emissive map\n\nvar uvScaleMap;\n\nif(material.map){\n\nuvScaleMap=material.map;\n\n}else if(material.specularMap){\n\nuvScaleMap=material.specularMap;\n\n}else if(material.displacementMap){\n\nuvScaleMap=material.displacementMap;\n\n}else if(material.normalMap){\n\nuvScaleMap=material.normalMap;\n\n}else if(material.bumpMap){\n\nuvScaleMap=material.bumpMap;\n\n}else if(material.roughnessMap){\n\nuvScaleMap=material.roughnessMap;\n\n}else if(material.metalnessMap){\n\nuvScaleMap=material.metalnessMap;\n\n}else if(material.alphaMap){\n\nuvScaleMap=material.alphaMap;\n\n}else if(material.emissiveMap){\n\nuvScaleMap=material.emissiveMap;\n\n}\n\nif(uvScaleMap!==undefined){\n\n// backwards compatibility\nif(uvScaleMap.isWebGLRenderTarget){\n\nuvScaleMap=uvScaleMap.texture;\n\n}\n\nvar offset=uvScaleMap.offset;\nvar repeat=uvScaleMap.repeat;\n\nuniforms.offsetRepeat.value.set(offset.x,offset.y,repeat.x,repeat.y);\n\n}\n\nuniforms.envMap.value=material.envMap;\n\n// don't flip CubeTexture envMaps, flip everything else:\n//  WebGLRenderTargetCube will be flipped for backwards compatibility\n//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\nuniforms.flipEnvMap.value=!(material.envMap&&material.envMap.isCubeTexture)?1:-1;\n\nuniforms.reflectivity.value=material.reflectivity;\nuniforms.refractionRatio.value=material.refractionRatio;\n\n}\n\nfunction refreshUniformsLine(uniforms,material){\n\nuniforms.diffuse.value=material.color;\nuniforms.opacity.value=material.opacity;\n\n}\n\nfunction refreshUniformsDash(uniforms,material){\n\nuniforms.dashSize.value=material.dashSize;\nuniforms.totalSize.value=material.dashSize+material.gapSize;\nuniforms.scale.value=material.scale;\n\n}\n\nfunction refreshUniformsPoints(uniforms,material){\n\nuniforms.diffuse.value=material.color;\nuniforms.opacity.value=material.opacity;\nuniforms.size.value=material.size*_pixelRatio;\nuniforms.scale.value=_height*0.5;\n\nuniforms.map.value=material.map;\n\nif(material.map!==null){\n\nvar offset=material.map.offset;\nvar repeat=material.map.repeat;\n\nuniforms.offsetRepeat.value.set(offset.x,offset.y,repeat.x,repeat.y);\n\n}\n\n}\n\nfunction refreshUniformsFog(uniforms,fog){\n\nuniforms.fogColor.value=fog.color;\n\nif(fog.isFog){\n\nuniforms.fogNear.value=fog.near;\nuniforms.fogFar.value=fog.far;\n\n}else if(fog.isFogExp2){\n\nuniforms.fogDensity.value=fog.density;\n\n}\n\n}\n\nfunction refreshUniformsLambert(uniforms,material){\n\nif(material.emissiveMap){\n\nuniforms.emissiveMap.value=material.emissiveMap;\n\n}\n\n}\n\nfunction refreshUniformsPhong(uniforms,material){\n\nuniforms.specular.value=material.specular;\nuniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )\n\nif(material.emissiveMap){\n\nuniforms.emissiveMap.value=material.emissiveMap;\n\n}\n\nif(material.bumpMap){\n\nuniforms.bumpMap.value=material.bumpMap;\nuniforms.bumpScale.value=material.bumpScale;\n\n}\n\nif(material.normalMap){\n\nuniforms.normalMap.value=material.normalMap;\nuniforms.normalScale.value.copy(material.normalScale);\n\n}\n\nif(material.displacementMap){\n\nuniforms.displacementMap.value=material.displacementMap;\nuniforms.displacementScale.value=material.displacementScale;\nuniforms.displacementBias.value=material.displacementBias;\n\n}\n\n}\n\nfunction refreshUniformsToon(uniforms,material){\n\nrefreshUniformsPhong(uniforms,material);\n\nif(material.gradientMap){\n\nuniforms.gradientMap.value=material.gradientMap;\n\n}\n\n}\n\nfunction refreshUniformsStandard(uniforms,material){\n\nuniforms.roughness.value=material.roughness;\nuniforms.metalness.value=material.metalness;\n\nif(material.roughnessMap){\n\nuniforms.roughnessMap.value=material.roughnessMap;\n\n}\n\nif(material.metalnessMap){\n\nuniforms.metalnessMap.value=material.metalnessMap;\n\n}\n\nif(material.emissiveMap){\n\nuniforms.emissiveMap.value=material.emissiveMap;\n\n}\n\nif(material.bumpMap){\n\nuniforms.bumpMap.value=material.bumpMap;\nuniforms.bumpScale.value=material.bumpScale;\n\n}\n\nif(material.normalMap){\n\nuniforms.normalMap.value=material.normalMap;\nuniforms.normalScale.value.copy(material.normalScale);\n\n}\n\nif(material.displacementMap){\n\nuniforms.displacementMap.value=material.displacementMap;\nuniforms.displacementScale.value=material.displacementScale;\nuniforms.displacementBias.value=material.displacementBias;\n\n}\n\nif(material.envMap){\n\n//uniforms.envMap.value = material.envMap; // part of uniforms common\nuniforms.envMapIntensity.value=material.envMapIntensity;\n\n}\n\n}\n\nfunction refreshUniformsPhysical(uniforms,material){\n\nuniforms.clearCoat.value=material.clearCoat;\nuniforms.clearCoatRoughness.value=material.clearCoatRoughness;\n\nrefreshUniformsStandard(uniforms,material);\n\n}\n\nfunction refreshUniformsNormal(uniforms,material){\n\nif(material.bumpMap){\n\nuniforms.bumpMap.value=material.bumpMap;\nuniforms.bumpScale.value=material.bumpScale;\n\n}\n\nif(material.normalMap){\n\nuniforms.normalMap.value=material.normalMap;\nuniforms.normalScale.value.copy(material.normalScale);\n\n}\n\nif(material.displacementMap){\n\nuniforms.displacementMap.value=material.displacementMap;\nuniforms.displacementScale.value=material.displacementScale;\nuniforms.displacementBias.value=material.displacementBias;\n\n}\n\n}\n\n// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\nfunction markUniformsLightsNeedsUpdate(uniforms,value){\n\nuniforms.ambientLightColor.needsUpdate=value;\n\nuniforms.directionalLights.needsUpdate=value;\nuniforms.pointLights.needsUpdate=value;\nuniforms.spotLights.needsUpdate=value;\nuniforms.rectAreaLights.needsUpdate=value;\nuniforms.hemisphereLights.needsUpdate=value;\n\n}\n\n// Lighting\n\nfunction setupShadows(lights){\n\nvar lightShadowsLength=0;\n\nfor(var i=0,l=lights.length;i<l;i++){\n\nvar light=lights[i];\n\nif(light.castShadow){\n\n_lights.shadows[lightShadowsLength++]=light;\n\n}\n\n}\n\n_lights.shadows.length=lightShadowsLength;\n\n}\n\nfunction setupLights(lights,camera){\n\nvar l,ll,light,\nr=0,g=0,b=0,\ncolor,\nintensity,\ndistance,\nshadowMap,\n\nviewMatrix=camera.matrixWorldInverse,\n\ndirectionalLength=0,\npointLength=0,\nspotLength=0,\nrectAreaLength=0,\nhemiLength=0;\n\nfor(l=0,ll=lights.length;l<ll;l++){\n\nlight=lights[l];\n\ncolor=light.color;\nintensity=light.intensity;\ndistance=light.distance;\n\nshadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;\n\nif(light.isAmbientLight){\n\nr+=color.r*intensity;\ng+=color.g*intensity;\nb+=color.b*intensity;\n\n}else if(light.isDirectionalLight){\n\nvar uniforms=lightCache.get(light);\n\nuniforms.color.copy(light.color).multiplyScalar(light.intensity);\nuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n_vector3.setFromMatrixPosition(light.target.matrixWorld);\nuniforms.direction.sub(_vector3);\nuniforms.direction.transformDirection(viewMatrix);\n\nuniforms.shadow=light.castShadow;\n\nif(light.castShadow){\n\nuniforms.shadowBias=light.shadow.bias;\nuniforms.shadowRadius=light.shadow.radius;\nuniforms.shadowMapSize=light.shadow.mapSize;\n\n}\n\n_lights.directionalShadowMap[directionalLength]=shadowMap;\n_lights.directionalShadowMatrix[directionalLength]=light.shadow.matrix;\n_lights.directional[directionalLength++]=uniforms;\n\n}else if(light.isSpotLight){\n\nvar uniforms=lightCache.get(light);\n\nuniforms.position.setFromMatrixPosition(light.matrixWorld);\nuniforms.position.applyMatrix4(viewMatrix);\n\nuniforms.color.copy(color).multiplyScalar(intensity);\nuniforms.distance=distance;\n\nuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n_vector3.setFromMatrixPosition(light.target.matrixWorld);\nuniforms.direction.sub(_vector3);\nuniforms.direction.transformDirection(viewMatrix);\n\nuniforms.coneCos=Math.cos(light.angle);\nuniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));\nuniforms.decay=light.distance===0?0.0:light.decay;\n\nuniforms.shadow=light.castShadow;\n\nif(light.castShadow){\n\nuniforms.shadowBias=light.shadow.bias;\nuniforms.shadowRadius=light.shadow.radius;\nuniforms.shadowMapSize=light.shadow.mapSize;\n\n}\n\n_lights.spotShadowMap[spotLength]=shadowMap;\n_lights.spotShadowMatrix[spotLength]=light.shadow.matrix;\n_lights.spot[spotLength++]=uniforms;\n\n}else if(light.isRectAreaLight){\n\nvar uniforms=lightCache.get(light);\n\n// (a) intensity controls irradiance of entire light\nuniforms.color.\ncopy(color).\nmultiplyScalar(intensity/(light.width*light.height));\n\n// (b) intensity controls the radiance per light area\n// uniforms.color.copy( color ).multiplyScalar( intensity );\n\nuniforms.position.setFromMatrixPosition(light.matrixWorld);\nuniforms.position.applyMatrix4(viewMatrix);\n\n// extract local rotation of light to derive width/height half vectors\n_matrix42.identity();\n_matrix4.copy(light.matrixWorld);\n_matrix4.premultiply(viewMatrix);\n_matrix42.extractRotation(_matrix4);\n\nuniforms.halfWidth.set(light.width*0.5,0.0,0.0);\nuniforms.halfHeight.set(0.0,light.height*0.5,0.0);\n\nuniforms.halfWidth.applyMatrix4(_matrix42);\nuniforms.halfHeight.applyMatrix4(_matrix42);\n\n// TODO (abelnation): RectAreaLight distance?\n// uniforms.distance = distance;\n\n_lights.rectArea[rectAreaLength++]=uniforms;\n\n}else if(light.isPointLight){\n\nvar uniforms=lightCache.get(light);\n\nuniforms.position.setFromMatrixPosition(light.matrixWorld);\nuniforms.position.applyMatrix4(viewMatrix);\n\nuniforms.color.copy(light.color).multiplyScalar(light.intensity);\nuniforms.distance=light.distance;\nuniforms.decay=light.distance===0?0.0:light.decay;\n\nuniforms.shadow=light.castShadow;\n\nif(light.castShadow){\n\nuniforms.shadowBias=light.shadow.bias;\nuniforms.shadowRadius=light.shadow.radius;\nuniforms.shadowMapSize=light.shadow.mapSize;\n\n}\n\n_lights.pointShadowMap[pointLength]=shadowMap;\n\nif(_lights.pointShadowMatrix[pointLength]===undefined){\n\n_lights.pointShadowMatrix[pointLength]=new Matrix4();\n\n}\n\n// for point lights we set the shadow matrix to be a translation-only matrix\n// equal to inverse of the light's position\n_vector3.setFromMatrixPosition(light.matrixWorld).negate();\n_lights.pointShadowMatrix[pointLength].identity().setPosition(_vector3);\n\n_lights.point[pointLength++]=uniforms;\n\n}else if(light.isHemisphereLight){\n\nvar uniforms=lightCache.get(light);\n\nuniforms.direction.setFromMatrixPosition(light.matrixWorld);\nuniforms.direction.transformDirection(viewMatrix);\nuniforms.direction.normalize();\n\nuniforms.skyColor.copy(light.color).multiplyScalar(intensity);\nuniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n\n_lights.hemi[hemiLength++]=uniforms;\n\n}\n\n}\n\n_lights.ambient[0]=r;\n_lights.ambient[1]=g;\n_lights.ambient[2]=b;\n\n_lights.directional.length=directionalLength;\n_lights.spot.length=spotLength;\n_lights.rectArea.length=rectAreaLength;\n_lights.point.length=pointLength;\n_lights.hemi.length=hemiLength;\n\n// TODO (sam-g-steel) why aren't we using join\n_lights.hash=directionalLength+','+pointLength+','+spotLength+','+rectAreaLength+','+hemiLength+','+_lights.shadows.length;\n\n}\n\n// GL state setting\n\nthis.setFaceCulling=function(cullFace,frontFaceDirection){\n\nstate.setCullFace(cullFace);\nstate.setFlipSided(frontFaceDirection===FrontFaceDirectionCW);\n\n};\n\n// Textures\n\nfunction allocTextureUnit(){\n\nvar textureUnit=_usedTextureUnits;\n\nif(textureUnit>=capabilities.maxTextures){\n\nconsole.warn('WebGLRenderer: trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);\n\n}\n\n_usedTextureUnits+=1;\n\nreturn textureUnit;\n\n}\n\nthis.allocTextureUnit=allocTextureUnit;\n\n// this.setTexture2D = setTexture2D;\nthis.setTexture2D=function(){\n\nvar warned=false;\n\n// backwards compatibility: peel texture.texture\nreturn function setTexture2D(texture,slot){\n\nif(texture&&texture.isWebGLRenderTarget){\n\nif(!warned){\n\nconsole.warn(\"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\");\nwarned=true;\n\n}\n\ntexture=texture.texture;\n\n}\n\ntextures.setTexture2D(texture,slot);\n\n};\n\n}();\n\nthis.setTexture=function(){\n\nvar warned=false;\n\nreturn function setTexture(texture,slot){\n\nif(!warned){\n\nconsole.warn(\"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\");\nwarned=true;\n\n}\n\ntextures.setTexture2D(texture,slot);\n\n};\n\n}();\n\nthis.setTextureCube=function(){\n\nvar warned=false;\n\nreturn function setTextureCube(texture,slot){\n\n// backwards compatibility: peel texture.texture\nif(texture&&texture.isWebGLRenderTargetCube){\n\nif(!warned){\n\nconsole.warn(\"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\");\nwarned=true;\n\n}\n\ntexture=texture.texture;\n\n}\n\n// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\n// TODO: unify these code paths\nif(texture&&texture.isCubeTexture||\nArray.isArray(texture.image)&&texture.image.length===6){\n\n// CompressedTexture can have Array in image :/\n\n// this function alone should take care of cube textures\ntextures.setTextureCube(texture,slot);\n\n}else{\n\n// assumed: texture property of THREE.WebGLRenderTargetCube\n\ntextures.setTextureCubeDynamic(texture,slot);\n\n}\n\n};\n\n}();\n\nthis.getCurrentRenderTarget=function(){\n\nreturn _currentRenderTarget;\n\n};\n\nthis.setRenderTarget=function(renderTarget){\n\n_currentRenderTarget=renderTarget;\n\nif(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){\n\ntextures.setupRenderTarget(renderTarget);\n\n}\n\nvar isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;\nvar framebuffer;\n\nif(renderTarget){\n\nvar renderTargetProperties=properties.get(renderTarget);\n\nif(isCube){\n\nframebuffer=renderTargetProperties.__webglFramebuffer[renderTarget.activeCubeFace];\n\n}else{\n\nframebuffer=renderTargetProperties.__webglFramebuffer;\n\n}\n\n_currentScissor.copy(renderTarget.scissor);\n_currentScissorTest=renderTarget.scissorTest;\n\n_currentViewport.copy(renderTarget.viewport);\n\n}else{\n\nframebuffer=null;\n\n_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);\n_currentScissorTest=_scissorTest;\n\n_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);\n\n}\n\nif(_currentFramebuffer!==framebuffer){\n\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);\n_currentFramebuffer=framebuffer;\n\n}\n\nstate.scissor(_currentScissor);\nstate.setScissorTest(_currentScissorTest);\n\nstate.viewport(_currentViewport);\n\nif(isCube){\n\nvar textureProperties=properties.get(renderTarget.texture);\n_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+renderTarget.activeCubeFace,textureProperties.__webglTexture,renderTarget.activeMipMapLevel);\n\n}\n\n};\n\nthis.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer){\n\nif((renderTarget&&renderTarget.isWebGLRenderTarget)===false){\n\nconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\nreturn;\n\n}\n\nvar framebuffer=properties.get(renderTarget).__webglFramebuffer;\n\nif(framebuffer){\n\nvar restore=false;\n\nif(framebuffer!==_currentFramebuffer){\n\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);\n\nrestore=true;\n\n}\n\ntry{\n\nvar texture=renderTarget.texture;\nvar textureFormat=texture.format;\nvar textureType=texture.type;\n\nif(textureFormat!==RGBAFormat&&paramThreeToGL(textureFormat)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)){\n\nconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');\nreturn;\n\n}\n\nif(textureType!==UnsignedByteType&&paramThreeToGL(textureType)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE)&&// IE11, Edge and Chrome Mac < 52 (#9513)\n!(textureType===FloatType&&(extensions.get('OES_texture_float')||extensions.get('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox\n!(textureType===HalfFloatType&&extensions.get('EXT_color_buffer_half_float'))){\n\nconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');\nreturn;\n\n}\n\nif(_gl.checkFramebufferStatus(_gl.FRAMEBUFFER)===_gl.FRAMEBUFFER_COMPLETE){\n\n// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\nif(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){\n\n_gl.readPixels(x,y,width,height,paramThreeToGL(textureFormat),paramThreeToGL(textureType),buffer);\n\n}\n\n}else{\n\nconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');\n\n}\n\n}finally{\n\nif(restore){\n\n_gl.bindFramebuffer(_gl.FRAMEBUFFER,_currentFramebuffer);\n\n}\n\n}\n\n}\n\n};\n\n// Map three.js constants to WebGL constants\n\nfunction paramThreeToGL(p){\n\nvar extension;\n\nif(p===RepeatWrapping)return _gl.REPEAT;\nif(p===ClampToEdgeWrapping)return _gl.CLAMP_TO_EDGE;\nif(p===MirroredRepeatWrapping)return _gl.MIRRORED_REPEAT;\n\nif(p===NearestFilter)return _gl.NEAREST;\nif(p===NearestMipMapNearestFilter)return _gl.NEAREST_MIPMAP_NEAREST;\nif(p===NearestMipMapLinearFilter)return _gl.NEAREST_MIPMAP_LINEAR;\n\nif(p===LinearFilter)return _gl.LINEAR;\nif(p===LinearMipMapNearestFilter)return _gl.LINEAR_MIPMAP_NEAREST;\nif(p===LinearMipMapLinearFilter)return _gl.LINEAR_MIPMAP_LINEAR;\n\nif(p===UnsignedByteType)return _gl.UNSIGNED_BYTE;\nif(p===UnsignedShort4444Type)return _gl.UNSIGNED_SHORT_4_4_4_4;\nif(p===UnsignedShort5551Type)return _gl.UNSIGNED_SHORT_5_5_5_1;\nif(p===UnsignedShort565Type)return _gl.UNSIGNED_SHORT_5_6_5;\n\nif(p===ByteType)return _gl.BYTE;\nif(p===ShortType)return _gl.SHORT;\nif(p===UnsignedShortType)return _gl.UNSIGNED_SHORT;\nif(p===IntType)return _gl.INT;\nif(p===UnsignedIntType)return _gl.UNSIGNED_INT;\nif(p===FloatType)return _gl.FLOAT;\n\nif(p===HalfFloatType){\n\nextension=extensions.get('OES_texture_half_float');\n\nif(extension!==null)return extension.HALF_FLOAT_OES;\n\n}\n\nif(p===AlphaFormat)return _gl.ALPHA;\nif(p===RGBFormat)return _gl.RGB;\nif(p===RGBAFormat)return _gl.RGBA;\nif(p===LuminanceFormat)return _gl.LUMINANCE;\nif(p===LuminanceAlphaFormat)return _gl.LUMINANCE_ALPHA;\nif(p===DepthFormat)return _gl.DEPTH_COMPONENT;\nif(p===DepthStencilFormat)return _gl.DEPTH_STENCIL;\n\nif(p===AddEquation)return _gl.FUNC_ADD;\nif(p===SubtractEquation)return _gl.FUNC_SUBTRACT;\nif(p===ReverseSubtractEquation)return _gl.FUNC_REVERSE_SUBTRACT;\n\nif(p===ZeroFactor)return _gl.ZERO;\nif(p===OneFactor)return _gl.ONE;\nif(p===SrcColorFactor)return _gl.SRC_COLOR;\nif(p===OneMinusSrcColorFactor)return _gl.ONE_MINUS_SRC_COLOR;\nif(p===SrcAlphaFactor)return _gl.SRC_ALPHA;\nif(p===OneMinusSrcAlphaFactor)return _gl.ONE_MINUS_SRC_ALPHA;\nif(p===DstAlphaFactor)return _gl.DST_ALPHA;\nif(p===OneMinusDstAlphaFactor)return _gl.ONE_MINUS_DST_ALPHA;\n\nif(p===DstColorFactor)return _gl.DST_COLOR;\nif(p===OneMinusDstColorFactor)return _gl.ONE_MINUS_DST_COLOR;\nif(p===SrcAlphaSaturateFactor)return _gl.SRC_ALPHA_SATURATE;\n\nif(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||\np===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){\n\nextension=extensions.get('WEBGL_compressed_texture_s3tc');\n\nif(extension!==null){\n\nif(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\nif(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\nif(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\nif(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n}\n\n}\n\nif(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||\np===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){\n\nextension=extensions.get('WEBGL_compressed_texture_pvrtc');\n\nif(extension!==null){\n\nif(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\nif(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\nif(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\nif(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n}\n\n}\n\nif(p===RGB_ETC1_Format){\n\nextension=extensions.get('WEBGL_compressed_texture_etc1');\n\nif(extension!==null)return extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n}\n\nif(p===MinEquation||p===MaxEquation){\n\nextension=extensions.get('EXT_blend_minmax');\n\nif(extension!==null){\n\nif(p===MinEquation)return extension.MIN_EXT;\nif(p===MaxEquation)return extension.MAX_EXT;\n\n}\n\n}\n\nif(p===UnsignedInt248Type){\n\nextension=extensions.get('WEBGL_depth_texture');\n\nif(extension!==null)return extension.UNSIGNED_INT_24_8_WEBGL;\n\n}\n\nreturn 0;\n\n}\n\n}\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction FogExp2(color,density){\n\nthis.name='';\n\nthis.color=new Color(color);\nthis.density=density!==undefined?density:0.00025;\n\n}\n\nFogExp2.prototype.isFogExp2=true;\n\nFogExp2.prototype.clone=function(){\n\nreturn new FogExp2(this.color.getHex(),this.density);\n\n};\n\nFogExp2.prototype.toJSON=function(meta){\n\nreturn{\ntype:'FogExp2',\ncolor:this.color.getHex(),\ndensity:this.density};\n\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction Fog(color,near,far){\n\nthis.name='';\n\nthis.color=new Color(color);\n\nthis.near=near!==undefined?near:1;\nthis.far=far!==undefined?far:1000;\n\n}\n\nFog.prototype.isFog=true;\n\nFog.prototype.clone=function(){\n\nreturn new Fog(this.color.getHex(),this.near,this.far);\n\n};\n\nFog.prototype.toJSON=function(meta){\n\nreturn{\ntype:'Fog',\ncolor:this.color.getHex(),\nnear:this.near,\nfar:this.far};\n\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Scene(){\n\nObject3D.call(this);\n\nthis.type='Scene';\n\nthis.background=null;\nthis.fog=null;\nthis.overrideMaterial=null;\n\nthis.autoUpdate=true;// checked by the renderer\n\n}\n\nScene.prototype=Object.create(Object3D.prototype);\n\nScene.prototype.constructor=Scene;\n\nScene.prototype.copy=function(source,recursive){\n\nObject3D.prototype.copy.call(this,source,recursive);\n\nif(source.background!==null)this.background=source.background.clone();\nif(source.fog!==null)this.fog=source.fog.clone();\nif(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();\n\nthis.autoUpdate=source.autoUpdate;\nthis.matrixAutoUpdate=source.matrixAutoUpdate;\n\nreturn this;\n\n};\n\nScene.prototype.toJSON=function(meta){\n\nvar data=Object3D.prototype.toJSON.call(this,meta);\n\nif(this.background!==null)data.object.background=this.background.toJSON(meta);\nif(this.fog!==null)data.object.fog=this.fog.toJSON();\n\nreturn data;\n\n};\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction LensFlare(texture,size,distance,blending,color){\n\nObject3D.call(this);\n\nthis.lensFlares=[];\n\nthis.positionScreen=new Vector3();\nthis.customUpdateCallback=undefined;\n\nif(texture!==undefined){\n\nthis.add(texture,size,distance,blending,color);\n\n}\n\n}\n\nLensFlare.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:LensFlare,\n\nisLensFlare:true,\n\ncopy:function copy(source){\n\nObject3D.prototype.copy.call(this,source);\n\nthis.positionScreen.copy(source.positionScreen);\nthis.customUpdateCallback=source.customUpdateCallback;\n\nfor(var i=0,l=source.lensFlares.length;i<l;i++){\n\nthis.lensFlares.push(source.lensFlares[i]);\n\n}\n\nreturn this;\n\n},\n\nadd:function add(texture,size,distance,blending,color,opacity){\n\nif(size===undefined)size=-1;\nif(distance===undefined)distance=0;\nif(opacity===undefined)opacity=1;\nif(color===undefined)color=new Color(0xffffff);\nif(blending===undefined)blending=NormalBlending;\n\ndistance=Math.min(distance,Math.max(0,distance));\n\nthis.lensFlares.push({\ntexture:texture,// THREE.Texture\nsize:size,// size in pixels (-1 = use texture.width)\ndistance:distance,// distance (0-1) from light source (0=at light source)\nx:0,y:0,z:0,// screen position (-1 => 1) z = 0 is in front z = 1 is back\nscale:1,// scale\nrotation:0,// rotation\nopacity:opacity,// opacity\ncolor:color,// color\nblending:blending// blending\n});\n\n},\n\n/*\n\t\t * Update lens flares update positions on all flares based on the screen position\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n\t\t */\n\nupdateLensFlares:function updateLensFlares(){\n\nvar f,fl=this.lensFlares.length;\nvar flare;\nvar vecX=-this.positionScreen.x*2;\nvar vecY=-this.positionScreen.y*2;\n\nfor(f=0;f<fl;f++){\n\nflare=this.lensFlares[f];\n\nflare.x=this.positionScreen.x+vecX*flare.distance;\nflare.y=this.positionScreen.y+vecY*flare.distance;\n\nflare.wantedRotation=flare.x*Math.PI*0.25;\nflare.rotation+=(flare.wantedRotation-flare.rotation)*0.25;\n\n}\n\n}});\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *\tuvOffset: new THREE.Vector2(),\n\t *\tuvScale: new THREE.Vector2()\n\t * }\n\t */\n\nfunction SpriteMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='SpriteMaterial';\n\nthis.color=new Color(0xffffff);\nthis.map=null;\n\nthis.rotation=0;\n\nthis.fog=false;\nthis.lights=false;\n\nthis.setValues(parameters);\n\n}\n\nSpriteMaterial.prototype=Object.create(Material.prototype);\nSpriteMaterial.prototype.constructor=SpriteMaterial;\n\nSpriteMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.color.copy(source.color);\nthis.map=source.map;\n\nthis.rotation=source.rotation;\n\nreturn this;\n\n};\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction Sprite(material){\n\nObject3D.call(this);\n\nthis.type='Sprite';\n\nthis.material=material!==undefined?material:new SpriteMaterial();\n\n}\n\nSprite.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:Sprite,\n\nisSprite:true,\n\nraycast:function(){\n\nvar matrixPosition=new Vector3();\n\nreturn function raycast(raycaster,intersects){\n\nmatrixPosition.setFromMatrixPosition(this.matrixWorld);\n\nvar distanceSq=raycaster.ray.distanceSqToPoint(matrixPosition);\nvar guessSizeSq=this.scale.x*this.scale.y/4;\n\nif(distanceSq>guessSizeSq){\n\nreturn;\n\n}\n\nintersects.push({\n\ndistance:Math.sqrt(distanceSq),\npoint:this.position,\nface:null,\nobject:this});\n\n\n\n};\n\n}(),\n\nclone:function clone(){\n\nreturn new this.constructor(this.material).copy(this);\n\n}});\n\n\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction LOD(){\n\nObject3D.call(this);\n\nthis.type='LOD';\n\nObject.defineProperties(this,{\nlevels:{\nenumerable:true,\nvalue:[]}});\n\n\n\n}\n\n\nLOD.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:LOD,\n\ncopy:function copy(source){\n\nObject3D.prototype.copy.call(this,source,false);\n\nvar levels=source.levels;\n\nfor(var i=0,l=levels.length;i<l;i++){\n\nvar level=levels[i];\n\nthis.addLevel(level.object.clone(),level.distance);\n\n}\n\nreturn this;\n\n},\n\naddLevel:function addLevel(object,distance){\n\nif(distance===undefined)distance=0;\n\ndistance=Math.abs(distance);\n\nvar levels=this.levels;\n\nfor(var l=0;l<levels.length;l++){\n\nif(distance<levels[l].distance){\n\nbreak;\n\n}\n\n}\n\nlevels.splice(l,0,{distance:distance,object:object});\n\nthis.add(object);\n\n},\n\ngetObjectForDistance:function getObjectForDistance(distance){\n\nvar levels=this.levels;\n\nfor(var i=1,l=levels.length;i<l;i++){\n\nif(distance<levels[i].distance){\n\nbreak;\n\n}\n\n}\n\nreturn levels[i-1].object;\n\n},\n\nraycast:function(){\n\nvar matrixPosition=new Vector3();\n\nreturn function raycast(raycaster,intersects){\n\nmatrixPosition.setFromMatrixPosition(this.matrixWorld);\n\nvar distance=raycaster.ray.origin.distanceTo(matrixPosition);\n\nthis.getObjectForDistance(distance).raycast(raycaster,intersects);\n\n};\n\n}(),\n\nupdate:function(){\n\nvar v1=new Vector3();\nvar v2=new Vector3();\n\nreturn function update(camera){\n\nvar levels=this.levels;\n\nif(levels.length>1){\n\nv1.setFromMatrixPosition(camera.matrixWorld);\nv2.setFromMatrixPosition(this.matrixWorld);\n\nvar distance=v1.distanceTo(v2);\n\nlevels[0].object.visible=true;\n\nfor(var i=1,l=levels.length;i<l;i++){\n\nif(distance>=levels[i].distance){\n\nlevels[i-1].object.visible=false;\nlevels[i].object.visible=true;\n\n}else{\n\nbreak;\n\n}\n\n}\n\nfor(;i<l;i++){\n\nlevels[i].object.visible=false;\n\n}\n\n}\n\n};\n\n}(),\n\ntoJSON:function toJSON(meta){\n\nvar data=Object3D.prototype.toJSON.call(this,meta);\n\ndata.object.levels=[];\n\nvar levels=this.levels;\n\nfor(var i=0,l=levels.length;i<l;i++){\n\nvar level=levels[i];\n\ndata.object.levels.push({\nobject:level.object.uuid,\ndistance:level.distance});\n\n\n}\n\nreturn data;\n\n}});\n\n\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author michael guerrero / http://realitymeltdown.com\n\t * @author ikerr / http://verold.com\n\t */\n\nfunction Skeleton(bones,boneInverses,useVertexTexture){\n\nthis.useVertexTexture=useVertexTexture!==undefined?useVertexTexture:true;\n\nthis.identityMatrix=new Matrix4();\n\n// copy the bone array\n\nbones=bones||[];\n\nthis.bones=bones.slice(0);\n\n// create a bone texture or an array of floats\n\nif(this.useVertexTexture){\n\n// layout (1 matrix = 4 pixels)\n//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\nvar size=Math.sqrt(this.bones.length*4);// 4 pixels needed for 1 matrix\nsize=_Math.nextPowerOfTwo(Math.ceil(size));\nsize=Math.max(size,4);\n\nthis.boneTextureWidth=size;\nthis.boneTextureHeight=size;\n\nthis.boneMatrices=new Float32Array(this.boneTextureWidth*this.boneTextureHeight*4);// 4 floats per RGBA pixel\nthis.boneTexture=new DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,RGBAFormat,FloatType);\n\n}else{\n\nthis.boneMatrices=new Float32Array(16*this.bones.length);\n\n}\n\n// use the supplied bone inverses or calculate the inverses\n\nif(boneInverses===undefined){\n\nthis.calculateInverses();\n\n}else{\n\nif(this.bones.length===boneInverses.length){\n\nthis.boneInverses=boneInverses.slice(0);\n\n}else{\n\nconsole.warn('THREE.Skeleton bonInverses is the wrong length.');\n\nthis.boneInverses=[];\n\nfor(var b=0,bl=this.bones.length;b<bl;b++){\n\nthis.boneInverses.push(new Matrix4());\n\n}\n\n}\n\n}\n\n}\n\nObject.assign(Skeleton.prototype,{\n\ncalculateInverses:function calculateInverses(){\n\nthis.boneInverses=[];\n\nfor(var b=0,bl=this.bones.length;b<bl;b++){\n\nvar inverse=new Matrix4();\n\nif(this.bones[b]){\n\ninverse.getInverse(this.bones[b].matrixWorld);\n\n}\n\nthis.boneInverses.push(inverse);\n\n}\n\n},\n\npose:function pose(){\n\nvar bone;\n\n// recover the bind-time world matrices\n\nfor(var b=0,bl=this.bones.length;b<bl;b++){\n\nbone=this.bones[b];\n\nif(bone){\n\nbone.matrixWorld.getInverse(this.boneInverses[b]);\n\n}\n\n}\n\n// compute the local matrices, positions, rotations and scales\n\nfor(var b=0,bl=this.bones.length;b<bl;b++){\n\nbone=this.bones[b];\n\nif(bone){\n\nif(bone.parent&&bone.parent.isBone){\n\nbone.matrix.getInverse(bone.parent.matrixWorld);\nbone.matrix.multiply(bone.matrixWorld);\n\n}else{\n\nbone.matrix.copy(bone.matrixWorld);\n\n}\n\nbone.matrix.decompose(bone.position,bone.quaternion,bone.scale);\n\n}\n\n}\n\n},\n\nupdate:function(){\n\nvar offsetMatrix=new Matrix4();\n\nreturn function update(){\n\n// flatten bone matrices to array\n\nfor(var b=0,bl=this.bones.length;b<bl;b++){\n\n// compute the offset between the current and the original transform\n\nvar matrix=this.bones[b]?this.bones[b].matrixWorld:this.identityMatrix;\n\noffsetMatrix.multiplyMatrices(matrix,this.boneInverses[b]);\noffsetMatrix.toArray(this.boneMatrices,b*16);\n\n}\n\nif(this.useVertexTexture){\n\nthis.boneTexture.needsUpdate=true;\n\n}\n\n};\n\n}(),\n\nclone:function clone(){\n\nreturn new Skeleton(this.bones,this.boneInverses,this.useVertexTexture);\n\n}});\n\n\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\nfunction Bone(){\n\nObject3D.call(this);\n\nthis.type='Bone';\n\n}\n\nBone.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:Bone,\n\nisBone:true});\n\n\n\n/**\n\t * @author mikael emtinger / http://gomo.se/\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author ikerr / http://verold.com\n\t */\n\nfunction SkinnedMesh(geometry,material,useVertexTexture){\n\nMesh.call(this,geometry,material);\n\nthis.type='SkinnedMesh';\n\nthis.bindMode=\"attached\";\nthis.bindMatrix=new Matrix4();\nthis.bindMatrixInverse=new Matrix4();\n\n// init bones\n\n// TODO: remove bone creation as there is no reason (other than\n// convenience) for THREE.SkinnedMesh to do this.\n\nvar bones=[];\n\nif(this.geometry&&this.geometry.bones!==undefined){\n\nvar bone,gbone;\n\nfor(var b=0,bl=this.geometry.bones.length;b<bl;++b){\n\ngbone=this.geometry.bones[b];\n\nbone=new Bone();\nbones.push(bone);\n\nbone.name=gbone.name;\nbone.position.fromArray(gbone.pos);\nbone.quaternion.fromArray(gbone.rotq);\nif(gbone.scl!==undefined)bone.scale.fromArray(gbone.scl);\n\n}\n\nfor(var b=0,bl=this.geometry.bones.length;b<bl;++b){\n\ngbone=this.geometry.bones[b];\n\nif(gbone.parent!==-1&&gbone.parent!==null&&\nbones[gbone.parent]!==undefined){\n\nbones[gbone.parent].add(bones[b]);\n\n}else{\n\nthis.add(bones[b]);\n\n}\n\n}\n\n}\n\nthis.normalizeSkinWeights();\n\nthis.updateMatrixWorld(true);\nthis.bind(new Skeleton(bones,undefined,useVertexTexture),this.matrixWorld);\n\n}\n\n\nSkinnedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{\n\nconstructor:SkinnedMesh,\n\nisSkinnedMesh:true,\n\nbind:function bind(skeleton,bindMatrix){\n\nthis.skeleton=skeleton;\n\nif(bindMatrix===undefined){\n\nthis.updateMatrixWorld(true);\n\nthis.skeleton.calculateInverses();\n\nbindMatrix=this.matrixWorld;\n\n}\n\nthis.bindMatrix.copy(bindMatrix);\nthis.bindMatrixInverse.getInverse(bindMatrix);\n\n},\n\npose:function pose(){\n\nthis.skeleton.pose();\n\n},\n\nnormalizeSkinWeights:function normalizeSkinWeights(){\n\nif(this.geometry&&this.geometry.isGeometry){\n\nfor(var i=0;i<this.geometry.skinWeights.length;i++){\n\nvar sw=this.geometry.skinWeights[i];\n\nvar scale=1.0/sw.lengthManhattan();\n\nif(scale!==Infinity){\n\nsw.multiplyScalar(scale);\n\n}else{\n\nsw.set(1,0,0,0);// do something reasonable\n\n}\n\n}\n\n}else if(this.geometry&&this.geometry.isBufferGeometry){\n\nvar vec=new Vector4();\n\nvar skinWeight=this.geometry.attributes.skinWeight;\n\nfor(var i=0;i<skinWeight.count;i++){\n\nvec.x=skinWeight.getX(i);\nvec.y=skinWeight.getY(i);\nvec.z=skinWeight.getZ(i);\nvec.w=skinWeight.getW(i);\n\nvar scale=1.0/vec.lengthManhattan();\n\nif(scale!==Infinity){\n\nvec.multiplyScalar(scale);\n\n}else{\n\nvec.set(1,0,0,0);// do something reasonable\n\n}\n\nskinWeight.setXYZW(i,vec.x,vec.y,vec.z,vec.w);\n\n}\n\n}\n\n},\n\nupdateMatrixWorld:function updateMatrixWorld(force){\n\nMesh.prototype.updateMatrixWorld.call(this,true);\n\nif(this.bindMode===\"attached\"){\n\nthis.bindMatrixInverse.getInverse(this.matrixWorld);\n\n}else if(this.bindMode===\"detached\"){\n\nthis.bindMatrixInverse.getInverse(this.bindMatrix);\n\n}else{\n\nconsole.warn('THREE.SkinnedMesh unrecognized bindMode: '+this.bindMode);\n\n}\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor(this.geometry,this.material,this.skeleton.useVertexTexture).copy(this);\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *  linecap: \"round\",\n\t *  linejoin: \"round\"\n\t * }\n\t */\n\nfunction LineBasicMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='LineBasicMaterial';\n\nthis.color=new Color(0xffffff);\n\nthis.linewidth=1;\nthis.linecap='round';\nthis.linejoin='round';\n\nthis.lights=false;\n\nthis.setValues(parameters);\n\n}\n\nLineBasicMaterial.prototype=Object.create(Material.prototype);\nLineBasicMaterial.prototype.constructor=LineBasicMaterial;\n\nLineBasicMaterial.prototype.isLineBasicMaterial=true;\n\nLineBasicMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.color.copy(source.color);\n\nthis.linewidth=source.linewidth;\nthis.linecap=source.linecap;\nthis.linejoin=source.linejoin;\n\nreturn this;\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Line(geometry,material,mode){\n\nif(mode===1){\n\nconsole.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');\nreturn new LineSegments(geometry,material);\n\n}\n\nObject3D.call(this);\n\nthis.type='Line';\n\nthis.geometry=geometry!==undefined?geometry:new BufferGeometry();\nthis.material=material!==undefined?material:new LineBasicMaterial({color:Math.random()*0xffffff});\n\n}\n\nLine.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:Line,\n\nisLine:true,\n\nraycast:function(){\n\nvar inverseMatrix=new Matrix4();\nvar ray=new Ray();\nvar sphere=new Sphere();\n\nreturn function raycast(raycaster,intersects){\n\nvar precision=raycaster.linePrecision;\nvar precisionSq=precision*precision;\n\nvar geometry=this.geometry;\nvar matrixWorld=this.matrixWorld;\n\n// Checking boundingSphere distance to ray\n\nif(geometry.boundingSphere===null)geometry.computeBoundingSphere();\n\nsphere.copy(geometry.boundingSphere);\nsphere.applyMatrix4(matrixWorld);\n\nif(raycaster.ray.intersectsSphere(sphere)===false)return;\n\n//\n\ninverseMatrix.getInverse(matrixWorld);\nray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n\nvar vStart=new Vector3();\nvar vEnd=new Vector3();\nvar interSegment=new Vector3();\nvar interRay=new Vector3();\nvar step=this&&this.isLineSegments?2:1;\n\nif(geometry.isBufferGeometry){\n\nvar index=geometry.index;\nvar attributes=geometry.attributes;\nvar positions=attributes.position.array;\n\nif(index!==null){\n\nvar indices=index.array;\n\nfor(var i=0,l=indices.length-1;i<l;i+=step){\n\nvar a=indices[i];\nvar b=indices[i+1];\n\nvStart.fromArray(positions,a*3);\nvEnd.fromArray(positions,b*3);\n\nvar distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);\n\nif(distSq>precisionSq)continue;\n\ninterRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation\n\nvar distance=raycaster.ray.origin.distanceTo(interRay);\n\nif(distance<raycaster.near||distance>raycaster.far)continue;\n\nintersects.push({\n\ndistance:distance,\n// What do we want? intersection point on the ray or on the segment??\n// point: raycaster.ray.at( distance ),\npoint:interSegment.clone().applyMatrix4(this.matrixWorld),\nindex:i,\nface:null,\nfaceIndex:null,\nobject:this});\n\n\n\n}\n\n}else{\n\nfor(var i=0,l=positions.length/3-1;i<l;i+=step){\n\nvStart.fromArray(positions,3*i);\nvEnd.fromArray(positions,3*i+3);\n\nvar distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);\n\nif(distSq>precisionSq)continue;\n\ninterRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation\n\nvar distance=raycaster.ray.origin.distanceTo(interRay);\n\nif(distance<raycaster.near||distance>raycaster.far)continue;\n\nintersects.push({\n\ndistance:distance,\n// What do we want? intersection point on the ray or on the segment??\n// point: raycaster.ray.at( distance ),\npoint:interSegment.clone().applyMatrix4(this.matrixWorld),\nindex:i,\nface:null,\nfaceIndex:null,\nobject:this});\n\n\n\n}\n\n}\n\n}else if(geometry.isGeometry){\n\nvar vertices=geometry.vertices;\nvar nbVertices=vertices.length;\n\nfor(var i=0;i<nbVertices-1;i+=step){\n\nvar distSq=ray.distanceSqToSegment(vertices[i],vertices[i+1],interRay,interSegment);\n\nif(distSq>precisionSq)continue;\n\ninterRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation\n\nvar distance=raycaster.ray.origin.distanceTo(interRay);\n\nif(distance<raycaster.near||distance>raycaster.far)continue;\n\nintersects.push({\n\ndistance:distance,\n// What do we want? intersection point on the ray or on the segment??\n// point: raycaster.ray.at( distance ),\npoint:interSegment.clone().applyMatrix4(this.matrixWorld),\nindex:i,\nface:null,\nfaceIndex:null,\nobject:this});\n\n\n\n}\n\n}\n\n};\n\n}(),\n\nclone:function clone(){\n\nreturn new this.constructor(this.geometry,this.material).copy(this);\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction LineSegments(geometry,material){\n\nLine.call(this,geometry,material);\n\nthis.type='LineSegments';\n\n}\n\nLineSegments.prototype=Object.assign(Object.create(Line.prototype),{\n\nconstructor:LineSegments,\n\nisLineSegments:true});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  size: <float>,\n\t *  sizeAttenuation: <bool>\n\t * }\n\t */\n\nfunction PointsMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='PointsMaterial';\n\nthis.color=new Color(0xffffff);\n\nthis.map=null;\n\nthis.size=1;\nthis.sizeAttenuation=true;\n\nthis.lights=false;\n\nthis.setValues(parameters);\n\n}\n\nPointsMaterial.prototype=Object.create(Material.prototype);\nPointsMaterial.prototype.constructor=PointsMaterial;\n\nPointsMaterial.prototype.isPointsMaterial=true;\n\nPointsMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.color.copy(source.color);\n\nthis.map=source.map;\n\nthis.size=source.size;\nthis.sizeAttenuation=source.sizeAttenuation;\n\nreturn this;\n\n};\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction Points(geometry,material){\n\nObject3D.call(this);\n\nthis.type='Points';\n\nthis.geometry=geometry!==undefined?geometry:new BufferGeometry();\nthis.material=material!==undefined?material:new PointsMaterial({color:Math.random()*0xffffff});\n\n}\n\nPoints.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:Points,\n\nisPoints:true,\n\nraycast:function(){\n\nvar inverseMatrix=new Matrix4();\nvar ray=new Ray();\nvar sphere=new Sphere();\n\nreturn function raycast(raycaster,intersects){\n\nvar object=this;\nvar geometry=this.geometry;\nvar matrixWorld=this.matrixWorld;\nvar threshold=raycaster.params.Points.threshold;\n\n// Checking boundingSphere distance to ray\n\nif(geometry.boundingSphere===null)geometry.computeBoundingSphere();\n\nsphere.copy(geometry.boundingSphere);\nsphere.applyMatrix4(matrixWorld);\n\nif(raycaster.ray.intersectsSphere(sphere)===false)return;\n\n//\n\ninverseMatrix.getInverse(matrixWorld);\nray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n\nvar localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);\nvar localThresholdSq=localThreshold*localThreshold;\nvar position=new Vector3();\n\nfunction testPoint(point,index){\n\nvar rayPointDistanceSq=ray.distanceSqToPoint(point);\n\nif(rayPointDistanceSq<localThresholdSq){\n\nvar intersectPoint=ray.closestPointToPoint(point);\nintersectPoint.applyMatrix4(matrixWorld);\n\nvar distance=raycaster.ray.origin.distanceTo(intersectPoint);\n\nif(distance<raycaster.near||distance>raycaster.far)return;\n\nintersects.push({\n\ndistance:distance,\ndistanceToRay:Math.sqrt(rayPointDistanceSq),\npoint:intersectPoint.clone(),\nindex:index,\nface:null,\nobject:object});\n\n\n\n}\n\n}\n\nif(geometry.isBufferGeometry){\n\nvar index=geometry.index;\nvar attributes=geometry.attributes;\nvar positions=attributes.position.array;\n\nif(index!==null){\n\nvar indices=index.array;\n\nfor(var i=0,il=indices.length;i<il;i++){\n\nvar a=indices[i];\n\nposition.fromArray(positions,a*3);\n\ntestPoint(position,a);\n\n}\n\n}else{\n\nfor(var i=0,l=positions.length/3;i<l;i++){\n\nposition.fromArray(positions,i*3);\n\ntestPoint(position,i);\n\n}\n\n}\n\n}else{\n\nvar vertices=geometry.vertices;\n\nfor(var i=0,l=vertices.length;i<l;i++){\n\ntestPoint(vertices[i],i);\n\n}\n\n}\n\n};\n\n}(),\n\nclone:function clone(){\n\nreturn new this.constructor(this.geometry,this.material).copy(this);\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Group(){\n\nObject3D.call(this);\n\nthis.type='Group';\n\n}\n\nGroup.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:Group});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction VideoTexture(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){\n\nTexture.call(this,video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);\n\nthis.generateMipmaps=false;\n\nvar scope=this;\n\nfunction update(){\n\nrequestAnimationFrame(update);\n\nif(video.readyState>=video.HAVE_CURRENT_DATA){\n\nscope.needsUpdate=true;\n\n}\n\n}\n\nupdate();\n\n}\n\nVideoTexture.prototype=Object.create(Texture.prototype);\nVideoTexture.prototype.constructor=VideoTexture;\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction CompressedTexture(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){\n\nTexture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);\n\nthis.image={width:width,height:height};\nthis.mipmaps=mipmaps;\n\n// no flipping for cube textures\n// (also flipping doesn't work for compressed textures )\n\nthis.flipY=false;\n\n// can't generate mipmaps for compressed textures\n// mips must be embedded in DDS files\n\nthis.generateMipmaps=false;\n\n}\n\nCompressedTexture.prototype=Object.create(Texture.prototype);\nCompressedTexture.prototype.constructor=CompressedTexture;\n\nCompressedTexture.prototype.isCompressedTexture=true;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction CanvasTexture(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){\n\nTexture.call(this,canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);\n\nthis.needsUpdate=true;\n\n}\n\nCanvasTexture.prototype=Object.create(Texture.prototype);\nCanvasTexture.prototype.constructor=CanvasTexture;\n\n/**\n\t * @author Matt DesLauriers / @mattdesl\n\t * @author atix / arthursilber.de\n\t */\n\nfunction DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){\n\nformat=format!==undefined?format:DepthFormat;\n\nif(format!==DepthFormat&&format!==DepthStencilFormat){\n\nthrow new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');\n\n}\n\nif(type===undefined&&format===DepthFormat)type=UnsignedShortType;\nif(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;\n\nTexture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);\n\nthis.image={width:width,height:height};\n\nthis.magFilter=magFilter!==undefined?magFilter:NearestFilter;\nthis.minFilter=minFilter!==undefined?minFilter:NearestFilter;\n\nthis.flipY=false;\nthis.generateMipmaps=false;\n\n}\n\nDepthTexture.prototype=Object.create(Texture.prototype);\nDepthTexture.prototype.constructor=DepthTexture;\nDepthTexture.prototype.isDepthTexture=true;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction WireframeGeometry(geometry){\n\nBufferGeometry.call(this);\n\nthis.type='WireframeGeometry';\n\n// buffer\n\nvar vertices=[];\n\n// helper variables\n\nvar i,j,l,o,ol;\nvar edge=[0,0],edges={},e;\nvar key,keys=['a','b','c'];\nvar vertex;\n\n// different logic for Geometry and BufferGeometry\n\nif(geometry&&geometry.isGeometry){\n\n// create a data structure that contains all edges without duplicates\n\nvar faces=geometry.faces;\n\nfor(i=0,l=faces.length;i<l;i++){\n\nvar face=faces[i];\n\nfor(j=0;j<3;j++){\n\nedge[0]=face[keys[j]];\nedge[1]=face[keys[(j+1)%3]];\nedge.sort(sortFunction);// sorting prevents duplicates\n\nkey=edge.toString();\n\nif(edges[key]===undefined){\n\nedges[key]={index1:edge[0],index2:edge[1]};\n\n}\n\n}\n\n}\n\n// generate vertices\n\nfor(key in edges){\n\ne=edges[key];\n\nvertex=geometry.vertices[e.index1];\nvertices.push(vertex.x,vertex.y,vertex.z);\n\nvertex=geometry.vertices[e.index2];\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n}\n\n}else if(geometry&&geometry.isBufferGeometry){\n\nvar position,indices,groups;\nvar group,start,count;\nvar index1,index2;\n\nvertex=new Vector3();\n\nif(geometry.index!==null){\n\n// indexed BufferGeometry\n\nposition=geometry.attributes.position;\nindices=geometry.index;\ngroups=geometry.groups;\n\nif(groups.length===0){\n\ngeometry.addGroup(0,indices.count);\n\n}\n\n// create a data structure that contains all eges without duplicates\n\nfor(o=0,ol=groups.length;o<ol;++o){\n\ngroup=groups[o];\n\nstart=group.start;\ncount=group.count;\n\nfor(i=start,l=start+count;i<l;i+=3){\n\nfor(j=0;j<3;j++){\n\nedge[0]=indices.getX(i+j);\nedge[1]=indices.getX(i+(j+1)%3);\nedge.sort(sortFunction);// sorting prevents duplicates\n\nkey=edge.toString();\n\nif(edges[key]===undefined){\n\nedges[key]={index1:edge[0],index2:edge[1]};\n\n}\n\n}\n\n}\n\n}\n\n// generate vertices\n\nfor(key in edges){\n\ne=edges[key];\n\nvertex.fromBufferAttribute(position,e.index1);\nvertices.push(vertex.x,vertex.y,vertex.z);\n\nvertex.fromBufferAttribute(position,e.index2);\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n}\n\n}else{\n\n// non-indexed BufferGeometry\n\nposition=geometry.attributes.position;\n\nfor(i=0,l=position.count/3;i<l;i++){\n\nfor(j=0;j<3;j++){\n\n// three edges per triangle, an edge is represented as (index1, index2)\n// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\nindex1=3*i+j;\nvertex.fromBufferAttribute(position,index1);\nvertices.push(vertex.x,vertex.y,vertex.z);\n\nindex2=3*i+(j+1)%3;\nvertex.fromBufferAttribute(position,index2);\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n}\n\n}\n\n}\n\n}\n\n// build geometry\n\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\n\n// custom array sort function\n\nfunction sortFunction(a,b){\n\nreturn a-b;\n\n}\n\n}\n\nWireframeGeometry.prototype=Object.create(BufferGeometry.prototype);\nWireframeGeometry.prototype.constructor=WireframeGeometry;\n\n/**\n\t * @author zz85 / https://github.com/zz85\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\nfunction ParametricGeometry(func,slices,stacks){\n\nGeometry.call(this);\n\nthis.type='ParametricGeometry';\n\nthis.parameters={\nfunc:func,\nslices:slices,\nstacks:stacks};\n\n\nthis.fromBufferGeometry(new ParametricBufferGeometry(func,slices,stacks));\nthis.mergeVertices();\n\n}\n\nParametricGeometry.prototype=Object.create(Geometry.prototype);\nParametricGeometry.prototype.constructor=ParametricGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n\t */\n\nfunction ParametricBufferGeometry(func,slices,stacks){\n\nBufferGeometry.call(this);\n\nthis.type='ParametricBufferGeometry';\n\nthis.parameters={\nfunc:func,\nslices:slices,\nstacks:stacks};\n\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar uvs=[];\n\nvar i,j;\n\n// generate vertices and uvs\n\nvar sliceCount=slices+1;\n\nfor(i=0;i<=stacks;i++){\n\nvar v=i/stacks;\n\nfor(j=0;j<=slices;j++){\n\nvar u=j/slices;\n\nvar p=func(u,v);\nvertices.push(p.x,p.y,p.z);\n\nuvs.push(u,v);\n\n}\n\n}\n\n// generate indices\n\nfor(i=0;i<stacks;i++){\n\nfor(j=0;j<slices;j++){\n\nvar a=i*sliceCount+j;\nvar b=i*sliceCount+j+1;\nvar c=(i+1)*sliceCount+j+1;\nvar d=(i+1)*sliceCount+j;\n\n// faces one and two\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n}\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n// generate normals\n\nthis.computeVertexNormals();\n\n}\n\nParametricBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry;\n\n/**\n\t * @author clockworkgeek / https://github.com/clockworkgeek\n\t * @author timothypratley / https://github.com/timothypratley\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\nfunction PolyhedronGeometry(vertices,indices,radius,detail){\n\nGeometry.call(this);\n\nthis.type='PolyhedronGeometry';\n\nthis.parameters={\nvertices:vertices,\nindices:indices,\nradius:radius,\ndetail:detail};\n\n\nthis.fromBufferGeometry(new PolyhedronBufferGeometry(vertices,indices,radius,detail));\nthis.mergeVertices();\n\n}\n\nPolyhedronGeometry.prototype=Object.create(Geometry.prototype);\nPolyhedronGeometry.prototype.constructor=PolyhedronGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction PolyhedronBufferGeometry(vertices,indices,radius,detail){\n\nBufferGeometry.call(this);\n\nthis.type='PolyhedronBufferGeometry';\n\nthis.parameters={\nvertices:vertices,\nindices:indices,\nradius:radius,\ndetail:detail};\n\n\nradius=radius||1;\ndetail=detail||0;\n\n// default buffer data\n\nvar vertexBuffer=[];\nvar uvBuffer=[];\n\n// the subdivision creates the vertex buffer data\n\nsubdivide(detail);\n\n// all vertices should lie on a conceptual sphere with a given radius\n\nappplyRadius(radius);\n\n// finally, create the uv data\n\ngenerateUVs();\n\n// build non-indexed geometry\n\nthis.addAttribute('position',new Float32BufferAttribute(vertexBuffer,3));\nthis.addAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvBuffer,2));\nthis.normalizeNormals();\n\n// helper functions\n\nfunction subdivide(detail){\n\nvar a=new Vector3();\nvar b=new Vector3();\nvar c=new Vector3();\n\n// iterate over all faces and apply a subdivison with the given detail value\n\nfor(var i=0;i<indices.length;i+=3){\n\n// get the vertices of the face\n\ngetVertexByIndex(indices[i+0],a);\ngetVertexByIndex(indices[i+1],b);\ngetVertexByIndex(indices[i+2],c);\n\n// perform subdivision\n\nsubdivideFace(a,b,c,detail);\n\n}\n\n}\n\nfunction subdivideFace(a,b,c,detail){\n\nvar cols=Math.pow(2,detail);\n\n// we use this multidimensional array as a data structure for creating the subdivision\n\nvar v=[];\n\nvar i,j;\n\n// construct all of the vertices for this subdivision\n\nfor(i=0;i<=cols;i++){\n\nv[i]=[];\n\nvar aj=a.clone().lerp(c,i/cols);\nvar bj=b.clone().lerp(c,i/cols);\n\nvar rows=cols-i;\n\nfor(j=0;j<=rows;j++){\n\nif(j===0&&i===cols){\n\nv[i][j]=aj;\n\n}else{\n\nv[i][j]=aj.clone().lerp(bj,j/rows);\n\n}\n\n}\n\n}\n\n// construct all of the faces\n\nfor(i=0;i<cols;i++){\n\nfor(j=0;j<2*(cols-i)-1;j++){\n\nvar k=Math.floor(j/2);\n\nif(j%2===0){\n\npushVertex(v[i][k+1]);\npushVertex(v[i+1][k]);\npushVertex(v[i][k]);\n\n}else{\n\npushVertex(v[i][k+1]);\npushVertex(v[i+1][k+1]);\npushVertex(v[i+1][k]);\n\n}\n\n}\n\n}\n\n}\n\nfunction appplyRadius(radius){\n\nvar vertex=new Vector3();\n\n// iterate over the entire buffer and apply the radius to each vertex\n\nfor(var i=0;i<vertexBuffer.length;i+=3){\n\nvertex.x=vertexBuffer[i+0];\nvertex.y=vertexBuffer[i+1];\nvertex.z=vertexBuffer[i+2];\n\nvertex.normalize().multiplyScalar(radius);\n\nvertexBuffer[i+0]=vertex.x;\nvertexBuffer[i+1]=vertex.y;\nvertexBuffer[i+2]=vertex.z;\n\n}\n\n}\n\nfunction generateUVs(){\n\nvar vertex=new Vector3();\n\nfor(var i=0;i<vertexBuffer.length;i+=3){\n\nvertex.x=vertexBuffer[i+0];\nvertex.y=vertexBuffer[i+1];\nvertex.z=vertexBuffer[i+2];\n\nvar u=azimuth(vertex)/2/Math.PI+0.5;\nvar v=inclination(vertex)/Math.PI+0.5;\nuvBuffer.push(u,1-v);\n\n}\n\ncorrectUVs();\n\ncorrectSeam();\n\n}\n\nfunction correctSeam(){\n\n// handle case when face straddles the seam, see #3269\n\nfor(var i=0;i<uvBuffer.length;i+=6){\n\n// uv data of a single face\n\nvar x0=uvBuffer[i+0];\nvar x1=uvBuffer[i+2];\nvar x2=uvBuffer[i+4];\n\nvar max=Math.max(x0,x1,x2);\nvar min=Math.min(x0,x1,x2);\n\n// 0.9 is somewhat arbitrary\n\nif(max>0.9&&min<0.1){\n\nif(x0<0.2)uvBuffer[i+0]+=1;\nif(x1<0.2)uvBuffer[i+2]+=1;\nif(x2<0.2)uvBuffer[i+4]+=1;\n\n}\n\n}\n\n}\n\nfunction pushVertex(vertex){\n\nvertexBuffer.push(vertex.x,vertex.y,vertex.z);\n\n}\n\nfunction getVertexByIndex(index,vertex){\n\nvar stride=index*3;\n\nvertex.x=vertices[stride+0];\nvertex.y=vertices[stride+1];\nvertex.z=vertices[stride+2];\n\n}\n\nfunction correctUVs(){\n\nvar a=new Vector3();\nvar b=new Vector3();\nvar c=new Vector3();\n\nvar centroid=new Vector3();\n\nvar uvA=new Vector2();\nvar uvB=new Vector2();\nvar uvC=new Vector2();\n\nfor(var i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){\n\na.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);\nb.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);\nc.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);\n\nuvA.set(uvBuffer[j+0],uvBuffer[j+1]);\nuvB.set(uvBuffer[j+2],uvBuffer[j+3]);\nuvC.set(uvBuffer[j+4],uvBuffer[j+5]);\n\ncentroid.copy(a).add(b).add(c).divideScalar(3);\n\nvar azi=azimuth(centroid);\n\ncorrectUV(uvA,j+0,a,azi);\ncorrectUV(uvB,j+2,b,azi);\ncorrectUV(uvC,j+4,c,azi);\n\n}\n\n}\n\nfunction correctUV(uv,stride,vector,azimuth){\n\nif(azimuth<0&&uv.x===1){\n\nuvBuffer[stride]=uv.x-1;\n\n}\n\nif(vector.x===0&&vector.z===0){\n\nuvBuffer[stride]=azimuth/2/Math.PI+0.5;\n\n}\n\n}\n\n// Angle around the Y axis, counter-clockwise when looking from above.\n\nfunction azimuth(vector){\n\nreturn Math.atan2(vector.z,-vector.x);\n\n}\n\n\n// Angle above the XZ plane.\n\nfunction inclination(vector){\n\nreturn Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));\n\n}\n\n}\n\nPolyhedronBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nPolyhedronBufferGeometry.prototype.constructor=PolyhedronBufferGeometry;\n\n/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\nfunction TetrahedronGeometry(radius,detail){\n\nGeometry.call(this);\n\nthis.type='TetrahedronGeometry';\n\nthis.parameters={\nradius:radius,\ndetail:detail};\n\n\nthis.fromBufferGeometry(new TetrahedronBufferGeometry(radius,detail));\nthis.mergeVertices();\n\n}\n\nTetrahedronGeometry.prototype=Object.create(Geometry.prototype);\nTetrahedronGeometry.prototype.constructor=TetrahedronGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction TetrahedronBufferGeometry(radius,detail){\n\nvar vertices=[\n1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];\n\n\nvar indices=[\n2,1,0,0,3,2,1,3,0,2,3,1];\n\n\nPolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);\n\nthis.type='TetrahedronBufferGeometry';\n\nthis.parameters={\nradius:radius,\ndetail:detail};\n\n\n}\n\nTetrahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);\nTetrahedronBufferGeometry.prototype.constructor=TetrahedronBufferGeometry;\n\n/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\nfunction OctahedronGeometry(radius,detail){\n\nGeometry.call(this);\n\nthis.type='OctahedronGeometry';\n\nthis.parameters={\nradius:radius,\ndetail:detail};\n\n\nthis.fromBufferGeometry(new OctahedronBufferGeometry(radius,detail));\nthis.mergeVertices();\n\n}\n\nOctahedronGeometry.prototype=Object.create(Geometry.prototype);\nOctahedronGeometry.prototype.constructor=OctahedronGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction OctahedronBufferGeometry(radius,detail){\n\nvar vertices=[\n1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];\n\n\nvar indices=[\n0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];\n\n\nPolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);\n\nthis.type='OctahedronBufferGeometry';\n\nthis.parameters={\nradius:radius,\ndetail:detail};\n\n\n}\n\nOctahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);\nOctahedronBufferGeometry.prototype.constructor=OctahedronBufferGeometry;\n\n/**\n\t * @author timothypratley / https://github.com/timothypratley\n\t */\n\nfunction IcosahedronGeometry(radius,detail){\n\nGeometry.call(this);\n\nthis.type='IcosahedronGeometry';\n\nthis.parameters={\nradius:radius,\ndetail:detail};\n\n\nthis.fromBufferGeometry(new IcosahedronBufferGeometry(radius,detail));\nthis.mergeVertices();\n\n}\n\nIcosahedronGeometry.prototype=Object.create(Geometry.prototype);\nIcosahedronGeometry.prototype.constructor=IcosahedronGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction IcosahedronBufferGeometry(radius,detail){\n\nvar t=(1+Math.sqrt(5))/2;\n\nvar vertices=[\n-1,t,0,1,t,0,-1,-t,0,1,-t,0,\n0,-1,t,0,1,t,0,-1,-t,0,1,-t,\nt,0,-1,t,0,1,-t,0,-1,-t,0,1];\n\n\nvar indices=[\n0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,\n1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,\n3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,\n4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];\n\n\nPolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);\n\nthis.type='IcosahedronBufferGeometry';\n\nthis.parameters={\nradius:radius,\ndetail:detail};\n\n\n}\n\nIcosahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);\nIcosahedronBufferGeometry.prototype.constructor=IcosahedronBufferGeometry;\n\n/**\n\t * @author Abe Pazos / https://hamoid.com\n\t */\n\nfunction DodecahedronGeometry(radius,detail){\n\nGeometry.call(this);\n\nthis.type='DodecahedronGeometry';\n\nthis.parameters={\nradius:radius,\ndetail:detail};\n\n\nthis.fromBufferGeometry(new DodecahedronBufferGeometry(radius,detail));\nthis.mergeVertices();\n\n}\n\nDodecahedronGeometry.prototype=Object.create(Geometry.prototype);\nDodecahedronGeometry.prototype.constructor=DodecahedronGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction DodecahedronBufferGeometry(radius,detail){\n\nvar t=(1+Math.sqrt(5))/2;\nvar r=1/t;\n\nvar vertices=[\n\n// (±1, ±1, ±1)\n-1,-1,-1,-1,-1,1,\n-1,1,-1,-1,1,1,\n1,-1,-1,1,-1,1,\n1,1,-1,1,1,1,\n\n// (0, ±1/φ, ±φ)\n0,-r,-t,0,-r,t,\n0,r,-t,0,r,t,\n\n// (±1/φ, ±φ, 0)\n-r,-t,0,-r,t,0,\nr,-t,0,r,t,0,\n\n// (±φ, 0, ±1/φ)\n-t,0,-r,t,0,-r,\n-t,0,r,t,0,r];\n\n\nvar indices=[\n3,11,7,3,7,15,3,15,13,\n7,19,17,7,17,6,7,6,15,\n17,4,8,17,8,10,17,10,6,\n8,0,16,8,16,2,8,2,10,\n0,12,1,0,1,18,0,18,16,\n6,10,2,6,2,13,6,13,15,\n2,16,18,2,18,3,2,3,13,\n18,1,9,18,9,11,18,11,3,\n4,14,12,4,12,0,4,0,8,\n11,9,5,11,5,19,11,19,7,\n19,5,14,19,14,4,19,4,17,\n1,12,14,1,14,5,1,5,9];\n\n\nPolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);\n\nthis.type='DodecahedronBufferGeometry';\n\nthis.parameters={\nradius:radius,\ndetail:detail};\n\n\n}\n\nDodecahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);\nDodecahedronBufferGeometry.prototype.constructor=DodecahedronBufferGeometry;\n\n/**\n\t * @author oosmoxiecode / https://github.com/oosmoxiecode\n\t * @author WestLangley / https://github.com/WestLangley\n\t * @author zz85 / https://github.com/zz85\n\t * @author miningold / https://github.com/miningold\n\t * @author jonobr1 / https://github.com/jonobr1\n\t *\n\t * Creates a tube which extrudes along a 3d spline.\n\t */\n\nfunction TubeGeometry(path,tubularSegments,radius,radialSegments,closed,taper){\n\nGeometry.call(this);\n\nthis.type='TubeGeometry';\n\nthis.parameters={\npath:path,\ntubularSegments:tubularSegments,\nradius:radius,\nradialSegments:radialSegments,\nclosed:closed};\n\n\nif(taper!==undefined)console.warn('THREE.TubeGeometry: taper has been removed.');\n\nvar bufferGeometry=new TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed);\n\n// expose internals\n\nthis.tangents=bufferGeometry.tangents;\nthis.normals=bufferGeometry.normals;\nthis.binormals=bufferGeometry.binormals;\n\n// create geometry\n\nthis.fromBufferGeometry(bufferGeometry);\nthis.mergeVertices();\n\n}\n\nTubeGeometry.prototype=Object.create(Geometry.prototype);\nTubeGeometry.prototype.constructor=TubeGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed){\n\nBufferGeometry.call(this);\n\nthis.type='TubeBufferGeometry';\n\nthis.parameters={\npath:path,\ntubularSegments:tubularSegments,\nradius:radius,\nradialSegments:radialSegments,\nclosed:closed};\n\n\ntubularSegments=tubularSegments||64;\nradius=radius||1;\nradialSegments=radialSegments||8;\nclosed=closed||false;\n\nvar frames=path.computeFrenetFrames(tubularSegments,closed);\n\n// expose internals\n\nthis.tangents=frames.tangents;\nthis.normals=frames.normals;\nthis.binormals=frames.binormals;\n\n// helper variables\n\nvar vertex=new Vector3();\nvar normal=new Vector3();\nvar uv=new Vector2();\n\nvar i,j;\n\n// buffer\n\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\nvar indices=[];\n\n// create buffer data\n\ngenerateBufferData();\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n// functions\n\nfunction generateBufferData(){\n\nfor(i=0;i<tubularSegments;i++){\n\ngenerateSegment(i);\n\n}\n\n// if the geometry is not closed, generate the last row of vertices and normals\n// at the regular position on the given path\n//\n// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\ngenerateSegment(closed===false?tubularSegments:0);\n\n// uvs are generated in a separate function.\n// this makes it easy compute correct values for closed geometries\n\ngenerateUVs();\n\n// finally create faces\n\ngenerateIndices();\n\n}\n\nfunction generateSegment(i){\n\n// we use getPointAt to sample evenly distributed points from the given path\n\nvar P=path.getPointAt(i/tubularSegments);\n\n// retrieve corresponding normal and binormal\n\nvar N=frames.normals[i];\nvar B=frames.binormals[i];\n\n// generate normals and vertices for the current segment\n\nfor(j=0;j<=radialSegments;j++){\n\nvar v=j/radialSegments*Math.PI*2;\n\nvar sin=Math.sin(v);\nvar cos=-Math.cos(v);\n\n// normal\n\nnormal.x=cos*N.x+sin*B.x;\nnormal.y=cos*N.y+sin*B.y;\nnormal.z=cos*N.z+sin*B.z;\nnormal.normalize();\n\nnormals.push(normal.x,normal.y,normal.z);\n\n// vertex\n\nvertex.x=P.x+radius*normal.x;\nvertex.y=P.y+radius*normal.y;\nvertex.z=P.z+radius*normal.z;\n\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n}\n\n}\n\nfunction generateIndices(){\n\nfor(j=1;j<=tubularSegments;j++){\n\nfor(i=1;i<=radialSegments;i++){\n\nvar a=(radialSegments+1)*(j-1)+(i-1);\nvar b=(radialSegments+1)*j+(i-1);\nvar c=(radialSegments+1)*j+i;\nvar d=(radialSegments+1)*(j-1)+i;\n\n// faces\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n}\n\n}\n\n}\n\nfunction generateUVs(){\n\nfor(i=0;i<=tubularSegments;i++){\n\nfor(j=0;j<=radialSegments;j++){\n\nuv.x=i/tubularSegments;\nuv.y=j/radialSegments;\n\nuvs.push(uv.x,uv.y);\n\n}\n\n}\n\n}\n\n}\n\nTubeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nTubeBufferGeometry.prototype.constructor=TubeBufferGeometry;\n\n/**\n\t * @author oosmoxiecode\n\t */\n\nfunction TorusKnotGeometry(radius,tube,tubularSegments,radialSegments,p,q,heightScale){\n\nGeometry.call(this);\n\nthis.type='TorusKnotGeometry';\n\nthis.parameters={\nradius:radius,\ntube:tube,\ntubularSegments:tubularSegments,\nradialSegments:radialSegments,\np:p,\nq:q};\n\n\nif(heightScale!==undefined)console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');\n\nthis.fromBufferGeometry(new TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q));\nthis.mergeVertices();\n\n}\n\nTorusKnotGeometry.prototype=Object.create(Geometry.prototype);\nTorusKnotGeometry.prototype.constructor=TorusKnotGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * see: http://www.blackpawn.com/texts/pqtorus/\n\t */\n\nfunction TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q){\n\nBufferGeometry.call(this);\n\nthis.type='TorusKnotBufferGeometry';\n\nthis.parameters={\nradius:radius,\ntube:tube,\ntubularSegments:tubularSegments,\nradialSegments:radialSegments,\np:p,\nq:q};\n\n\nradius=radius||100;\ntube=tube||40;\ntubularSegments=Math.floor(tubularSegments)||64;\nradialSegments=Math.floor(radialSegments)||8;\np=p||2;\nq=q||3;\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// helper variables\n\nvar i,j;\n\nvar vertex=new Vector3();\nvar normal=new Vector3();\nvar uv=new Vector2();\n\nvar P1=new Vector3();\nvar P2=new Vector3();\n\nvar B=new Vector3();\nvar T=new Vector3();\nvar N=new Vector3();\n\n// generate vertices, normals and uvs\n\nfor(i=0;i<=tubularSegments;++i){\n\n// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\nvar u=i/tubularSegments*p*Math.PI*2;\n\n// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\ncalculatePositionOnCurve(u,p,q,radius,P1);\ncalculatePositionOnCurve(u+0.01,p,q,radius,P2);\n\n// calculate orthonormal basis\n\nT.subVectors(P2,P1);\nN.addVectors(P2,P1);\nB.crossVectors(T,N);\nN.crossVectors(B,T);\n\n// normalize B, N. T can be ignored, we don't use it\n\nB.normalize();\nN.normalize();\n\nfor(j=0;j<=radialSegments;++j){\n\n// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\nvar v=j/radialSegments*Math.PI*2;\nvar cx=-tube*Math.cos(v);\nvar cy=tube*Math.sin(v);\n\n// now calculate the final vertex position.\n// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\nvertex.x=P1.x+(cx*N.x+cy*B.x);\nvertex.y=P1.y+(cx*N.y+cy*B.y);\nvertex.z=P1.z+(cx*N.z+cy*B.z);\n\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\nnormal.subVectors(vertex,P1).normalize();\n\nnormals.push(normal.x,normal.y,normal.z);\n\n// uv\n\nuvs.push(i/tubularSegments);\nuvs.push(j/radialSegments);\n\n}\n\n}\n\n// generate indices\n\nfor(j=1;j<=tubularSegments;j++){\n\nfor(i=1;i<=radialSegments;i++){\n\n// indices\n\nvar a=(radialSegments+1)*(j-1)+(i-1);\nvar b=(radialSegments+1)*j+(i-1);\nvar c=(radialSegments+1)*j+i;\nvar d=(radialSegments+1)*(j-1)+i;\n\n// faces\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n}\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n// this function calculates the current position on the torus curve\n\nfunction calculatePositionOnCurve(u,p,q,radius,position){\n\nvar cu=Math.cos(u);\nvar su=Math.sin(u);\nvar quOverP=q/p*u;\nvar cs=Math.cos(quOverP);\n\nposition.x=radius*(2+cs)*0.5*cu;\nposition.y=radius*(2+cs)*su*0.5;\nposition.z=radius*Math.sin(quOverP)*0.5;\n\n}\n\n}\n\nTorusKnotBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nTorusKnotBufferGeometry.prototype.constructor=TorusKnotBufferGeometry;\n\n/**\n\t * @author oosmoxiecode\n\t * @author mrdoob / http://mrdoob.com/\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n\t */\n\nfunction TorusGeometry(radius,tube,radialSegments,tubularSegments,arc){\n\nGeometry.call(this);\n\nthis.type='TorusGeometry';\n\nthis.parameters={\nradius:radius,\ntube:tube,\nradialSegments:radialSegments,\ntubularSegments:tubularSegments,\narc:arc};\n\n\nthis.fromBufferGeometry(new TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc));\n\n}\n\nTorusGeometry.prototype=Object.create(Geometry.prototype);\nTorusGeometry.prototype.constructor=TorusGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc){\n\nBufferGeometry.call(this);\n\nthis.type='TorusBufferGeometry';\n\nthis.parameters={\nradius:radius,\ntube:tube,\nradialSegments:radialSegments,\ntubularSegments:tubularSegments,\narc:arc};\n\n\nradius=radius||100;\ntube=tube||40;\nradialSegments=Math.floor(radialSegments)||8;\ntubularSegments=Math.floor(tubularSegments)||6;\narc=arc||Math.PI*2;\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// helper variables\n\nvar center=new Vector3();\nvar vertex=new Vector3();\nvar normal=new Vector3();\n\nvar j,i;\n\n// generate vertices, normals and uvs\n\nfor(j=0;j<=radialSegments;j++){\n\nfor(i=0;i<=tubularSegments;i++){\n\nvar u=i/tubularSegments*arc;\nvar v=j/radialSegments*Math.PI*2;\n\n// vertex\n\nvertex.x=(radius+tube*Math.cos(v))*Math.cos(u);\nvertex.y=(radius+tube*Math.cos(v))*Math.sin(u);\nvertex.z=tube*Math.sin(v);\n\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n// normal\n\ncenter.x=radius*Math.cos(u);\ncenter.y=radius*Math.sin(u);\nnormal.subVectors(vertex,center).normalize();\n\nnormals.push(normal.x,normal.y,normal.z);\n\n// uv\n\nuvs.push(i/tubularSegments);\nuvs.push(j/radialSegments);\n\n}\n\n}\n\n// generate indices\n\nfor(j=1;j<=radialSegments;j++){\n\nfor(i=1;i<=tubularSegments;i++){\n\n// indices\n\nvar a=(tubularSegments+1)*j+i-1;\nvar b=(tubularSegments+1)*(j-1)+i-1;\nvar c=(tubularSegments+1)*(j-1)+i;\nvar d=(tubularSegments+1)*j+i;\n\n// faces\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n}\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n}\n\nTorusBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nTorusBufferGeometry.prototype.constructor=TorusBufferGeometry;\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t */\n\nvar ShapeUtils={\n\n// calculate area of the contour polygon\n\narea:function area(contour){\n\nvar n=contour.length;\nvar a=0.0;\n\nfor(var p=n-1,q=0;q<n;p=q++){\n\na+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;\n\n}\n\nreturn a*0.5;\n\n},\n\ntriangulate:function(){\n\n/**\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\n\t\t\t * See original code and more information here:\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n\t\t\t *\n\t\t\t * ported to actionscript by Zevan Rosser\n\t\t\t * www.actionsnippet.com\n\t\t\t *\n\t\t\t * ported to javascript by Joshua Koo\n\t\t\t * http://www.lab4games.net/zz85/blog\n\t\t\t *\n\t\t\t */\n\nfunction snip(contour,u,v,w,n,verts){\n\nvar p;\nvar ax,ay,bx,by;\nvar cx,cy,px,py;\n\nax=contour[verts[u]].x;\nay=contour[verts[u]].y;\n\nbx=contour[verts[v]].x;\nby=contour[verts[v]].y;\n\ncx=contour[verts[w]].x;\ncy=contour[verts[w]].y;\n\nif((bx-ax)*(cy-ay)-(by-ay)*(cx-ax)<=0)return false;\n\nvar aX,aY,bX,bY,cX,cY;\nvar apx,apy,bpx,bpy,cpx,cpy;\nvar cCROSSap,bCROSScp,aCROSSbp;\n\naX=cx-bx;aY=cy-by;\nbX=ax-cx;bY=ay-cy;\ncX=bx-ax;cY=by-ay;\n\nfor(p=0;p<n;p++){\n\npx=contour[verts[p]].x;\npy=contour[verts[p]].y;\n\nif(px===ax&&py===ay||\npx===bx&&py===by||\npx===cx&&py===cy)continue;\n\napx=px-ax;apy=py-ay;\nbpx=px-bx;bpy=py-by;\ncpx=px-cx;cpy=py-cy;\n\n// see if p is inside triangle abc\n\naCROSSbp=aX*bpy-aY*bpx;\ncCROSSap=cX*apy-cY*apx;\nbCROSScp=bX*cpy-bY*cpx;\n\nif(aCROSSbp>=-Number.EPSILON&&bCROSScp>=-Number.EPSILON&&cCROSSap>=-Number.EPSILON)return false;\n\n}\n\nreturn true;\n\n}\n\n// takes in an contour array and returns\n\nreturn function triangulate(contour,indices){\n\nvar n=contour.length;\n\nif(n<3)return null;\n\nvar result=[],\nverts=[],\nvertIndices=[];\n\n/* we want a counter-clockwise polygon in verts */\n\nvar u,v,w;\n\nif(ShapeUtils.area(contour)>0.0){\n\nfor(v=0;v<n;v++){verts[v]=v;}\n\n}else{\n\nfor(v=0;v<n;v++){verts[v]=n-1-v;}\n\n}\n\nvar nv=n;\n\n/*  remove nv - 2 vertices, creating 1 triangle every time */\n\nvar count=2*nv;/* error detection */\n\nfor(v=nv-1;nv>2;){\n\n/* if we loop, it is probably a non-simple polygon */\n\nif(count--<=0){\n\n//** Triangulate: ERROR - probable bad polygon!\n\n//throw ( \"Warning, unable to triangulate polygon!\" );\n//return null;\n// Sometimes warning is fine, especially polygons are triangulated in reverse.\nconsole.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');\n\nif(indices)return vertIndices;\nreturn result;\n\n}\n\n/* three consecutive vertices in current polygon, <u,v,w> */\n\nu=v;if(nv<=u)u=0;/* previous */\nv=u+1;if(nv<=v)v=0;/* new v    */\nw=v+1;if(nv<=w)w=0;/* next     */\n\nif(snip(contour,u,v,w,nv,verts)){\n\nvar a,b,c,s,t;\n\n/* true names of the vertices */\n\na=verts[u];\nb=verts[v];\nc=verts[w];\n\n/* output Triangle */\n\nresult.push([contour[a],\ncontour[b],\ncontour[c]]);\n\n\nvertIndices.push([verts[u],verts[v],verts[w]]);\n\n/* remove v from the remaining polygon */\n\nfor(s=v,t=v+1;t<nv;s++,t++){\n\nverts[s]=verts[t];\n\n}\n\nnv--;\n\n/* reset error detection counter */\n\ncount=2*nv;\n\n}\n\n}\n\nif(indices)return vertIndices;\nreturn result;\n\n};\n\n}(),\n\ntriangulateShape:function triangulateShape(contour,holes){\n\nfunction removeDupEndPts(points){\n\nvar l=points.length;\n\nif(l>2&&points[l-1].equals(points[0])){\n\npoints.pop();\n\n}\n\n}\n\nremoveDupEndPts(contour);\nholes.forEach(removeDupEndPts);\n\nfunction point_in_segment_2D_colin(inSegPt1,inSegPt2,inOtherPt){\n\n// inOtherPt needs to be collinear to the inSegment\nif(inSegPt1.x!==inSegPt2.x){\n\nif(inSegPt1.x<inSegPt2.x){\n\nreturn inSegPt1.x<=inOtherPt.x&&inOtherPt.x<=inSegPt2.x;\n\n}else{\n\nreturn inSegPt2.x<=inOtherPt.x&&inOtherPt.x<=inSegPt1.x;\n\n}\n\n}else{\n\nif(inSegPt1.y<inSegPt2.y){\n\nreturn inSegPt1.y<=inOtherPt.y&&inOtherPt.y<=inSegPt2.y;\n\n}else{\n\nreturn inSegPt2.y<=inOtherPt.y&&inOtherPt.y<=inSegPt1.y;\n\n}\n\n}\n\n}\n\nfunction intersect_segments_2D(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1,inSeg2Pt2,inExcludeAdjacentSegs){\n\nvar seg1dx=inSeg1Pt2.x-inSeg1Pt1.x,seg1dy=inSeg1Pt2.y-inSeg1Pt1.y;\nvar seg2dx=inSeg2Pt2.x-inSeg2Pt1.x,seg2dy=inSeg2Pt2.y-inSeg2Pt1.y;\n\nvar seg1seg2dx=inSeg1Pt1.x-inSeg2Pt1.x;\nvar seg1seg2dy=inSeg1Pt1.y-inSeg2Pt1.y;\n\nvar limit=seg1dy*seg2dx-seg1dx*seg2dy;\nvar perpSeg1=seg1dy*seg1seg2dx-seg1dx*seg1seg2dy;\n\nif(Math.abs(limit)>Number.EPSILON){\n\n// not parallel\n\nvar perpSeg2;\nif(limit>0){\n\nif(perpSeg1<0||perpSeg1>limit)return[];\nperpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;\nif(perpSeg2<0||perpSeg2>limit)return[];\n\n}else{\n\nif(perpSeg1>0||perpSeg1<limit)return[];\nperpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;\nif(perpSeg2>0||perpSeg2<limit)return[];\n\n}\n\n// i.e. to reduce rounding errors\n// intersection at endpoint of segment#1?\nif(perpSeg2===0){\n\nif(inExcludeAdjacentSegs&&(\nperpSeg1===0||perpSeg1===limit))return[];\nreturn[inSeg1Pt1];\n\n}\nif(perpSeg2===limit){\n\nif(inExcludeAdjacentSegs&&(\nperpSeg1===0||perpSeg1===limit))return[];\nreturn[inSeg1Pt2];\n\n}\n// intersection at endpoint of segment#2?\nif(perpSeg1===0)return[inSeg2Pt1];\nif(perpSeg1===limit)return[inSeg2Pt2];\n\n// return real intersection point\nvar factorSeg1=perpSeg2/limit;\nreturn[{x:inSeg1Pt1.x+factorSeg1*seg1dx,\ny:inSeg1Pt1.y+factorSeg1*seg1dy}];\n\n}else{\n\n// parallel or collinear\nif(perpSeg1!==0||\nseg2dy*seg1seg2dx!==seg2dx*seg1seg2dy)return[];\n\n// they are collinear or degenerate\nvar seg1Pt=seg1dx===0&&seg1dy===0;// segment1 is just a point?\nvar seg2Pt=seg2dx===0&&seg2dy===0;// segment2 is just a point?\n// both segments are points\nif(seg1Pt&&seg2Pt){\n\nif(inSeg1Pt1.x!==inSeg2Pt1.x||\ninSeg1Pt1.y!==inSeg2Pt1.y)return[];// they are distinct  points\nreturn[inSeg1Pt1];// they are the same point\n\n}\n// segment#1  is a single point\nif(seg1Pt){\n\nif(!point_in_segment_2D_colin(inSeg2Pt1,inSeg2Pt2,inSeg1Pt1))return[];// but not in segment#2\nreturn[inSeg1Pt1];\n\n}\n// segment#2  is a single point\nif(seg2Pt){\n\nif(!point_in_segment_2D_colin(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1))return[];// but not in segment#1\nreturn[inSeg2Pt1];\n\n}\n\n// they are collinear segments, which might overlap\nvar seg1min,seg1max,seg1minVal,seg1maxVal;\nvar seg2min,seg2max,seg2minVal,seg2maxVal;\nif(seg1dx!==0){\n\n// the segments are NOT on a vertical line\nif(inSeg1Pt1.x<inSeg1Pt2.x){\n\nseg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.x;\nseg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.x;\n\n}else{\n\nseg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.x;\nseg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.x;\n\n}\nif(inSeg2Pt1.x<inSeg2Pt2.x){\n\nseg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.x;\nseg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.x;\n\n}else{\n\nseg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.x;\nseg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.x;\n\n}\n\n}else{\n\n// the segments are on a vertical line\nif(inSeg1Pt1.y<inSeg1Pt2.y){\n\nseg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.y;\nseg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.y;\n\n}else{\n\nseg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.y;\nseg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.y;\n\n}\nif(inSeg2Pt1.y<inSeg2Pt2.y){\n\nseg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.y;\nseg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.y;\n\n}else{\n\nseg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.y;\nseg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.y;\n\n}\n\n}\nif(seg1minVal<=seg2minVal){\n\nif(seg1maxVal<seg2minVal)return[];\nif(seg1maxVal===seg2minVal){\n\nif(inExcludeAdjacentSegs)return[];\nreturn[seg2min];\n\n}\nif(seg1maxVal<=seg2maxVal)return[seg2min,seg1max];\nreturn[seg2min,seg2max];\n\n}else{\n\nif(seg1minVal>seg2maxVal)return[];\nif(seg1minVal===seg2maxVal){\n\nif(inExcludeAdjacentSegs)return[];\nreturn[seg1min];\n\n}\nif(seg1maxVal<=seg2maxVal)return[seg1min,seg1max];\nreturn[seg1min,seg2max];\n\n}\n\n}\n\n}\n\nfunction isPointInsideAngle(inVertex,inLegFromPt,inLegToPt,inOtherPt){\n\n// The order of legs is important\n\n// translation of all points, so that Vertex is at (0,0)\nvar legFromPtX=inLegFromPt.x-inVertex.x,legFromPtY=inLegFromPt.y-inVertex.y;\nvar legToPtX=inLegToPt.x-inVertex.x,legToPtY=inLegToPt.y-inVertex.y;\nvar otherPtX=inOtherPt.x-inVertex.x,otherPtY=inOtherPt.y-inVertex.y;\n\n// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\nvar from2toAngle=legFromPtX*legToPtY-legFromPtY*legToPtX;\nvar from2otherAngle=legFromPtX*otherPtY-legFromPtY*otherPtX;\n\nif(Math.abs(from2toAngle)>Number.EPSILON){\n\n// angle != 180 deg.\n\nvar other2toAngle=otherPtX*legToPtY-otherPtY*legToPtX;\n// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\n\nif(from2toAngle>0){\n\n// main angle < 180 deg.\nreturn from2otherAngle>=0&&other2toAngle>=0;\n\n}else{\n\n// main angle > 180 deg.\nreturn from2otherAngle>=0||other2toAngle>=0;\n\n}\n\n}else{\n\n// angle == 180 deg.\n// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\nreturn from2otherAngle>0;\n\n}\n\n}\n\n\nfunction removeHoles(contour,holes){\n\nvar shape=contour.concat();// work on this shape\nvar hole;\n\nfunction isCutLineInsideAngles(inShapeIdx,inHoleIdx){\n\n// Check if hole point lies within angle around shape point\nvar lastShapeIdx=shape.length-1;\n\nvar prevShapeIdx=inShapeIdx-1;\nif(prevShapeIdx<0)prevShapeIdx=lastShapeIdx;\n\nvar nextShapeIdx=inShapeIdx+1;\nif(nextShapeIdx>lastShapeIdx)nextShapeIdx=0;\n\nvar insideAngle=isPointInsideAngle(shape[inShapeIdx],shape[prevShapeIdx],shape[nextShapeIdx],hole[inHoleIdx]);\nif(!insideAngle){\n\n// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\nreturn false;\n\n}\n\n// Check if shape point lies within angle around hole point\nvar lastHoleIdx=hole.length-1;\n\nvar prevHoleIdx=inHoleIdx-1;\nif(prevHoleIdx<0)prevHoleIdx=lastHoleIdx;\n\nvar nextHoleIdx=inHoleIdx+1;\nif(nextHoleIdx>lastHoleIdx)nextHoleIdx=0;\n\ninsideAngle=isPointInsideAngle(hole[inHoleIdx],hole[prevHoleIdx],hole[nextHoleIdx],shape[inShapeIdx]);\nif(!insideAngle){\n\n// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\nreturn false;\n\n}\n\nreturn true;\n\n}\n\nfunction intersectsShapeEdge(inShapePt,inHolePt){\n\n// checks for intersections with shape edges\nvar sIdx,nextIdx,intersection;\nfor(sIdx=0;sIdx<shape.length;sIdx++){\n\nnextIdx=sIdx+1;nextIdx%=shape.length;\nintersection=intersect_segments_2D(inShapePt,inHolePt,shape[sIdx],shape[nextIdx],true);\nif(intersection.length>0)return true;\n\n}\n\nreturn false;\n\n}\n\nvar indepHoles=[];\n\nfunction intersectsHoleEdge(inShapePt,inHolePt){\n\n// checks for intersections with hole edges\nvar ihIdx,chkHole,\nhIdx,nextIdx,intersection;\nfor(ihIdx=0;ihIdx<indepHoles.length;ihIdx++){\n\nchkHole=holes[indepHoles[ihIdx]];\nfor(hIdx=0;hIdx<chkHole.length;hIdx++){\n\nnextIdx=hIdx+1;nextIdx%=chkHole.length;\nintersection=intersect_segments_2D(inShapePt,inHolePt,chkHole[hIdx],chkHole[nextIdx],true);\nif(intersection.length>0)return true;\n\n}\n\n}\nreturn false;\n\n}\n\nvar holeIndex,shapeIndex,\nshapePt,holePt,\nholeIdx,cutKey,failedCuts=[],\ntmpShape1,tmpShape2,\ntmpHole1,tmpHole2;\n\nfor(var h=0,hl=holes.length;h<hl;h++){\n\nindepHoles.push(h);\n\n}\n\nvar minShapeIndex=0;\nvar counter=indepHoles.length*2;\nwhile(indepHoles.length>0){\n\ncounter--;\nif(counter<0){\n\nconsole.log(\"Infinite Loop! Holes left:\"+indepHoles.length+\", Probably Hole outside Shape!\");\nbreak;\n\n}\n\n// search for shape-vertex and hole-vertex,\n// which can be connected without intersections\nfor(shapeIndex=minShapeIndex;shapeIndex<shape.length;shapeIndex++){\n\nshapePt=shape[shapeIndex];\nholeIndex=-1;\n\n// search for hole which can be reached without intersections\nfor(var h=0;h<indepHoles.length;h++){\n\nholeIdx=indepHoles[h];\n\n// prevent multiple checks\ncutKey=shapePt.x+\":\"+shapePt.y+\":\"+holeIdx;\nif(failedCuts[cutKey]!==undefined)continue;\n\nhole=holes[holeIdx];\nfor(var h2=0;h2<hole.length;h2++){\n\nholePt=hole[h2];\nif(!isCutLineInsideAngles(shapeIndex,h2))continue;\nif(intersectsShapeEdge(shapePt,holePt))continue;\nif(intersectsHoleEdge(shapePt,holePt))continue;\n\nholeIndex=h2;\nindepHoles.splice(h,1);\n\ntmpShape1=shape.slice(0,shapeIndex+1);\ntmpShape2=shape.slice(shapeIndex);\ntmpHole1=hole.slice(holeIndex);\ntmpHole2=hole.slice(0,holeIndex+1);\n\nshape=tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);\n\nminShapeIndex=shapeIndex;\n\n// Debug only, to show the selected cuts\n// glob_CutLines.push( [ shapePt, holePt ] );\n\nbreak;\n\n}\nif(holeIndex>=0)break;// hole-vertex found\n\nfailedCuts[cutKey]=true;// remember failure\n\n}\nif(holeIndex>=0)break;// hole-vertex found\n\n}\n\n}\n\nreturn shape;/* shape with no holes */\n\n}\n\n\nvar i,il,f,face,\nkey,index,\nallPointsMap={};\n\n// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\nvar allpoints=contour.concat();\n\nfor(var h=0,hl=holes.length;h<hl;h++){\n\nArray.prototype.push.apply(allpoints,holes[h]);\n\n}\n\n//console.log( \"allpoints\",allpoints, allpoints.length );\n\n// prepare all points map\n\nfor(i=0,il=allpoints.length;i<il;i++){\n\nkey=allpoints[i].x+\":\"+allpoints[i].y;\n\nif(allPointsMap[key]!==undefined){\n\nconsole.warn(\"THREE.ShapeUtils: Duplicate point\",key,i);\n\n}\n\nallPointsMap[key]=i;\n\n}\n\n// remove holes by cutting paths to holes and adding them to the shape\nvar shapeWithoutHoles=removeHoles(contour,holes);\n\nvar triangles=ShapeUtils.triangulate(shapeWithoutHoles,false);// True returns indices for points of spooled shape\n//console.log( \"triangles\",triangles, triangles.length );\n\n// check all face vertices against all points map\n\nfor(i=0,il=triangles.length;i<il;i++){\n\nface=triangles[i];\n\nfor(f=0;f<3;f++){\n\nkey=face[f].x+\":\"+face[f].y;\n\nindex=allPointsMap[key];\n\nif(index!==undefined){\n\nface[f]=index;\n\n}\n\n}\n\n}\n\nreturn triangles.concat();\n\n},\n\nisClockWise:function isClockWise(pts){\n\nreturn ShapeUtils.area(pts)<0;\n\n}};\n\n\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *  curveSegments: <int>, // number of points on the curves\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *  amount: <int>, // Depth to extrude the shape\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\n\t *  bevelSize: <float>, // how far from shape outline is bevel\n\t *  bevelSegments: <int>, // number of bevel layers\n\t *\n\t *  extrudePath: <THREE.Curve> // curve to extrude shape along\n\t *  frames: <Object> // containing arrays of tangents, normals, binormals\n\t *\n\t *  uvGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t **/\n\nfunction ExtrudeGeometry(shapes,options){\n\nif(typeof shapes===\"undefined\"){\n\nshapes=[];\nreturn;\n\n}\n\nGeometry.call(this);\n\nthis.type='ExtrudeGeometry';\n\nshapes=Array.isArray(shapes)?shapes:[shapes];\n\nthis.addShapeList(shapes,options);\n\nthis.computeFaceNormals();\n\n// can't really use automatic vertex normals\n// as then front and back sides get smoothed too\n// should do separate smoothing just for sides\n\n//this.computeVertexNormals();\n\n//console.log( \"took\", ( Date.now() - startTime ) );\n\n}\n\nExtrudeGeometry.prototype=Object.create(Geometry.prototype);\nExtrudeGeometry.prototype.constructor=ExtrudeGeometry;\n\nExtrudeGeometry.prototype.addShapeList=function(shapes,options){\n\nvar sl=shapes.length;\n\nfor(var s=0;s<sl;s++){\n\nvar shape=shapes[s];\nthis.addShape(shape,options);\n\n}\n\n};\n\nExtrudeGeometry.prototype.addShape=function(shape,options){\n\nvar amount=options.amount!==undefined?options.amount:100;\n\nvar bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;// 10\nvar bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;// 8\nvar bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;\n\nvar bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;// false\n\nvar curveSegments=options.curveSegments!==undefined?options.curveSegments:12;\n\nvar steps=options.steps!==undefined?options.steps:1;\n\nvar extrudePath=options.extrudePath;\nvar extrudePts,extrudeByPath=false;\n\n// Use default WorldUVGenerator if no UV generators are specified.\nvar uvgen=options.UVGenerator!==undefined?options.UVGenerator:ExtrudeGeometry.WorldUVGenerator;\n\nvar splineTube,binormal,normal,position2;\nif(extrudePath){\n\nextrudePts=extrudePath.getSpacedPoints(steps);\n\nextrudeByPath=true;\nbevelEnabled=false;// bevels not supported for path extrusion\n\n// SETUP TNB variables\n\n// TODO1 - have a .isClosed in spline?\n\nsplineTube=options.frames!==undefined?options.frames:extrudePath.computeFrenetFrames(steps,false);\n\n// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\nbinormal=new Vector3();\nnormal=new Vector3();\nposition2=new Vector3();\n\n}\n\n// Safeguards if bevels are not enabled\n\nif(!bevelEnabled){\n\nbevelSegments=0;\nbevelThickness=0;\nbevelSize=0;\n\n}\n\n// Variables initialization\n\nvar ahole,h,hl;// looping of holes\nvar scope=this;\n\nvar shapesOffset=this.vertices.length;\n\nvar shapePoints=shape.extractPoints(curveSegments);\n\nvar vertices=shapePoints.shape;\nvar holes=shapePoints.holes;\n\nvar reverse=!ShapeUtils.isClockWise(vertices);\n\nif(reverse){\n\nvertices=vertices.reverse();\n\n// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\nfor(h=0,hl=holes.length;h<hl;h++){\n\nahole=holes[h];\n\nif(ShapeUtils.isClockWise(ahole)){\n\nholes[h]=ahole.reverse();\n\n}\n\n}\n\nreverse=false;// If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n}\n\n\nvar faces=ShapeUtils.triangulateShape(vertices,holes);\n\n/* Vertices */\n\nvar contour=vertices;// vertices has all points but contour has only points of circumference\n\nfor(h=0,hl=holes.length;h<hl;h++){\n\nahole=holes[h];\n\nvertices=vertices.concat(ahole);\n\n}\n\n\nfunction scalePt2(pt,vec,size){\n\nif(!vec)console.error(\"THREE.ExtrudeGeometry: vec does not exist\");\n\nreturn vec.clone().multiplyScalar(size).add(pt);\n\n}\n\nvar b,bs,t,z,\nvert,vlen=vertices.length,\nface,flen=faces.length;\n\n\n// Find directions for point movement\n\n\nfunction getBevelVec(inPt,inPrev,inNext){\n\n// computes for inPt the corresponding point inPt' on a new contour\n//   shifted by 1 unit (length of normalized vector) to the left\n// if we walk along contour clockwise, this new contour is outside the old one\n//\n// inPt' is the intersection of the two lines parallel to the two\n//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\nvar v_trans_x,v_trans_y,shrink_by=1;// resulting translation vector for inPt\n\n// good reading for geometry algorithms (here: line-line intersection)\n// http://geomalgorithms.com/a05-_intersect-1.html\n\nvar v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;\nvar v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;\n\nvar v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;\n\n// check for collinear edges\nvar collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;\n\nif(Math.abs(collinear0)>Number.EPSILON){\n\n// not collinear\n\n// length of vectors for normalizing\n\nvar v_prev_len=Math.sqrt(v_prev_lensq);\nvar v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);\n\n// shift adjacent points by unit vectors to the left\n\nvar ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;\nvar ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;\n\nvar ptNextShift_x=inNext.x-v_next_y/v_next_len;\nvar ptNextShift_y=inNext.y+v_next_x/v_next_len;\n\n// scaling factor for v_prev to intersection point\n\nvar sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-\n(ptNextShift_y-ptPrevShift_y)*v_next_x)/(\nv_prev_x*v_next_y-v_prev_y*v_next_x);\n\n// vector from inPt to intersection point\n\nv_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;\nv_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;\n\n// Don't normalize!, otherwise sharp corners become ugly\n//  but prevent crazy spikes\nvar v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;\nif(v_trans_lensq<=2){\n\nreturn new Vector2(v_trans_x,v_trans_y);\n\n}else{\n\nshrink_by=Math.sqrt(v_trans_lensq/2);\n\n}\n\n}else{\n\n// handle special case of collinear edges\n\nvar direction_eq=false;// assumes: opposite\nif(v_prev_x>Number.EPSILON){\n\nif(v_next_x>Number.EPSILON){\n\ndirection_eq=true;\n\n}\n\n}else{\n\nif(v_prev_x<-Number.EPSILON){\n\nif(v_next_x<-Number.EPSILON){\n\ndirection_eq=true;\n\n}\n\n}else{\n\nif(Math.sign(v_prev_y)===Math.sign(v_next_y)){\n\ndirection_eq=true;\n\n}\n\n}\n\n}\n\nif(direction_eq){\n\n// console.log(\"Warning: lines are a straight sequence\");\nv_trans_x=-v_prev_y;\nv_trans_y=v_prev_x;\nshrink_by=Math.sqrt(v_prev_lensq);\n\n}else{\n\n// console.log(\"Warning: lines are a straight spike\");\nv_trans_x=v_prev_x;\nv_trans_y=v_prev_y;\nshrink_by=Math.sqrt(v_prev_lensq/2);\n\n}\n\n}\n\nreturn new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);\n\n}\n\n\nvar contourMovements=[];\n\nfor(var i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){\n\nif(j===il)j=0;\nif(k===il)k=0;\n\n//  (j)---(i)---(k)\n// console.log('i,j,k', i, j , k)\n\ncontourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);\n\n}\n\nvar holesMovements=[],oneHoleMovements,verticesMovements=contourMovements.concat();\n\nfor(h=0,hl=holes.length;h<hl;h++){\n\nahole=holes[h];\n\noneHoleMovements=[];\n\nfor(i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){\n\nif(j===il)j=0;\nif(k===il)k=0;\n\n//  (j)---(i)---(k)\noneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);\n\n}\n\nholesMovements.push(oneHoleMovements);\nverticesMovements=verticesMovements.concat(oneHoleMovements);\n\n}\n\n\n// Loop bevelSegments, 1 for the front, 1 for the back\n\nfor(b=0;b<bevelSegments;b++){\n\n//for ( b = bevelSegments; b > 0; b -- ) {\n\nt=b/bevelSegments;\nz=bevelThickness*Math.cos(t*Math.PI/2);\nbs=bevelSize*Math.sin(t*Math.PI/2);\n\n// contract shape\n\nfor(i=0,il=contour.length;i<il;i++){\n\nvert=scalePt2(contour[i],contourMovements[i],bs);\n\nv(vert.x,vert.y,-z);\n\n}\n\n// expand holes\n\nfor(h=0,hl=holes.length;h<hl;h++){\n\nahole=holes[h];\noneHoleMovements=holesMovements[h];\n\nfor(i=0,il=ahole.length;i<il;i++){\n\nvert=scalePt2(ahole[i],oneHoleMovements[i],bs);\n\nv(vert.x,vert.y,-z);\n\n}\n\n}\n\n}\n\nbs=bevelSize;\n\n// Back facing vertices\n\nfor(i=0;i<vlen;i++){\n\nvert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];\n\nif(!extrudeByPath){\n\nv(vert.x,vert.y,0);\n\n}else{\n\n// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\nnormal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\nbinormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n\nposition2.copy(extrudePts[0]).add(normal).add(binormal);\n\nv(position2.x,position2.y,position2.z);\n\n}\n\n}\n\n// Add stepped vertices...\n// Including front facing vertices\n\nvar s;\n\nfor(s=1;s<=steps;s++){\n\nfor(i=0;i<vlen;i++){\n\nvert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];\n\nif(!extrudeByPath){\n\nv(vert.x,vert.y,amount/steps*s);\n\n}else{\n\n// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\nnormal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\nbinormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n\nposition2.copy(extrudePts[s]).add(normal).add(binormal);\n\nv(position2.x,position2.y,position2.z);\n\n}\n\n}\n\n}\n\n\n// Add bevel segments planes\n\n//for ( b = 1; b <= bevelSegments; b ++ ) {\nfor(b=bevelSegments-1;b>=0;b--){\n\nt=b/bevelSegments;\nz=bevelThickness*Math.cos(t*Math.PI/2);\nbs=bevelSize*Math.sin(t*Math.PI/2);\n\n// contract shape\n\nfor(i=0,il=contour.length;i<il;i++){\n\nvert=scalePt2(contour[i],contourMovements[i],bs);\nv(vert.x,vert.y,amount+z);\n\n}\n\n// expand holes\n\nfor(h=0,hl=holes.length;h<hl;h++){\n\nahole=holes[h];\noneHoleMovements=holesMovements[h];\n\nfor(i=0,il=ahole.length;i<il;i++){\n\nvert=scalePt2(ahole[i],oneHoleMovements[i],bs);\n\nif(!extrudeByPath){\n\nv(vert.x,vert.y,amount+z);\n\n}else{\n\nv(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);\n\n}\n\n}\n\n}\n\n}\n\n/* Faces */\n\n// Top and bottom faces\n\nbuildLidFaces();\n\n// Sides faces\n\nbuildSideFaces();\n\n\n/////  Internal functions\n\nfunction buildLidFaces(){\n\nif(bevelEnabled){\n\nvar layer=0;// steps + 1\nvar offset=vlen*layer;\n\n// Bottom faces\n\nfor(i=0;i<flen;i++){\n\nface=faces[i];\nf3(face[2]+offset,face[1]+offset,face[0]+offset);\n\n}\n\nlayer=steps+bevelSegments*2;\noffset=vlen*layer;\n\n// Top faces\n\nfor(i=0;i<flen;i++){\n\nface=faces[i];\nf3(face[0]+offset,face[1]+offset,face[2]+offset);\n\n}\n\n}else{\n\n// Bottom faces\n\nfor(i=0;i<flen;i++){\n\nface=faces[i];\nf3(face[2],face[1],face[0]);\n\n}\n\n// Top faces\n\nfor(i=0;i<flen;i++){\n\nface=faces[i];\nf3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);\n\n}\n\n}\n\n}\n\n// Create faces for the z-sides of the shape\n\nfunction buildSideFaces(){\n\nvar layeroffset=0;\nsidewalls(contour,layeroffset);\nlayeroffset+=contour.length;\n\nfor(h=0,hl=holes.length;h<hl;h++){\n\nahole=holes[h];\nsidewalls(ahole,layeroffset);\n\n//, true\nlayeroffset+=ahole.length;\n\n}\n\n}\n\nfunction sidewalls(contour,layeroffset){\n\nvar j,k;\ni=contour.length;\n\nwhile(--i>=0){\n\nj=i;\nk=i-1;\nif(k<0)k=contour.length-1;\n\n//console.log('b', i,j, i-1, k,vertices.length);\n\nvar s=0,sl=steps+bevelSegments*2;\n\nfor(s=0;s<sl;s++){\n\nvar slen1=vlen*s;\nvar slen2=vlen*(s+1);\n\nvar a=layeroffset+j+slen1,\nb=layeroffset+k+slen1,\nc=layeroffset+k+slen2,\nd=layeroffset+j+slen2;\n\nf4(a,b,c,d,contour,s,sl,j,k);\n\n}\n\n}\n\n}\n\n\nfunction v(x,y,z){\n\nscope.vertices.push(new Vector3(x,y,z));\n\n}\n\nfunction f3(a,b,c){\n\na+=shapesOffset;\nb+=shapesOffset;\nc+=shapesOffset;\n\nscope.faces.push(new Face3(a,b,c,null,null,0));\n\nvar uvs=uvgen.generateTopUV(scope,a,b,c);\n\nscope.faceVertexUvs[0].push(uvs);\n\n}\n\nfunction f4(a,b,c,d,wallContour,stepIndex,stepsLength,contourIndex1,contourIndex2){\n\na+=shapesOffset;\nb+=shapesOffset;\nc+=shapesOffset;\nd+=shapesOffset;\n\nscope.faces.push(new Face3(a,b,d,null,null,1));\nscope.faces.push(new Face3(b,c,d,null,null,1));\n\nvar uvs=uvgen.generateSideWallUV(scope,a,b,c,d);\n\nscope.faceVertexUvs[0].push([uvs[0],uvs[1],uvs[3]]);\nscope.faceVertexUvs[0].push([uvs[1],uvs[2],uvs[3]]);\n\n}\n\n};\n\nExtrudeGeometry.WorldUVGenerator={\n\ngenerateTopUV:function generateTopUV(geometry,indexA,indexB,indexC){\n\nvar vertices=geometry.vertices;\n\nvar a=vertices[indexA];\nvar b=vertices[indexB];\nvar c=vertices[indexC];\n\nreturn[\nnew Vector2(a.x,a.y),\nnew Vector2(b.x,b.y),\nnew Vector2(c.x,c.y)];\n\n\n},\n\ngenerateSideWallUV:function generateSideWallUV(geometry,indexA,indexB,indexC,indexD){\n\nvar vertices=geometry.vertices;\n\nvar a=vertices[indexA];\nvar b=vertices[indexB];\nvar c=vertices[indexC];\nvar d=vertices[indexD];\n\nif(Math.abs(a.y-b.y)<0.01){\n\nreturn[\nnew Vector2(a.x,1-a.z),\nnew Vector2(b.x,1-b.z),\nnew Vector2(c.x,1-c.z),\nnew Vector2(d.x,1-d.z)];\n\n\n}else{\n\nreturn[\nnew Vector2(a.y,1-a.z),\nnew Vector2(b.y,1-b.z),\nnew Vector2(c.y,1-c.z),\nnew Vector2(d.y,1-d.z)];\n\n\n}\n\n}};\n\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *  font: <THREE.Font>, // font\n\t *\n\t *  size: <float>, // size of the text\n\t *  height: <float>, // thickness to extrude text\n\t *  curveSegments: <int>, // number of points on the curves\n\t *\n\t *  bevelEnabled: <bool>, // turn on bevel\n\t *  bevelThickness: <float>, // how deep into text bevel goes\n\t *  bevelSize: <float> // how far from text outline is bevel\n\t * }\n\t */\n\nfunction TextGeometry(text,parameters){\n\nparameters=parameters||{};\n\nvar font=parameters.font;\n\nif((font&&font.isFont)===false){\n\nconsole.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');\nreturn new Geometry();\n\n}\n\nvar shapes=font.generateShapes(text,parameters.size,parameters.curveSegments);\n\n// translate parameters to ExtrudeGeometry API\n\nparameters.amount=parameters.height!==undefined?parameters.height:50;\n\n// defaults\n\nif(parameters.bevelThickness===undefined)parameters.bevelThickness=10;\nif(parameters.bevelSize===undefined)parameters.bevelSize=8;\nif(parameters.bevelEnabled===undefined)parameters.bevelEnabled=false;\n\nExtrudeGeometry.call(this,shapes,parameters);\n\nthis.type='TextGeometry';\n\n}\n\nTextGeometry.prototype=Object.create(ExtrudeGeometry.prototype);\nTextGeometry.prototype.constructor=TextGeometry;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){\n\nGeometry.call(this);\n\nthis.type='SphereGeometry';\n\nthis.parameters={\nradius:radius,\nwidthSegments:widthSegments,\nheightSegments:heightSegments,\nphiStart:phiStart,\nphiLength:phiLength,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\nthis.fromBufferGeometry(new SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength));\n\n}\n\nSphereGeometry.prototype=Object.create(Geometry.prototype);\nSphereGeometry.prototype.constructor=SphereGeometry;\n\n/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){\n\nBufferGeometry.call(this);\n\nthis.type='SphereBufferGeometry';\n\nthis.parameters={\nradius:radius,\nwidthSegments:widthSegments,\nheightSegments:heightSegments,\nphiStart:phiStart,\nphiLength:phiLength,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\nradius=radius||50;\n\nwidthSegments=Math.max(3,Math.floor(widthSegments)||8);\nheightSegments=Math.max(2,Math.floor(heightSegments)||6);\n\nphiStart=phiStart!==undefined?phiStart:0;\nphiLength=phiLength!==undefined?phiLength:Math.PI*2;\n\nthetaStart=thetaStart!==undefined?thetaStart:0;\nthetaLength=thetaLength!==undefined?thetaLength:Math.PI;\n\nvar thetaEnd=thetaStart+thetaLength;\n\nvar ix,iy;\n\nvar index=0;\nvar grid=[];\n\nvar vertex=new Vector3();\nvar normal=new Vector3();\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// generate vertices, normals and uvs\n\nfor(iy=0;iy<=heightSegments;iy++){\n\nvar verticesRow=[];\n\nvar v=iy/heightSegments;\n\nfor(ix=0;ix<=widthSegments;ix++){\n\nvar u=ix/widthSegments;\n\n// vertex\n\nvertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);\nvertex.y=radius*Math.cos(thetaStart+v*thetaLength);\nvertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);\n\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n// normal\n\nnormal.set(vertex.x,vertex.y,vertex.z).normalize();\nnormals.push(normal.x,normal.y,normal.z);\n\n// uv\n\nuvs.push(u,1-v);\n\nverticesRow.push(index++);\n\n}\n\ngrid.push(verticesRow);\n\n}\n\n// indices\n\nfor(iy=0;iy<heightSegments;iy++){\n\nfor(ix=0;ix<widthSegments;ix++){\n\nvar a=grid[iy][ix+1];\nvar b=grid[iy][ix];\nvar c=grid[iy+1][ix];\nvar d=grid[iy+1][ix+1];\n\nif(iy!==0||thetaStart>0)indices.push(a,b,d);\nif(iy!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);\n\n}\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n}\n\nSphereBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nSphereBufferGeometry.prototype.constructor=SphereBufferGeometry;\n\n/**\n\t * @author Kaleb Murphy\n\t */\n\nfunction RingGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){\n\nGeometry.call(this);\n\nthis.type='RingGeometry';\n\nthis.parameters={\ninnerRadius:innerRadius,\nouterRadius:outerRadius,\nthetaSegments:thetaSegments,\nphiSegments:phiSegments,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\nthis.fromBufferGeometry(new RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength));\n\n}\n\nRingGeometry.prototype=Object.create(Geometry.prototype);\nRingGeometry.prototype.constructor=RingGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){\n\nBufferGeometry.call(this);\n\nthis.type='RingBufferGeometry';\n\nthis.parameters={\ninnerRadius:innerRadius,\nouterRadius:outerRadius,\nthetaSegments:thetaSegments,\nphiSegments:phiSegments,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\ninnerRadius=innerRadius||20;\nouterRadius=outerRadius||50;\n\nthetaStart=thetaStart!==undefined?thetaStart:0;\nthetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;\n\nthetaSegments=thetaSegments!==undefined?Math.max(3,thetaSegments):8;\nphiSegments=phiSegments!==undefined?Math.max(1,phiSegments):1;\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// some helper variables\n\nvar segment;\nvar radius=innerRadius;\nvar radiusStep=(outerRadius-innerRadius)/phiSegments;\nvar vertex=new Vector3();\nvar uv=new Vector2();\nvar j,i;\n\n// generate vertices, normals and uvs\n\nfor(j=0;j<=phiSegments;j++){\n\nfor(i=0;i<=thetaSegments;i++){\n\n// values are generate from the inside of the ring to the outside\n\nsegment=thetaStart+i/thetaSegments*thetaLength;\n\n// vertex\n\nvertex.x=radius*Math.cos(segment);\nvertex.y=radius*Math.sin(segment);\n\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n// normal\n\nnormals.push(0,0,1);\n\n// uv\n\nuv.x=(vertex.x/outerRadius+1)/2;\nuv.y=(vertex.y/outerRadius+1)/2;\n\nuvs.push(uv.x,uv.y);\n\n}\n\n// increase the radius for next row of vertices\n\nradius+=radiusStep;\n\n}\n\n// indices\n\nfor(j=0;j<phiSegments;j++){\n\nvar thetaSegmentLevel=j*(thetaSegments+1);\n\nfor(i=0;i<thetaSegments;i++){\n\nsegment=i+thetaSegmentLevel;\n\nvar a=segment;\nvar b=segment+thetaSegments+1;\nvar c=segment+thetaSegments+2;\nvar d=segment+1;\n\n// faces\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n}\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n}\n\nRingBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nRingBufferGeometry.prototype.constructor=RingBufferGeometry;\n\n/**\n\t * @author astrodud / http://astrodud.isgreat.org/\n\t * @author zz85 / https://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t */\n\n// points - to create a closed torus, one must use a set of points\n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2PI) range of the lathed section\n//    2PI is a closed lathe, less than 2PI is a portion.\n\nfunction LatheGeometry(points,segments,phiStart,phiLength){\n\nGeometry.call(this);\n\nthis.type='LatheGeometry';\n\nthis.parameters={\npoints:points,\nsegments:segments,\nphiStart:phiStart,\nphiLength:phiLength};\n\n\nthis.fromBufferGeometry(new LatheBufferGeometry(points,segments,phiStart,phiLength));\nthis.mergeVertices();\n\n}\n\nLatheGeometry.prototype=Object.create(Geometry.prototype);\nLatheGeometry.prototype.constructor=LatheGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction LatheBufferGeometry(points,segments,phiStart,phiLength){\n\nBufferGeometry.call(this);\n\nthis.type='LatheBufferGeometry';\n\nthis.parameters={\npoints:points,\nsegments:segments,\nphiStart:phiStart,\nphiLength:phiLength};\n\n\nsegments=Math.floor(segments)||12;\nphiStart=phiStart||0;\nphiLength=phiLength||Math.PI*2;\n\n// clamp phiLength so it's in range of [ 0, 2PI ]\n\nphiLength=_Math.clamp(phiLength,0,Math.PI*2);\n\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar uvs=[];\n\n// helper variables\n\nvar base;\nvar inverseSegments=1.0/segments;\nvar vertex=new Vector3();\nvar uv=new Vector2();\nvar i,j;\n\n// generate vertices and uvs\n\nfor(i=0;i<=segments;i++){\n\nvar phi=phiStart+i*inverseSegments*phiLength;\n\nvar sin=Math.sin(phi);\nvar cos=Math.cos(phi);\n\nfor(j=0;j<=points.length-1;j++){\n\n// vertex\n\nvertex.x=points[j].x*sin;\nvertex.y=points[j].y;\nvertex.z=points[j].x*cos;\n\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n// uv\n\nuv.x=i/segments;\nuv.y=j/(points.length-1);\n\nuvs.push(uv.x,uv.y);\n\n\n}\n\n}\n\n// indices\n\nfor(i=0;i<segments;i++){\n\nfor(j=0;j<points.length-1;j++){\n\nbase=j+i*points.length;\n\nvar a=base;\nvar b=base+points.length;\nvar c=base+points.length+1;\nvar d=base+1;\n\n// faces\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n}\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n// generate normals\n\nthis.computeVertexNormals();\n\n// if the geometry is closed, we need to average the normals along the seam.\n// because the corresponding vertices are identical (but still have different UVs).\n\nif(phiLength===Math.PI*2){\n\nvar normals=this.attributes.normal.array;\nvar n1=new Vector3();\nvar n2=new Vector3();\nvar n=new Vector3();\n\n// this is the buffer offset for the last line of vertices\n\nbase=segments*points.length*3;\n\nfor(i=0,j=0;i<points.length;i++,j+=3){\n\n// select the normal of the vertex in the first line\n\nn1.x=normals[j+0];\nn1.y=normals[j+1];\nn1.z=normals[j+2];\n\n// select the normal of the vertex in the last line\n\nn2.x=normals[base+j+0];\nn2.y=normals[base+j+1];\nn2.z=normals[base+j+2];\n\n// average normals\n\nn.addVectors(n1,n2).normalize();\n\n// assign the new values to both normals\n\nnormals[j+0]=normals[base+j+0]=n.x;\nnormals[j+1]=normals[base+j+1]=n.y;\nnormals[j+2]=normals[base+j+2]=n.z;\n\n}\n\n}\n\n}\n\nLatheBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nLatheBufferGeometry.prototype.constructor=LatheBufferGeometry;\n\n/**\n\t * @author jonobr1 / http://jonobr1.com\n\t */\n\nfunction ShapeGeometry(shapes,curveSegments){\n\nGeometry.call(this);\n\nthis.type='ShapeGeometry';\n\nif((typeof curveSegments==='undefined'?'undefined':_typeof(curveSegments))==='object'){\n\nconsole.warn('THREE.ShapeGeometry: Options parameter has been removed.');\n\ncurveSegments=curveSegments.curveSegments;\n\n}\n\nthis.parameters={\nshapes:shapes,\ncurveSegments:curveSegments};\n\n\nthis.fromBufferGeometry(new ShapeBufferGeometry(shapes,curveSegments));\nthis.mergeVertices();\n\n}\n\nShapeGeometry.prototype=Object.create(Geometry.prototype);\nShapeGeometry.prototype.constructor=ShapeGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction ShapeBufferGeometry(shapes,curveSegments){\n\nBufferGeometry.call(this);\n\nthis.type='ShapeBufferGeometry';\n\nthis.parameters={\nshapes:shapes,\ncurveSegments:curveSegments};\n\n\ncurveSegments=curveSegments||12;\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// helper variables\n\nvar groupStart=0;\nvar groupCount=0;\n\n// allow single and array values for \"shapes\" parameter\n\nif(Array.isArray(shapes)===false){\n\naddShape(shapes);\n\n}else{\n\nfor(var i=0;i<shapes.length;i++){\n\naddShape(shapes[i]);\n\nthis.addGroup(groupStart,groupCount,i);// enables MultiMaterial support\n\ngroupStart+=groupCount;\ngroupCount=0;\n\n}\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n\n// helper functions\n\nfunction addShape(shape){\n\nvar i,l,shapeHole;\n\nvar indexOffset=vertices.length/3;\nvar points=shape.extractPoints(curveSegments);\n\nvar shapeVertices=points.shape;\nvar shapeHoles=points.holes;\n\n// check direction of vertices\n\nif(ShapeUtils.isClockWise(shapeVertices)===false){\n\nshapeVertices=shapeVertices.reverse();\n\n// also check if holes are in the opposite direction\n\nfor(i=0,l=shapeHoles.length;i<l;i++){\n\nshapeHole=shapeHoles[i];\n\nif(ShapeUtils.isClockWise(shapeHole)===true){\n\nshapeHoles[i]=shapeHole.reverse();\n\n}\n\n}\n\n}\n\nvar faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);\n\n// join vertices of inner and outer paths to a single array\n\nfor(i=0,l=shapeHoles.length;i<l;i++){\n\nshapeHole=shapeHoles[i];\nshapeVertices=shapeVertices.concat(shapeHole);\n\n}\n\n// vertices, normals, uvs\n\nfor(i=0,l=shapeVertices.length;i<l;i++){\n\nvar vertex=shapeVertices[i];\n\nvertices.push(vertex.x,vertex.y,0);\nnormals.push(0,0,1);\nuvs.push(vertex.x,vertex.y);// world uvs\n\n}\n\n// incides\n\nfor(i=0,l=faces.length;i<l;i++){\n\nvar face=faces[i];\n\nvar a=face[0]+indexOffset;\nvar b=face[1]+indexOffset;\nvar c=face[2]+indexOffset;\n\nindices.push(a,b,c);\ngroupCount+=3;\n\n}\n\n}\n\n}\n\nShapeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry;\n\n/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction EdgesGeometry(geometry,thresholdAngle){\n\nBufferGeometry.call(this);\n\nthis.type='EdgesGeometry';\n\nthis.parameters={\nthresholdAngle:thresholdAngle};\n\n\nthresholdAngle=thresholdAngle!==undefined?thresholdAngle:1;\n\n// buffer\n\nvar vertices=[];\n\n// helper variables\n\nvar thresholdDot=Math.cos(_Math.DEG2RAD*thresholdAngle);\nvar edge=[0,0],edges={};\nvar key,keys=['a','b','c'];\n\n// prepare source geometry\n\nvar geometry2;\n\nif(geometry.isBufferGeometry){\n\ngeometry2=new Geometry();\ngeometry2.fromBufferGeometry(geometry);\n\n}else{\n\ngeometry2=geometry.clone();\n\n}\n\ngeometry2.mergeVertices();\ngeometry2.computeFaceNormals();\n\nvar sourceVertices=geometry2.vertices;\nvar faces=geometry2.faces;\n\n// now create a data structure where each entry represents an edge with its adjoining faces\n\nfor(var i=0,l=faces.length;i<l;i++){\n\nvar face=faces[i];\n\nfor(var j=0;j<3;j++){\n\nedge[0]=face[keys[j]];\nedge[1]=face[keys[(j+1)%3]];\nedge.sort(sortFunction);\n\nkey=edge.toString();\n\nif(edges[key]===undefined){\n\nedges[key]={index1:edge[0],index2:edge[1],face1:i,face2:undefined};\n\n}else{\n\nedges[key].face2=i;\n\n}\n\n}\n\n}\n\n// generate vertices\n\nfor(key in edges){\n\nvar e=edges[key];\n\n// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n\nif(e.face2===undefined||faces[e.face1].normal.dot(faces[e.face2].normal)<=thresholdDot){\n\nvar vertex=sourceVertices[e.index1];\nvertices.push(vertex.x,vertex.y,vertex.z);\n\nvertex=sourceVertices[e.index2];\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n}\n\n}\n\n// build geometry\n\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\n\n// custom array sort function\n\nfunction sortFunction(a,b){\n\nreturn a-b;\n\n}\n\n}\n\nEdgesGeometry.prototype=Object.create(BufferGeometry.prototype);\nEdgesGeometry.prototype.constructor=EdgesGeometry;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction CylinderGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){\n\nGeometry.call(this);\n\nthis.type='CylinderGeometry';\n\nthis.parameters={\nradiusTop:radiusTop,\nradiusBottom:radiusBottom,\nheight:height,\nradialSegments:radialSegments,\nheightSegments:heightSegments,\nopenEnded:openEnded,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\nthis.fromBufferGeometry(new CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength));\nthis.mergeVertices();\n\n}\n\nCylinderGeometry.prototype=Object.create(Geometry.prototype);\nCylinderGeometry.prototype.constructor=CylinderGeometry;\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){\n\nBufferGeometry.call(this);\n\nthis.type='CylinderBufferGeometry';\n\nthis.parameters={\nradiusTop:radiusTop,\nradiusBottom:radiusBottom,\nheight:height,\nradialSegments:radialSegments,\nheightSegments:heightSegments,\nopenEnded:openEnded,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\nvar scope=this;\n\nradiusTop=radiusTop!==undefined?radiusTop:20;\nradiusBottom=radiusBottom!==undefined?radiusBottom:20;\nheight=height!==undefined?height:100;\n\nradialSegments=Math.floor(radialSegments)||8;\nheightSegments=Math.floor(heightSegments)||1;\n\nopenEnded=openEnded!==undefined?openEnded:false;\nthetaStart=thetaStart!==undefined?thetaStart:0.0;\nthetaLength=thetaLength!==undefined?thetaLength:2.0*Math.PI;\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// helper variables\n\nvar index=0;\nvar indexOffset=0;\nvar indexArray=[];\nvar halfHeight=height/2;\nvar groupStart=0;\n\n// generate geometry\n\ngenerateTorso();\n\nif(openEnded===false){\n\nif(radiusTop>0)generateCap(true);\nif(radiusBottom>0)generateCap(false);\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\nfunction generateTorso(){\n\nvar x,y;\nvar normal=new Vector3();\nvar vertex=new Vector3();\n\nvar groupCount=0;\n\n// this will be used to calculate the normal\nvar slope=(radiusBottom-radiusTop)/height;\n\n// generate vertices, normals and uvs\n\nfor(y=0;y<=heightSegments;y++){\n\nvar indexRow=[];\n\nvar v=y/heightSegments;\n\n// calculate the radius of the current row\n\nvar radius=v*(radiusBottom-radiusTop)+radiusTop;\n\nfor(x=0;x<=radialSegments;x++){\n\nvar u=x/radialSegments;\n\nvar theta=u*thetaLength+thetaStart;\n\nvar sinTheta=Math.sin(theta);\nvar cosTheta=Math.cos(theta);\n\n// vertex\n\nvertex.x=radius*sinTheta;\nvertex.y=-v*height+halfHeight;\nvertex.z=radius*cosTheta;\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n// normal\n\nnormal.set(sinTheta,slope,cosTheta).normalize();\nnormals.push(normal.x,normal.y,normal.z);\n\n// uv\n\nuvs.push(u,1-v);\n\n// save index of vertex in respective row\n\nindexRow.push(index++);\n\n}\n\n// now save vertices of the row in our index array\n\nindexArray.push(indexRow);\n\n}\n\n// generate indices\n\nfor(x=0;x<radialSegments;x++){\n\nfor(y=0;y<heightSegments;y++){\n\n// we use the index array to access the correct indices\n\nvar a=indexArray[y][x];\nvar b=indexArray[y+1][x];\nvar c=indexArray[y+1][x+1];\nvar d=indexArray[y][x+1];\n\n// faces\n\nindices.push(a,b,d);\nindices.push(b,c,d);\n\n// update group counter\n\ngroupCount+=6;\n\n}\n\n}\n\n// add a group to the geometry. this will ensure multi material support\n\nscope.addGroup(groupStart,groupCount,0);\n\n// calculate new start value for groups\n\ngroupStart+=groupCount;\n\n}\n\nfunction generateCap(top){\n\nvar x,centerIndexStart,centerIndexEnd;\n\nvar uv=new Vector2();\nvar vertex=new Vector3();\n\nvar groupCount=0;\n\nvar radius=top===true?radiusTop:radiusBottom;\nvar sign=top===true?1:-1;\n\n// save the index of the first center vertex\ncenterIndexStart=index;\n\n// first we generate the center vertex data of the cap.\n// because the geometry needs one set of uvs per face,\n// we must generate a center vertex per face/segment\n\nfor(x=1;x<=radialSegments;x++){\n\n// vertex\n\nvertices.push(0,halfHeight*sign,0);\n\n// normal\n\nnormals.push(0,sign,0);\n\n// uv\n\nuvs.push(0.5,0.5);\n\n// increase index\n\nindex++;\n\n}\n\n// save the index of the last center vertex\n\ncenterIndexEnd=index;\n\n// now we generate the surrounding vertices, normals and uvs\n\nfor(x=0;x<=radialSegments;x++){\n\nvar u=x/radialSegments;\nvar theta=u*thetaLength+thetaStart;\n\nvar cosTheta=Math.cos(theta);\nvar sinTheta=Math.sin(theta);\n\n// vertex\n\nvertex.x=radius*sinTheta;\nvertex.y=halfHeight*sign;\nvertex.z=radius*cosTheta;\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n// normal\n\nnormals.push(0,sign,0);\n\n// uv\n\nuv.x=cosTheta*0.5+0.5;\nuv.y=sinTheta*0.5*sign+0.5;\nuvs.push(uv.x,uv.y);\n\n// increase index\n\nindex++;\n\n}\n\n// generate indices\n\nfor(x=0;x<radialSegments;x++){\n\nvar c=centerIndexStart+x;\nvar i=centerIndexEnd+x;\n\nif(top===true){\n\n// face top\n\nindices.push(i,i+1,c);\n\n}else{\n\n// face bottom\n\nindices.push(i+1,i,c);\n\n}\n\ngroupCount+=3;\n\n}\n\n// add a group to the geometry. this will ensure multi material support\n\nscope.addGroup(groupStart,groupCount,top===true?1:2);\n\n// calculate new start value for groups\n\ngroupStart+=groupCount;\n\n}\n\n}\n\nCylinderBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nCylinderBufferGeometry.prototype.constructor=CylinderBufferGeometry;\n\n/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\nfunction ConeGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){\n\nCylinderGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);\n\nthis.type='ConeGeometry';\n\nthis.parameters={\nradius:radius,\nheight:height,\nradialSegments:radialSegments,\nheightSegments:heightSegments,\nopenEnded:openEnded,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\n}\n\nConeGeometry.prototype=Object.create(CylinderGeometry.prototype);\nConeGeometry.prototype.constructor=ConeGeometry;\n\n/**\n\t * @author: abelnation / http://github.com/abelnation\n\t */\n\nfunction ConeBufferGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){\n\nCylinderBufferGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);\n\nthis.type='ConeBufferGeometry';\n\nthis.parameters={\nradius:radius,\nheight:height,\nradialSegments:radialSegments,\nheightSegments:heightSegments,\nopenEnded:openEnded,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\n}\n\nConeBufferGeometry.prototype=Object.create(CylinderBufferGeometry.prototype);\nConeBufferGeometry.prototype.constructor=ConeBufferGeometry;\n\n/**\n\t * @author hughes\n\t */\n\nfunction CircleGeometry(radius,segments,thetaStart,thetaLength){\n\nGeometry.call(this);\n\nthis.type='CircleGeometry';\n\nthis.parameters={\nradius:radius,\nsegments:segments,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\nthis.fromBufferGeometry(new CircleBufferGeometry(radius,segments,thetaStart,thetaLength));\n\n}\n\nCircleGeometry.prototype=Object.create(Geometry.prototype);\nCircleGeometry.prototype.constructor=CircleGeometry;\n\n/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction CircleBufferGeometry(radius,segments,thetaStart,thetaLength){\n\nBufferGeometry.call(this);\n\nthis.type='CircleBufferGeometry';\n\nthis.parameters={\nradius:radius,\nsegments:segments,\nthetaStart:thetaStart,\nthetaLength:thetaLength};\n\n\nradius=radius||50;\nsegments=segments!==undefined?Math.max(3,segments):8;\n\nthetaStart=thetaStart!==undefined?thetaStart:0;\nthetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;\n\n// buffers\n\nvar indices=[];\nvar vertices=[];\nvar normals=[];\nvar uvs=[];\n\n// helper variables\n\nvar i,s;\nvar vertex=new Vector3();\nvar uv=new Vector2();\n\n// center point\n\nvertices.push(0,0,0);\nnormals.push(0,0,1);\nuvs.push(0.5,0.5);\n\nfor(s=0,i=3;s<=segments;s++,i+=3){\n\nvar segment=thetaStart+s/segments*thetaLength;\n\n// vertex\n\nvertex.x=radius*Math.cos(segment);\nvertex.y=radius*Math.sin(segment);\n\nvertices.push(vertex.x,vertex.y,vertex.z);\n\n// normal\n\nnormals.push(0,0,1);\n\n// uvs\n\nuv.x=(vertices[i]/radius+1)/2;\nuv.y=(vertices[i+1]/radius+1)/2;\n\nuvs.push(uv.x,uv.y);\n\n}\n\n// indices\n\nfor(i=1;i<=segments;i++){\n\nindices.push(i,i+1,0);\n\n}\n\n// build geometry\n\nthis.setIndex(indices);\nthis.addAttribute('position',new Float32BufferAttribute(vertices,3));\nthis.addAttribute('normal',new Float32BufferAttribute(normals,3));\nthis.addAttribute('uv',new Float32BufferAttribute(uvs,2));\n\n}\n\nCircleBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nCircleBufferGeometry.prototype.constructor=CircleBufferGeometry;\n\n\n\nvar Geometries=Object.freeze({\nWireframeGeometry:WireframeGeometry,\nParametricGeometry:ParametricGeometry,\nParametricBufferGeometry:ParametricBufferGeometry,\nTetrahedronGeometry:TetrahedronGeometry,\nTetrahedronBufferGeometry:TetrahedronBufferGeometry,\nOctahedronGeometry:OctahedronGeometry,\nOctahedronBufferGeometry:OctahedronBufferGeometry,\nIcosahedronGeometry:IcosahedronGeometry,\nIcosahedronBufferGeometry:IcosahedronBufferGeometry,\nDodecahedronGeometry:DodecahedronGeometry,\nDodecahedronBufferGeometry:DodecahedronBufferGeometry,\nPolyhedronGeometry:PolyhedronGeometry,\nPolyhedronBufferGeometry:PolyhedronBufferGeometry,\nTubeGeometry:TubeGeometry,\nTubeBufferGeometry:TubeBufferGeometry,\nTorusKnotGeometry:TorusKnotGeometry,\nTorusKnotBufferGeometry:TorusKnotBufferGeometry,\nTorusGeometry:TorusGeometry,\nTorusBufferGeometry:TorusBufferGeometry,\nTextGeometry:TextGeometry,\nSphereGeometry:SphereGeometry,\nSphereBufferGeometry:SphereBufferGeometry,\nRingGeometry:RingGeometry,\nRingBufferGeometry:RingBufferGeometry,\nPlaneGeometry:PlaneGeometry,\nPlaneBufferGeometry:PlaneBufferGeometry,\nLatheGeometry:LatheGeometry,\nLatheBufferGeometry:LatheBufferGeometry,\nShapeGeometry:ShapeGeometry,\nShapeBufferGeometry:ShapeBufferGeometry,\nExtrudeGeometry:ExtrudeGeometry,\nEdgesGeometry:EdgesGeometry,\nConeGeometry:ConeGeometry,\nConeBufferGeometry:ConeBufferGeometry,\nCylinderGeometry:CylinderGeometry,\nCylinderBufferGeometry:CylinderBufferGeometry,\nCircleGeometry:CircleGeometry,\nCircleBufferGeometry:CircleBufferGeometry,\nBoxGeometry:BoxGeometry,\nBoxBufferGeometry:BoxBufferGeometry});\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction ShadowMaterial(){\n\nShaderMaterial.call(this,{\nuniforms:UniformsUtils.merge([\nUniformsLib.lights,\n{\nopacity:{value:1.0}}]),\n\n\nvertexShader:ShaderChunk['shadow_vert'],\nfragmentShader:ShaderChunk['shadow_frag']});\n\n\nthis.lights=true;\nthis.transparent=true;\n\nObject.defineProperties(this,{\nopacity:{\nenumerable:true,\nget:function get(){\nreturn this.uniforms.opacity.value;\n},\nset:function set(value){\nthis.uniforms.opacity.value=value;\n}}});\n\n\n\n}\n\nShadowMaterial.prototype=Object.create(ShaderMaterial.prototype);\nShadowMaterial.prototype.constructor=ShadowMaterial;\n\nShadowMaterial.prototype.isShadowMaterial=true;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction RawShaderMaterial(parameters){\n\nShaderMaterial.call(this,parameters);\n\nthis.type='RawShaderMaterial';\n\n}\n\nRawShaderMaterial.prototype=Object.create(ShaderMaterial.prototype);\nRawShaderMaterial.prototype.constructor=RawShaderMaterial;\n\nRawShaderMaterial.prototype.isRawShaderMaterial=true;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction MultiMaterial(materials){\n\nthis.uuid=_Math.generateUUID();\n\nthis.type='MultiMaterial';\n\nthis.materials=Array.isArray(materials)?materials:[];\n\nthis.visible=true;\n\n}\n\nMultiMaterial.prototype={\n\nconstructor:MultiMaterial,\n\nisMultiMaterial:true,\n\ntoJSON:function toJSON(meta){\n\nvar output={\nmetadata:{\nversion:4.2,\ntype:'material',\ngenerator:'MaterialExporter'},\n\nuuid:this.uuid,\ntype:this.type,\nmaterials:[]};\n\n\nvar materials=this.materials;\n\nfor(var i=0,l=materials.length;i<l;i++){\n\nvar material=materials[i].toJSON(meta);\ndelete material.metadata;\n\noutput.materials.push(material);\n\n}\n\noutput.visible=this.visible;\n\nreturn output;\n\n},\n\nclone:function clone(){\n\nvar material=new this.constructor();\n\nfor(var i=0;i<this.materials.length;i++){\n\nmaterial.materials.push(this.materials[i].clone());\n\n}\n\nmaterial.visible=this.visible;\n\nreturn material;\n\n}};\n\n\n\n/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  roughness: <float>,\n\t *  metalness: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  roughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  metalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *  envMapIntensity: <float>\n\t *\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\nfunction MeshStandardMaterial(parameters){\n\nMaterial.call(this);\n\nthis.defines={'STANDARD':''};\n\nthis.type='MeshStandardMaterial';\n\nthis.color=new Color(0xffffff);// diffuse\nthis.roughness=0.5;\nthis.metalness=0.5;\n\nthis.map=null;\n\nthis.lightMap=null;\nthis.lightMapIntensity=1.0;\n\nthis.aoMap=null;\nthis.aoMapIntensity=1.0;\n\nthis.emissive=new Color(0x000000);\nthis.emissiveIntensity=1.0;\nthis.emissiveMap=null;\n\nthis.bumpMap=null;\nthis.bumpScale=1;\n\nthis.normalMap=null;\nthis.normalScale=new Vector2(1,1);\n\nthis.displacementMap=null;\nthis.displacementScale=1;\nthis.displacementBias=0;\n\nthis.roughnessMap=null;\n\nthis.metalnessMap=null;\n\nthis.alphaMap=null;\n\nthis.envMap=null;\nthis.envMapIntensity=1.0;\n\nthis.refractionRatio=0.98;\n\nthis.wireframe=false;\nthis.wireframeLinewidth=1;\nthis.wireframeLinecap='round';\nthis.wireframeLinejoin='round';\n\nthis.skinning=false;\nthis.morphTargets=false;\nthis.morphNormals=false;\n\nthis.setValues(parameters);\n\n}\n\nMeshStandardMaterial.prototype=Object.create(Material.prototype);\nMeshStandardMaterial.prototype.constructor=MeshStandardMaterial;\n\nMeshStandardMaterial.prototype.isMeshStandardMaterial=true;\n\nMeshStandardMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.defines={'STANDARD':''};\n\nthis.color.copy(source.color);\nthis.roughness=source.roughness;\nthis.metalness=source.metalness;\n\nthis.map=source.map;\n\nthis.lightMap=source.lightMap;\nthis.lightMapIntensity=source.lightMapIntensity;\n\nthis.aoMap=source.aoMap;\nthis.aoMapIntensity=source.aoMapIntensity;\n\nthis.emissive.copy(source.emissive);\nthis.emissiveMap=source.emissiveMap;\nthis.emissiveIntensity=source.emissiveIntensity;\n\nthis.bumpMap=source.bumpMap;\nthis.bumpScale=source.bumpScale;\n\nthis.normalMap=source.normalMap;\nthis.normalScale.copy(source.normalScale);\n\nthis.displacementMap=source.displacementMap;\nthis.displacementScale=source.displacementScale;\nthis.displacementBias=source.displacementBias;\n\nthis.roughnessMap=source.roughnessMap;\n\nthis.metalnessMap=source.metalnessMap;\n\nthis.alphaMap=source.alphaMap;\n\nthis.envMap=source.envMap;\nthis.envMapIntensity=source.envMapIntensity;\n\nthis.refractionRatio=source.refractionRatio;\n\nthis.wireframe=source.wireframe;\nthis.wireframeLinewidth=source.wireframeLinewidth;\nthis.wireframeLinecap=source.wireframeLinecap;\nthis.wireframeLinejoin=source.wireframeLinejoin;\n\nthis.skinning=source.skinning;\nthis.morphTargets=source.morphTargets;\nthis.morphNormals=source.morphNormals;\n\nreturn this;\n\n};\n\n/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  reflectivity: <float>\n\t * }\n\t */\n\nfunction MeshPhysicalMaterial(parameters){\n\nMeshStandardMaterial.call(this);\n\nthis.defines={'PHYSICAL':''};\n\nthis.type='MeshPhysicalMaterial';\n\nthis.reflectivity=0.5;// maps to F0 = 0.04\n\nthis.clearCoat=0.0;\nthis.clearCoatRoughness=0.0;\n\nthis.setValues(parameters);\n\n}\n\nMeshPhysicalMaterial.prototype=Object.create(MeshStandardMaterial.prototype);\nMeshPhysicalMaterial.prototype.constructor=MeshPhysicalMaterial;\n\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;\n\nMeshPhysicalMaterial.prototype.copy=function(source){\n\nMeshStandardMaterial.prototype.copy.call(this,source);\n\nthis.defines={'PHYSICAL':''};\n\nthis.reflectivity=source.reflectivity;\n\nthis.clearCoat=source.clearCoat;\nthis.clearCoatRoughness=source.clearCoatRoughness;\n\nreturn this;\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  specular: <hex>,\n\t *  shininess: <float>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\nfunction MeshPhongMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='MeshPhongMaterial';\n\nthis.color=new Color(0xffffff);// diffuse\nthis.specular=new Color(0x111111);\nthis.shininess=30;\n\nthis.map=null;\n\nthis.lightMap=null;\nthis.lightMapIntensity=1.0;\n\nthis.aoMap=null;\nthis.aoMapIntensity=1.0;\n\nthis.emissive=new Color(0x000000);\nthis.emissiveIntensity=1.0;\nthis.emissiveMap=null;\n\nthis.bumpMap=null;\nthis.bumpScale=1;\n\nthis.normalMap=null;\nthis.normalScale=new Vector2(1,1);\n\nthis.displacementMap=null;\nthis.displacementScale=1;\nthis.displacementBias=0;\n\nthis.specularMap=null;\n\nthis.alphaMap=null;\n\nthis.envMap=null;\nthis.combine=MultiplyOperation;\nthis.reflectivity=1;\nthis.refractionRatio=0.98;\n\nthis.wireframe=false;\nthis.wireframeLinewidth=1;\nthis.wireframeLinecap='round';\nthis.wireframeLinejoin='round';\n\nthis.skinning=false;\nthis.morphTargets=false;\nthis.morphNormals=false;\n\nthis.setValues(parameters);\n\n}\n\nMeshPhongMaterial.prototype=Object.create(Material.prototype);\nMeshPhongMaterial.prototype.constructor=MeshPhongMaterial;\n\nMeshPhongMaterial.prototype.isMeshPhongMaterial=true;\n\nMeshPhongMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.color.copy(source.color);\nthis.specular.copy(source.specular);\nthis.shininess=source.shininess;\n\nthis.map=source.map;\n\nthis.lightMap=source.lightMap;\nthis.lightMapIntensity=source.lightMapIntensity;\n\nthis.aoMap=source.aoMap;\nthis.aoMapIntensity=source.aoMapIntensity;\n\nthis.emissive.copy(source.emissive);\nthis.emissiveMap=source.emissiveMap;\nthis.emissiveIntensity=source.emissiveIntensity;\n\nthis.bumpMap=source.bumpMap;\nthis.bumpScale=source.bumpScale;\n\nthis.normalMap=source.normalMap;\nthis.normalScale.copy(source.normalScale);\n\nthis.displacementMap=source.displacementMap;\nthis.displacementScale=source.displacementScale;\nthis.displacementBias=source.displacementBias;\n\nthis.specularMap=source.specularMap;\n\nthis.alphaMap=source.alphaMap;\n\nthis.envMap=source.envMap;\nthis.combine=source.combine;\nthis.reflectivity=source.reflectivity;\nthis.refractionRatio=source.refractionRatio;\n\nthis.wireframe=source.wireframe;\nthis.wireframeLinewidth=source.wireframeLinewidth;\nthis.wireframeLinecap=source.wireframeLinecap;\nthis.wireframeLinejoin=source.wireframeLinejoin;\n\nthis.skinning=source.skinning;\nthis.morphTargets=source.morphTargets;\nthis.morphNormals=source.morphNormals;\n\nreturn this;\n\n};\n\n/**\n\t * @author takahirox / http://github.com/takahirox\n\t *\n\t * parameters = {\n\t *  gradientMap: new THREE.Texture( <Image> )\n\t * }\n\t */\n\nfunction MeshToonMaterial(parameters){\n\nMeshPhongMaterial.call(this);\n\nthis.defines={'TOON':''};\n\nthis.type='MeshToonMaterial';\n\nthis.gradientMap=null;\n\nthis.setValues(parameters);\n\n}\n\nMeshToonMaterial.prototype=Object.create(MeshPhongMaterial.prototype);\nMeshToonMaterial.prototype.constructor=MeshToonMaterial;\n\nMeshToonMaterial.prototype.isMeshToonMaterial=true;\n\nMeshToonMaterial.prototype.copy=function(source){\n\nMeshPhongMaterial.prototype.copy.call(this,source);\n\nthis.gradientMap=source.gradientMap;\n\nreturn this;\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * parameters = {\n\t *  opacity: <float>,\n\t *\n\t *  bumpMap: new THREE.Texture( <Image> ),\n\t *  bumpScale: <float>,\n\t *\n\t *  normalMap: new THREE.Texture( <Image> ),\n\t *  normalScale: <Vector2>,\n\t *\n\t *  displacementMap: new THREE.Texture( <Image> ),\n\t *  displacementScale: <float>,\n\t *  displacementBias: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\nfunction MeshNormalMaterial(parameters){\n\nMaterial.call(this,parameters);\n\nthis.type='MeshNormalMaterial';\n\nthis.bumpMap=null;\nthis.bumpScale=1;\n\nthis.normalMap=null;\nthis.normalScale=new Vector2(1,1);\n\nthis.displacementMap=null;\nthis.displacementScale=1;\nthis.displacementBias=0;\n\nthis.wireframe=false;\nthis.wireframeLinewidth=1;\n\nthis.fog=false;\nthis.lights=false;\n\nthis.skinning=false;\nthis.morphTargets=false;\nthis.morphNormals=false;\n\nthis.setValues(parameters);\n\n}\n\nMeshNormalMaterial.prototype=Object.create(Material.prototype);\nMeshNormalMaterial.prototype.constructor=MeshNormalMaterial;\n\nMeshNormalMaterial.prototype.isMeshNormalMaterial=true;\n\nMeshNormalMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.bumpMap=source.bumpMap;\nthis.bumpScale=source.bumpScale;\n\nthis.normalMap=source.normalMap;\nthis.normalScale.copy(source.normalScale);\n\nthis.displacementMap=source.displacementMap;\nthis.displacementScale=source.displacementScale;\nthis.displacementBias=source.displacementBias;\n\nthis.wireframe=source.wireframe;\nthis.wireframeLinewidth=source.wireframeLinewidth;\n\nthis.skinning=source.skinning;\nthis.morphTargets=source.morphTargets;\nthis.morphNormals=source.morphNormals;\n\nreturn this;\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  map: new THREE.Texture( <Image> ),\n\t *\n\t *  lightMap: new THREE.Texture( <Image> ),\n\t *  lightMapIntensity: <float>\n\t *\n\t *  aoMap: new THREE.Texture( <Image> ),\n\t *  aoMapIntensity: <float>\n\t *\n\t *  emissive: <hex>,\n\t *  emissiveIntensity: <float>\n\t *  emissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *  specularMap: new THREE.Texture( <Image> ),\n\t *\n\t *  alphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n\t *  combine: THREE.Multiply,\n\t *  reflectivity: <float>,\n\t *  refractionRatio: <float>,\n\t *\n\t *  wireframe: <boolean>,\n\t *  wireframeLinewidth: <float>,\n\t *\n\t *  skinning: <bool>,\n\t *  morphTargets: <bool>,\n\t *  morphNormals: <bool>\n\t * }\n\t */\n\nfunction MeshLambertMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='MeshLambertMaterial';\n\nthis.color=new Color(0xffffff);// diffuse\n\nthis.map=null;\n\nthis.lightMap=null;\nthis.lightMapIntensity=1.0;\n\nthis.aoMap=null;\nthis.aoMapIntensity=1.0;\n\nthis.emissive=new Color(0x000000);\nthis.emissiveIntensity=1.0;\nthis.emissiveMap=null;\n\nthis.specularMap=null;\n\nthis.alphaMap=null;\n\nthis.envMap=null;\nthis.combine=MultiplyOperation;\nthis.reflectivity=1;\nthis.refractionRatio=0.98;\n\nthis.wireframe=false;\nthis.wireframeLinewidth=1;\nthis.wireframeLinecap='round';\nthis.wireframeLinejoin='round';\n\nthis.skinning=false;\nthis.morphTargets=false;\nthis.morphNormals=false;\n\nthis.setValues(parameters);\n\n}\n\nMeshLambertMaterial.prototype=Object.create(Material.prototype);\nMeshLambertMaterial.prototype.constructor=MeshLambertMaterial;\n\nMeshLambertMaterial.prototype.isMeshLambertMaterial=true;\n\nMeshLambertMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.color.copy(source.color);\n\nthis.map=source.map;\n\nthis.lightMap=source.lightMap;\nthis.lightMapIntensity=source.lightMapIntensity;\n\nthis.aoMap=source.aoMap;\nthis.aoMapIntensity=source.aoMapIntensity;\n\nthis.emissive.copy(source.emissive);\nthis.emissiveMap=source.emissiveMap;\nthis.emissiveIntensity=source.emissiveIntensity;\n\nthis.specularMap=source.specularMap;\n\nthis.alphaMap=source.alphaMap;\n\nthis.envMap=source.envMap;\nthis.combine=source.combine;\nthis.reflectivity=source.reflectivity;\nthis.refractionRatio=source.refractionRatio;\n\nthis.wireframe=source.wireframe;\nthis.wireframeLinewidth=source.wireframeLinewidth;\nthis.wireframeLinecap=source.wireframeLinecap;\nthis.wireframeLinejoin=source.wireframeLinejoin;\n\nthis.skinning=source.skinning;\nthis.morphTargets=source.morphTargets;\nthis.morphNormals=source.morphNormals;\n\nreturn this;\n\n};\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t *\n\t * parameters = {\n\t *  color: <hex>,\n\t *  opacity: <float>,\n\t *\n\t *  linewidth: <float>,\n\t *\n\t *  scale: <float>,\n\t *  dashSize: <float>,\n\t *  gapSize: <float>\n\t * }\n\t */\n\nfunction LineDashedMaterial(parameters){\n\nMaterial.call(this);\n\nthis.type='LineDashedMaterial';\n\nthis.color=new Color(0xffffff);\n\nthis.linewidth=1;\n\nthis.scale=1;\nthis.dashSize=3;\nthis.gapSize=1;\n\nthis.lights=false;\n\nthis.setValues(parameters);\n\n}\n\nLineDashedMaterial.prototype=Object.create(Material.prototype);\nLineDashedMaterial.prototype.constructor=LineDashedMaterial;\n\nLineDashedMaterial.prototype.isLineDashedMaterial=true;\n\nLineDashedMaterial.prototype.copy=function(source){\n\nMaterial.prototype.copy.call(this,source);\n\nthis.color.copy(source.color);\n\nthis.linewidth=source.linewidth;\n\nthis.scale=source.scale;\nthis.dashSize=source.dashSize;\nthis.gapSize=source.gapSize;\n\nreturn this;\n\n};\n\n\n\nvar Materials=Object.freeze({\nShadowMaterial:ShadowMaterial,\nSpriteMaterial:SpriteMaterial,\nRawShaderMaterial:RawShaderMaterial,\nShaderMaterial:ShaderMaterial,\nPointsMaterial:PointsMaterial,\nMultiMaterial:MultiMaterial,\nMeshPhysicalMaterial:MeshPhysicalMaterial,\nMeshStandardMaterial:MeshStandardMaterial,\nMeshPhongMaterial:MeshPhongMaterial,\nMeshToonMaterial:MeshToonMaterial,\nMeshNormalMaterial:MeshNormalMaterial,\nMeshLambertMaterial:MeshLambertMaterial,\nMeshDepthMaterial:MeshDepthMaterial,\nMeshBasicMaterial:MeshBasicMaterial,\nLineDashedMaterial:LineDashedMaterial,\nLineBasicMaterial:LineBasicMaterial,\nMaterial:Material});\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nvar Cache={\n\nenabled:false,\n\nfiles:{},\n\nadd:function add(key,file){\n\nif(this.enabled===false)return;\n\n// console.log( 'THREE.Cache', 'Adding key:', key );\n\nthis.files[key]=file;\n\n},\n\nget:function get(key){\n\nif(this.enabled===false)return;\n\n// console.log( 'THREE.Cache', 'Checking key:', key );\n\nreturn this.files[key];\n\n},\n\nremove:function remove(key){\n\ndelete this.files[key];\n\n},\n\nclear:function clear(){\n\nthis.files={};\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction LoadingManager(onLoad,onProgress,onError){\n\nvar scope=this;\n\nvar isLoading=false,itemsLoaded=0,itemsTotal=0;\n\nthis.onStart=undefined;\nthis.onLoad=onLoad;\nthis.onProgress=onProgress;\nthis.onError=onError;\n\nthis.itemStart=function(url){\n\nitemsTotal++;\n\nif(isLoading===false){\n\nif(scope.onStart!==undefined){\n\nscope.onStart(url,itemsLoaded,itemsTotal);\n\n}\n\n}\n\nisLoading=true;\n\n};\n\nthis.itemEnd=function(url){\n\nitemsLoaded++;\n\nif(scope.onProgress!==undefined){\n\nscope.onProgress(url,itemsLoaded,itemsTotal);\n\n}\n\nif(itemsLoaded===itemsTotal){\n\nisLoading=false;\n\nif(scope.onLoad!==undefined){\n\nscope.onLoad();\n\n}\n\n}\n\n};\n\nthis.itemError=function(url){\n\nif(scope.onError!==undefined){\n\nscope.onError(url);\n\n}\n\n};\n\n}\n\nvar DefaultLoadingManager=new LoadingManager();\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction FileLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n}\n\nObject.assign(FileLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nif(url===undefined)url='';\n\nif(this.path!==undefined)url=this.path+url;\n\nvar scope=this;\n\nvar cached=Cache.get(url);\n\nif(cached!==undefined){\n\nscope.manager.itemStart(url);\n\nsetTimeout(function(){\n\nif(onLoad)onLoad(cached);\n\nscope.manager.itemEnd(url);\n\n},0);\n\nreturn cached;\n\n}\n\n// Check for data: URI\nvar dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;\nvar dataUriRegexResult=url.match(dataUriRegex);\n\n// Safari can not handle Data URIs through XMLHttpRequest so process manually\nif(dataUriRegexResult){\n\nvar mimeType=dataUriRegexResult[1];\nvar isBase64=!!dataUriRegexResult[2];\nvar data=dataUriRegexResult[3];\n\ndata=window.decodeURIComponent(data);\n\nif(isBase64)data=window.atob(data);\n\ntry{\n\nvar response;\nvar responseType=(this.responseType||'').toLowerCase();\n\nswitch(responseType){\n\ncase'arraybuffer':\ncase'blob':\n\nresponse=new ArrayBuffer(data.length);\n\nvar view=new Uint8Array(response);\n\nfor(var i=0;i<data.length;i++){\n\nview[i]=data.charCodeAt(i);\n\n}\n\nif(responseType==='blob'){\n\nresponse=new Blob([response],{type:mimeType});\n\n}\n\nbreak;\n\ncase'document':\n\nvar parser=new DOMParser();\nresponse=parser.parseFromString(data,mimeType);\n\nbreak;\n\ncase'json':\n\nresponse=JSON.parse(data);\n\nbreak;\n\ndefault:// 'text' or other\n\nresponse=data;\n\nbreak;}\n\n\n\n// Wait for next browser tick\nwindow.setTimeout(function(){\n\nif(onLoad)onLoad(response);\n\nscope.manager.itemEnd(url);\n\n},0);\n\n}catch(error){\n\n// Wait for next browser tick\nwindow.setTimeout(function(){\n\nif(onError)onError(error);\n\nscope.manager.itemError(url);\n\n},0);\n\n}\n\n}else{\n\nvar request=new XMLHttpRequest();\nrequest.open('GET',url,true);\n\nrequest.addEventListener('load',function(event){\n\nvar response=event.target.response;\n\nCache.add(url,response);\n\nif(this.status===200){\n\nif(onLoad)onLoad(response);\n\nscope.manager.itemEnd(url);\n\n}else if(this.status===0){\n\n// Some browsers return HTTP Status 0 when using non-http protocol\n// e.g. 'file://' or 'data://'. Handle as success.\n\nconsole.warn('THREE.FileLoader: HTTP Status 0 received.');\n\nif(onLoad)onLoad(response);\n\nscope.manager.itemEnd(url);\n\n}else{\n\nif(onError)onError(event);\n\nscope.manager.itemError(url);\n\n}\n\n},false);\n\nif(onProgress!==undefined){\n\nrequest.addEventListener('progress',function(event){\n\nonProgress(event);\n\n},false);\n\n}\n\nrequest.addEventListener('error',function(event){\n\nif(onError)onError(event);\n\nscope.manager.itemError(url);\n\n},false);\n\nif(this.responseType!==undefined)request.responseType=this.responseType;\nif(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;\n\nif(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');\n\nrequest.send(null);\n\n}\n\nscope.manager.itemStart(url);\n\nreturn request;\n\n},\n\nsetPath:function setPath(value){\n\nthis.path=value;\nreturn this;\n\n},\n\nsetResponseType:function setResponseType(value){\n\nthis.responseType=value;\nreturn this;\n\n},\n\nsetWithCredentials:function setWithCredentials(value){\n\nthis.withCredentials=value;\nreturn this;\n\n},\n\nsetMimeType:function setMimeType(value){\n\nthis.mimeType=value;\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t *\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t */\n\nfunction CompressedTextureLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n// override in sub classes\nthis._parser=null;\n\n}\n\nObject.assign(CompressedTextureLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nvar scope=this;\n\nvar images=[];\n\nvar texture=new CompressedTexture();\ntexture.image=images;\n\nvar loader=new FileLoader(this.manager);\nloader.setPath(this.path);\nloader.setResponseType('arraybuffer');\n\nfunction loadTexture(i){\n\nloader.load(url[i],function(buffer){\n\nvar texDatas=scope._parser(buffer,true);\n\nimages[i]={\nwidth:texDatas.width,\nheight:texDatas.height,\nformat:texDatas.format,\nmipmaps:texDatas.mipmaps};\n\n\nloaded+=1;\n\nif(loaded===6){\n\nif(texDatas.mipmapCount===1)\ntexture.minFilter=LinearFilter;\n\ntexture.format=texDatas.format;\ntexture.needsUpdate=true;\n\nif(onLoad)onLoad(texture);\n\n}\n\n},onProgress,onError);\n\n}\n\nif(Array.isArray(url)){\n\nvar loaded=0;\n\nfor(var i=0,il=url.length;i<il;++i){\n\nloadTexture(i);\n\n}\n\n}else{\n\n// compressed cubemap texture stored in a single DDS file\n\nloader.load(url,function(buffer){\n\nvar texDatas=scope._parser(buffer,true);\n\nif(texDatas.isCubemap){\n\nvar faces=texDatas.mipmaps.length/texDatas.mipmapCount;\n\nfor(var f=0;f<faces;f++){\n\nimages[f]={mipmaps:[]};\n\nfor(var i=0;i<texDatas.mipmapCount;i++){\n\nimages[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+i]);\nimages[f].format=texDatas.format;\nimages[f].width=texDatas.width;\nimages[f].height=texDatas.height;\n\n}\n\n}\n\n}else{\n\ntexture.image.width=texDatas.width;\ntexture.image.height=texDatas.height;\ntexture.mipmaps=texDatas.mipmaps;\n\n}\n\nif(texDatas.mipmapCount===1){\n\ntexture.minFilter=LinearFilter;\n\n}\n\ntexture.format=texDatas.format;\ntexture.needsUpdate=true;\n\nif(onLoad)onLoad(texture);\n\n},onProgress,onError);\n\n}\n\nreturn texture;\n\n},\n\nsetPath:function setPath(value){\n\nthis.path=value;\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author Nikos M. / https://github.com/foo123/\n\t *\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t */\n\nfunction DataTextureLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n// override in sub classes\nthis._parser=null;\n\n}\n\nObject.assign(DataTextureLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nvar scope=this;\n\nvar texture=new DataTexture();\n\nvar loader=new FileLoader(this.manager);\nloader.setResponseType('arraybuffer');\n\nloader.load(url,function(buffer){\n\nvar texData=scope._parser(buffer);\n\nif(!texData)return;\n\nif(undefined!==texData.image){\n\ntexture.image=texData.image;\n\n}else if(undefined!==texData.data){\n\ntexture.image.width=texData.width;\ntexture.image.height=texData.height;\ntexture.image.data=texData.data;\n\n}\n\ntexture.wrapS=undefined!==texData.wrapS?texData.wrapS:ClampToEdgeWrapping;\ntexture.wrapT=undefined!==texData.wrapT?texData.wrapT:ClampToEdgeWrapping;\n\ntexture.magFilter=undefined!==texData.magFilter?texData.magFilter:LinearFilter;\ntexture.minFilter=undefined!==texData.minFilter?texData.minFilter:LinearMipMapLinearFilter;\n\ntexture.anisotropy=undefined!==texData.anisotropy?texData.anisotropy:1;\n\nif(undefined!==texData.format){\n\ntexture.format=texData.format;\n\n}\nif(undefined!==texData.type){\n\ntexture.type=texData.type;\n\n}\n\nif(undefined!==texData.mipmaps){\n\ntexture.mipmaps=texData.mipmaps;\n\n}\n\nif(1===texData.mipmapCount){\n\ntexture.minFilter=LinearFilter;\n\n}\n\ntexture.needsUpdate=true;\n\nif(onLoad)onLoad(texture,texData);\n\n},onProgress,onError);\n\n\nreturn texture;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction ImageLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n}\n\nObject.assign(ImageLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nif(url===undefined)url='';\n\nif(this.path!==undefined)url=this.path+url;\n\nvar scope=this;\n\nvar cached=Cache.get(url);\n\nif(cached!==undefined){\n\nscope.manager.itemStart(url);\n\nsetTimeout(function(){\n\nif(onLoad)onLoad(cached);\n\nscope.manager.itemEnd(url);\n\n},0);\n\nreturn cached;\n\n}\n\nvar image=document.createElementNS('http://www.w3.org/1999/xhtml','img');\n\nimage.addEventListener('load',function(){\n\nCache.add(url,this);\n\nif(onLoad)onLoad(this);\n\nscope.manager.itemEnd(url);\n\n},false);\n\n/*\n\t\t\timage.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tif ( onProgress ) onProgress( event );\n\n\t\t\t}, false );\n\t\t\t*/\n\nimage.addEventListener('error',function(event){\n\nif(onError)onError(event);\n\nscope.manager.itemError(url);\n\n},false);\n\nif(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;\n\nscope.manager.itemStart(url);\n\nimage.src=url;\n\nreturn image;\n\n},\n\nsetCrossOrigin:function setCrossOrigin(value){\n\nthis.crossOrigin=value;\nreturn this;\n\n},\n\nsetPath:function setPath(value){\n\nthis.path=value;\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction CubeTextureLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n}\n\nObject.assign(CubeTextureLoader.prototype,{\n\nload:function load(urls,onLoad,onProgress,onError){\n\nvar texture=new CubeTexture();\n\nvar loader=new ImageLoader(this.manager);\nloader.setCrossOrigin(this.crossOrigin);\nloader.setPath(this.path);\n\nvar loaded=0;\n\nfunction loadTexture(i){\n\nloader.load(urls[i],function(image){\n\ntexture.images[i]=image;\n\nloaded++;\n\nif(loaded===6){\n\ntexture.needsUpdate=true;\n\nif(onLoad)onLoad(texture);\n\n}\n\n},undefined,onError);\n\n}\n\nfor(var i=0;i<urls.length;++i){\n\nloadTexture(i);\n\n}\n\nreturn texture;\n\n},\n\nsetCrossOrigin:function setCrossOrigin(value){\n\nthis.crossOrigin=value;\nreturn this;\n\n},\n\nsetPath:function setPath(value){\n\nthis.path=value;\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction TextureLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n}\n\nObject.assign(TextureLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nvar texture=new Texture();\n\nvar loader=new ImageLoader(this.manager);\nloader.setCrossOrigin(this.crossOrigin);\nloader.setPath(this.path);\nloader.load(url,function(image){\n\n// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\nvar isJPEG=url.search(/\\.(jpg|jpeg)$/)>0||url.search(/^data\\:image\\/jpeg/)===0;\n\ntexture.format=isJPEG?RGBFormat:RGBAFormat;\ntexture.image=image;\ntexture.needsUpdate=true;\n\nif(onLoad!==undefined){\n\nonLoad(texture);\n\n}\n\n},onProgress,onError);\n\nreturn texture;\n\n},\n\nsetCrossOrigin:function setCrossOrigin(value){\n\nthis.crossOrigin=value;\nreturn this;\n\n},\n\nsetPath:function setPath(value){\n\nthis.path=value;\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction Light(color,intensity){\n\nObject3D.call(this);\n\nthis.type='Light';\n\nthis.color=new Color(color);\nthis.intensity=intensity!==undefined?intensity:1;\n\nthis.receiveShadow=undefined;\n\n}\n\nLight.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:Light,\n\nisLight:true,\n\ncopy:function copy(source){\n\nObject3D.prototype.copy.call(this,source);\n\nthis.color.copy(source.color);\nthis.intensity=source.intensity;\n\nreturn this;\n\n},\n\ntoJSON:function toJSON(meta){\n\nvar data=Object3D.prototype.toJSON.call(this,meta);\n\ndata.object.color=this.color.getHex();\ndata.object.intensity=this.intensity;\n\nif(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();\n\nif(this.distance!==undefined)data.object.distance=this.distance;\nif(this.angle!==undefined)data.object.angle=this.angle;\nif(this.decay!==undefined)data.object.decay=this.decay;\nif(this.penumbra!==undefined)data.object.penumbra=this.penumbra;\n\nif(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();\n\nreturn data;\n\n}});\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction HemisphereLight(skyColor,groundColor,intensity){\n\nLight.call(this,skyColor,intensity);\n\nthis.type='HemisphereLight';\n\nthis.castShadow=undefined;\n\nthis.position.copy(Object3D.DefaultUp);\nthis.updateMatrix();\n\nthis.groundColor=new Color(groundColor);\n\n}\n\nHemisphereLight.prototype=Object.assign(Object.create(Light.prototype),{\n\nconstructor:HemisphereLight,\n\nisHemisphereLight:true,\n\ncopy:function copy(source){\n\nLight.prototype.copy.call(this,source);\n\nthis.groundColor.copy(source.groundColor);\n\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction LightShadow(camera){\n\nthis.camera=camera;\n\nthis.bias=0;\nthis.radius=1;\n\nthis.mapSize=new Vector2(512,512);\n\nthis.map=null;\nthis.matrix=new Matrix4();\n\n}\n\nObject.assign(LightShadow.prototype,{\n\ncopy:function copy(source){\n\nthis.camera=source.camera.clone();\n\nthis.bias=source.bias;\nthis.radius=source.radius;\n\nthis.mapSize.copy(source.mapSize);\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ntoJSON:function toJSON(){\n\nvar object={};\n\nif(this.bias!==0)object.bias=this.bias;\nif(this.radius!==1)object.radius=this.radius;\nif(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();\n\nobject.camera=this.camera.toJSON(false).object;\ndelete object.camera.matrix;\n\nreturn object;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction SpotLightShadow(){\n\nLightShadow.call(this,new PerspectiveCamera(50,1,0.5,500));\n\n}\n\nSpotLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{\n\nconstructor:SpotLightShadow,\n\nisSpotLightShadow:true,\n\nupdate:function update(light){\n\nvar fov=_Math.RAD2DEG*2*light.angle;\nvar aspect=this.mapSize.width/this.mapSize.height;\nvar far=light.distance||500;\n\nvar camera=this.camera;\n\nif(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){\n\ncamera.fov=fov;\ncamera.aspect=aspect;\ncamera.far=far;\ncamera.updateProjectionMatrix();\n\n}\n\n}});\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction SpotLight(color,intensity,distance,angle,penumbra,decay){\n\nLight.call(this,color,intensity);\n\nthis.type='SpotLight';\n\nthis.position.copy(Object3D.DefaultUp);\nthis.updateMatrix();\n\nthis.target=new Object3D();\n\nObject.defineProperty(this,'power',{\nget:function get(){\n// intensity = power per solid angle.\n// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\nreturn this.intensity*Math.PI;\n},\nset:function set(power){\n// intensity = power per solid angle.\n// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\nthis.intensity=power/Math.PI;\n}});\n\n\nthis.distance=distance!==undefined?distance:0;\nthis.angle=angle!==undefined?angle:Math.PI/3;\nthis.penumbra=penumbra!==undefined?penumbra:0;\nthis.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.\n\nthis.shadow=new SpotLightShadow();\n\n}\n\nSpotLight.prototype=Object.assign(Object.create(Light.prototype),{\n\nconstructor:SpotLight,\n\nisSpotLight:true,\n\ncopy:function copy(source){\n\nLight.prototype.copy.call(this,source);\n\nthis.distance=source.distance;\nthis.angle=source.angle;\nthis.penumbra=source.penumbra;\nthis.decay=source.decay;\n\nthis.target=source.target.clone();\n\nthis.shadow=source.shadow.clone();\n\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\n\nfunction PointLight(color,intensity,distance,decay){\n\nLight.call(this,color,intensity);\n\nthis.type='PointLight';\n\nObject.defineProperty(this,'power',{\nget:function get(){\n// intensity = power per solid angle.\n// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\nreturn this.intensity*4*Math.PI;\n\n},\nset:function set(power){\n// intensity = power per solid angle.\n// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\nthis.intensity=power/(4*Math.PI);\n}});\n\n\nthis.distance=distance!==undefined?distance:0;\nthis.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.\n\nthis.shadow=new LightShadow(new PerspectiveCamera(90,1,0.5,500));\n\n}\n\nPointLight.prototype=Object.assign(Object.create(Light.prototype),{\n\nconstructor:PointLight,\n\nisPointLight:true,\n\ncopy:function copy(source){\n\nLight.prototype.copy.call(this,source);\n\nthis.distance=source.distance;\nthis.decay=source.decay;\n\nthis.shadow=source.shadow.clone();\n\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction DirectionalLightShadow(){\n\nLightShadow.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));\n\n}\n\nDirectionalLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{\n\nconstructor:DirectionalLightShadow});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction DirectionalLight(color,intensity){\n\nLight.call(this,color,intensity);\n\nthis.type='DirectionalLight';\n\nthis.position.copy(Object3D.DefaultUp);\nthis.updateMatrix();\n\nthis.target=new Object3D();\n\nthis.shadow=new DirectionalLightShadow();\n\n}\n\nDirectionalLight.prototype=Object.assign(Object.create(Light.prototype),{\n\nconstructor:DirectionalLight,\n\nisDirectionalLight:true,\n\ncopy:function copy(source){\n\nLight.prototype.copy.call(this,source);\n\nthis.target=source.target.clone();\n\nthis.shadow=source.shadow.clone();\n\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction AmbientLight(color,intensity){\n\nLight.call(this,color,intensity);\n\nthis.type='AmbientLight';\n\nthis.castShadow=undefined;\n\n}\n\nAmbientLight.prototype=Object.assign(Object.create(Light.prototype),{\n\nconstructor:AmbientLight,\n\nisAmbientLight:true});\n\n\n\n/**\n\t * @author tschw\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\nvar AnimationUtils={\n\n// same as Array.prototype.slice, but also works on typed arrays\narraySlice:function arraySlice(array,from,to){\n\nif(AnimationUtils.isTypedArray(array)){\n\nreturn new array.constructor(array.subarray(from,to));\n\n}\n\nreturn array.slice(from,to);\n\n},\n\n// converts an array to a specific type\nconvertArray:function convertArray(array,type,forceClone){\n\nif(!array||// let 'undefined' and 'null' pass\n!forceClone&&array.constructor===type)return array;\n\nif(typeof type.BYTES_PER_ELEMENT==='number'){\n\nreturn new type(array);// create typed array\n\n}\n\nreturn Array.prototype.slice.call(array);// create Array\n\n},\n\nisTypedArray:function isTypedArray(object){\n\nreturn ArrayBuffer.isView(object)&&\n!(object instanceof DataView);\n\n},\n\n// returns an array by which times and values can be sorted\ngetKeyframeOrder:function getKeyframeOrder(times){\n\nfunction compareTime(i,j){\n\nreturn times[i]-times[j];\n\n}\n\nvar n=times.length;\nvar result=new Array(n);\nfor(var i=0;i!==n;++i){result[i]=i;}\n\nresult.sort(compareTime);\n\nreturn result;\n\n},\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nsortedArray:function sortedArray(values,stride,order){\n\nvar nValues=values.length;\nvar result=new values.constructor(nValues);\n\nfor(var i=0,dstOffset=0;dstOffset!==nValues;++i){\n\nvar srcOffset=order[i]*stride;\n\nfor(var j=0;j!==stride;++j){\n\nresult[dstOffset++]=values[srcOffset+j];\n\n}\n\n}\n\nreturn result;\n\n},\n\n// function for parsing AOS keyframe formats\nflattenJSON:function flattenJSON(jsonKeys,times,values,valuePropertyName){\n\nvar i=1,key=jsonKeys[0];\n\nwhile(key!==undefined&&key[valuePropertyName]===undefined){\n\nkey=jsonKeys[i++];\n\n}\n\nif(key===undefined)return;// no data\n\nvar value=key[valuePropertyName];\nif(value===undefined)return;// no data\n\nif(Array.isArray(value)){\n\ndo{\n\nvalue=key[valuePropertyName];\n\nif(value!==undefined){\n\ntimes.push(key.time);\nvalues.push.apply(values,value);// push all elements\n\n}\n\nkey=jsonKeys[i++];\n\n}while(key!==undefined);\n\n}else if(value.toArray!==undefined){\n// ...assume THREE.Math-ish\n\ndo{\n\nvalue=key[valuePropertyName];\n\nif(value!==undefined){\n\ntimes.push(key.time);\nvalue.toArray(values,values.length);\n\n}\n\nkey=jsonKeys[i++];\n\n}while(key!==undefined);\n\n}else{\n// otherwise push as-is\n\ndo{\n\nvalue=key[valuePropertyName];\n\nif(value!==undefined){\n\ntimes.push(key.time);\nvalues.push(value);\n\n}\n\nkey=jsonKeys[i++];\n\n}while(key!==undefined);\n\n}\n\n}};\n\n\n\n/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t * @author tschw\n\t */\n\nfunction Interpolant(\nparameterPositions,sampleValues,sampleSize,resultBuffer){\n\nthis.parameterPositions=parameterPositions;\nthis._cachedIndex=0;\n\nthis.resultBuffer=resultBuffer!==undefined?\nresultBuffer:new sampleValues.constructor(sampleSize);\nthis.sampleValues=sampleValues;\nthis.valueSize=sampleSize;\n\n}\n\nInterpolant.prototype={\n\nconstructor:Interpolant,\n\nevaluate:function evaluate(t){\n\nvar pp=this.parameterPositions,\ni1=this._cachedIndex,\n\nt1=pp[i1],\nt0=pp[i1-1];\n\nvalidate_interval:{\n\nseek:{\n\nvar right;\n\nlinear_scan:{\n//- See http://jsperf.com/comparison-to-undefined/3\n//- slower code:\n//-\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\nforward_scan:if(!(t<t1)){\n\nfor(var giveUpAt=i1+2;;){\n\nif(t1===undefined){\n\nif(t<t0)break forward_scan;\n\n// after end\n\ni1=pp.length;\nthis._cachedIndex=i1;\nreturn this.afterEnd_(i1-1,t,t0);\n\n}\n\nif(i1===giveUpAt)break;// this loop\n\nt0=t1;\nt1=pp[++i1];\n\nif(t<t1){\n\n// we have arrived at the sought interval\nbreak seek;\n\n}\n\n}\n\n// prepare binary search on the right side of the index\nright=pp.length;\nbreak linear_scan;\n\n}\n\n//- slower code:\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\nif(!(t>=t0)){\n\n// looping?\n\nvar t1global=pp[1];\n\nif(t<t1global){\n\ni1=2;// + 1, using the scan for the details\nt0=t1global;\n\n}\n\n// linear reverse scan\n\nfor(var giveUpAt=i1-2;;){\n\nif(t0===undefined){\n\n// before start\n\nthis._cachedIndex=0;\nreturn this.beforeStart_(0,t,t1);\n\n}\n\nif(i1===giveUpAt)break;// this loop\n\nt1=t0;\nt0=pp[--i1-1];\n\nif(t>=t0){\n\n// we have arrived at the sought interval\nbreak seek;\n\n}\n\n}\n\n// prepare binary search on the left side of the index\nright=i1;\ni1=0;\nbreak linear_scan;\n\n}\n\n// the interval is valid\n\nbreak validate_interval;\n\n}// linear scan\n\n// binary search\n\nwhile(i1<right){\n\nvar mid=i1+right>>>1;\n\nif(t<pp[mid]){\n\nright=mid;\n\n}else{\n\ni1=mid+1;\n\n}\n\n}\n\nt1=pp[i1];\nt0=pp[i1-1];\n\n// check boundary cases, again\n\nif(t0===undefined){\n\nthis._cachedIndex=0;\nreturn this.beforeStart_(0,t,t1);\n\n}\n\nif(t1===undefined){\n\ni1=pp.length;\nthis._cachedIndex=i1;\nreturn this.afterEnd_(i1-1,t0,t);\n\n}\n\n}// seek\n\nthis._cachedIndex=i1;\n\nthis.intervalChanged_(i1,t0,t1);\n\n}// validate_interval\n\nreturn this.interpolate_(i1,t0,t,t1);\n\n},\n\nsettings:null,// optional, subclass-specific settings structure\n// Note: The indirection allows central control of many interpolants.\n\n// --- Protected interface\n\nDefaultSettings_:{},\n\ngetSettings_:function getSettings_(){\n\nreturn this.settings||this.DefaultSettings_;\n\n},\n\ncopySampleValue_:function copySampleValue_(index){\n\n// copies a sample value to the result buffer\n\nvar result=this.resultBuffer,\nvalues=this.sampleValues,\nstride=this.valueSize,\noffset=index*stride;\n\nfor(var i=0;i!==stride;++i){\n\nresult[i]=values[offset+i];\n\n}\n\nreturn result;\n\n},\n\n// Template methods for derived classes:\n\ninterpolate_:function interpolate_(i1,t0,t,t1){\n\nthrow new Error(\"call to abstract method\");\n// implementations shall return this.resultBuffer\n\n},\n\nintervalChanged_:function intervalChanged_(i1,t0,t1){\n\n// empty\n\n}};\n\n\n\nObject.assign(Interpolant.prototype,{\n\nbeforeStart_://( 0, t, t0 ), returns this.resultBuffer\nInterpolant.prototype.copySampleValue_,\n\nafterEnd_://( N-1, tN-1, t ), returns this.resultBuffer\nInterpolant.prototype.copySampleValue_});\n\n\n\n/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t *\n\t * @author tschw\n\t */\n\nfunction CubicInterpolant(\nparameterPositions,sampleValues,sampleSize,resultBuffer){\n\nInterpolant.call(\nthis,parameterPositions,sampleValues,sampleSize,resultBuffer);\n\nthis._weightPrev=-0;\nthis._offsetPrev=-0;\nthis._weightNext=-0;\nthis._offsetNext=-0;\n\n}\n\nCubicInterpolant.prototype=\nObject.assign(Object.create(Interpolant.prototype),{\n\nconstructor:CubicInterpolant,\n\nDefaultSettings_:{\n\nendingStart:ZeroCurvatureEnding,\nendingEnd:ZeroCurvatureEnding},\n\n\n\nintervalChanged_:function intervalChanged_(i1,t0,t1){\n\nvar pp=this.parameterPositions,\niPrev=i1-2,\niNext=i1+1,\n\ntPrev=pp[iPrev],\ntNext=pp[iNext];\n\nif(tPrev===undefined){\n\nswitch(this.getSettings_().endingStart){\n\ncase ZeroSlopeEnding:\n\n// f'(t0) = 0\niPrev=i1;\ntPrev=2*t0-t1;\n\nbreak;\n\ncase WrapAroundEnding:\n\n// use the other end of the curve\niPrev=pp.length-2;\ntPrev=t0+pp[iPrev]-pp[iPrev+1];\n\nbreak;\n\ndefault:// ZeroCurvatureEnding\n\n// f''(t0) = 0 a.k.a. Natural Spline\niPrev=i1;\ntPrev=t1;}\n\n\n\n}\n\nif(tNext===undefined){\n\nswitch(this.getSettings_().endingEnd){\n\ncase ZeroSlopeEnding:\n\n// f'(tN) = 0\niNext=i1;\ntNext=2*t1-t0;\n\nbreak;\n\ncase WrapAroundEnding:\n\n// use the other end of the curve\niNext=1;\ntNext=t1+pp[1]-pp[0];\n\nbreak;\n\ndefault:// ZeroCurvatureEnding\n\n// f''(tN) = 0, a.k.a. Natural Spline\niNext=i1-1;\ntNext=t0;}\n\n\n\n}\n\nvar halfDt=(t1-t0)*0.5,\nstride=this.valueSize;\n\nthis._weightPrev=halfDt/(t0-tPrev);\nthis._weightNext=halfDt/(tNext-t1);\nthis._offsetPrev=iPrev*stride;\nthis._offsetNext=iNext*stride;\n\n},\n\ninterpolate_:function interpolate_(i1,t0,t,t1){\n\nvar result=this.resultBuffer,\nvalues=this.sampleValues,\nstride=this.valueSize,\n\no1=i1*stride,o0=o1-stride,\noP=this._offsetPrev,oN=this._offsetNext,\nwP=this._weightPrev,wN=this._weightNext,\n\np=(t-t0)/(t1-t0),\npp=p*p,\nppp=pp*p;\n\n// evaluate polynomials\n\nvar sP=-wP*ppp+2*wP*pp-wP*p;\nvar s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;\nvar s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;\nvar sN=wN*ppp-wN*pp;\n\n// combine data linearly\n\nfor(var i=0;i!==stride;++i){\n\nresult[i]=\nsP*values[oP+i]+\ns0*values[o0+i]+\ns1*values[o1+i]+\nsN*values[oN+i];\n\n}\n\nreturn result;\n\n}});\n\n\n\n/**\n\t * @author tschw\n\t */\n\nfunction LinearInterpolant(\nparameterPositions,sampleValues,sampleSize,resultBuffer){\n\nInterpolant.call(\nthis,parameterPositions,sampleValues,sampleSize,resultBuffer);\n\n}\n\nLinearInterpolant.prototype=\nObject.assign(Object.create(Interpolant.prototype),{\n\nconstructor:LinearInterpolant,\n\ninterpolate_:function interpolate_(i1,t0,t,t1){\n\nvar result=this.resultBuffer,\nvalues=this.sampleValues,\nstride=this.valueSize,\n\noffset1=i1*stride,\noffset0=offset1-stride,\n\nweight1=(t-t0)/(t1-t0),\nweight0=1-weight1;\n\nfor(var i=0;i!==stride;++i){\n\nresult[i]=\nvalues[offset0+i]*weight0+\nvalues[offset1+i]*weight1;\n\n}\n\nreturn result;\n\n}});\n\n\n\n/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t *\n\t * @author tschw\n\t */\n\nfunction DiscreteInterpolant(\nparameterPositions,sampleValues,sampleSize,resultBuffer){\n\nInterpolant.call(\nthis,parameterPositions,sampleValues,sampleSize,resultBuffer);\n\n}\n\nDiscreteInterpolant.prototype=\nObject.assign(Object.create(Interpolant.prototype),{\n\nconstructor:DiscreteInterpolant,\n\ninterpolate_:function interpolate_(i1,t0,t,t1){\n\nreturn this.copySampleValue_(i1-1);\n\n}});\n\n\n\nvar KeyframeTrackPrototype;\n\nKeyframeTrackPrototype={\n\nTimeBufferType:Float32Array,\nValueBufferType:Float32Array,\n\nDefaultInterpolation:InterpolateLinear,\n\nInterpolantFactoryMethodDiscrete:function InterpolantFactoryMethodDiscrete(result){\n\nreturn new DiscreteInterpolant(\nthis.times,this.values,this.getValueSize(),result);\n\n},\n\nInterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){\n\nreturn new LinearInterpolant(\nthis.times,this.values,this.getValueSize(),result);\n\n},\n\nInterpolantFactoryMethodSmooth:function InterpolantFactoryMethodSmooth(result){\n\nreturn new CubicInterpolant(\nthis.times,this.values,this.getValueSize(),result);\n\n},\n\nsetInterpolation:function setInterpolation(interpolation){\n\nvar factoryMethod;\n\nswitch(interpolation){\n\ncase InterpolateDiscrete:\n\nfactoryMethod=this.InterpolantFactoryMethodDiscrete;\n\nbreak;\n\ncase InterpolateLinear:\n\nfactoryMethod=this.InterpolantFactoryMethodLinear;\n\nbreak;\n\ncase InterpolateSmooth:\n\nfactoryMethod=this.InterpolantFactoryMethodSmooth;\n\nbreak;}\n\n\n\nif(factoryMethod===undefined){\n\nvar message=\"unsupported interpolation for \"+\nthis.ValueTypeName+\" keyframe track named \"+this.name;\n\nif(this.createInterpolant===undefined){\n\n// fall back to default, unless the default itself is messed up\nif(interpolation!==this.DefaultInterpolation){\n\nthis.setInterpolation(this.DefaultInterpolation);\n\n}else{\n\nthrow new Error(message);// fatal, in this case\n\n}\n\n}\n\nconsole.warn(message);\nreturn;\n\n}\n\nthis.createInterpolant=factoryMethod;\n\n},\n\ngetInterpolation:function getInterpolation(){\n\nswitch(this.createInterpolant){\n\ncase this.InterpolantFactoryMethodDiscrete:\n\nreturn InterpolateDiscrete;\n\ncase this.InterpolantFactoryMethodLinear:\n\nreturn InterpolateLinear;\n\ncase this.InterpolantFactoryMethodSmooth:\n\nreturn InterpolateSmooth;}\n\n\n\n},\n\ngetValueSize:function getValueSize(){\n\nreturn this.values.length/this.times.length;\n\n},\n\n// move all keyframes either forwards or backwards in time\nshift:function shift(timeOffset){\n\nif(timeOffset!==0.0){\n\nvar times=this.times;\n\nfor(var i=0,n=times.length;i!==n;++i){\n\ntimes[i]+=timeOffset;\n\n}\n\n}\n\nreturn this;\n\n},\n\n// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\nscale:function scale(timeScale){\n\nif(timeScale!==1.0){\n\nvar times=this.times;\n\nfor(var i=0,n=times.length;i!==n;++i){\n\ntimes[i]*=timeScale;\n\n}\n\n}\n\nreturn this;\n\n},\n\n// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\ntrim:function trim(startTime,endTime){\n\nvar times=this.times,\nnKeys=times.length,\nfrom=0,\nto=nKeys-1;\n\nwhile(from!==nKeys&&times[from]<startTime){++from;}\nwhile(to!==-1&&times[to]>endTime){--to;}\n\n++to;// inclusive -> exclusive bound\n\nif(from!==0||to!==nKeys){\n\n// empty tracks are forbidden, so keep at least one keyframe\nif(from>=to)to=Math.max(to,1),from=to-1;\n\nvar stride=this.getValueSize();\nthis.times=AnimationUtils.arraySlice(times,from,to);\nthis.values=AnimationUtils.\narraySlice(this.values,from*stride,to*stride);\n\n}\n\nreturn this;\n\n},\n\n// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\nvalidate:function validate(){\n\nvar valid=true;\n\nvar valueSize=this.getValueSize();\nif(valueSize-Math.floor(valueSize)!==0){\n\nconsole.error(\"invalid value size in track\",this);\nvalid=false;\n\n}\n\nvar times=this.times,\nvalues=this.values,\n\nnKeys=times.length;\n\nif(nKeys===0){\n\nconsole.error(\"track is empty\",this);\nvalid=false;\n\n}\n\nvar prevTime=null;\n\nfor(var i=0;i!==nKeys;i++){\n\nvar currTime=times[i];\n\nif(typeof currTime==='number'&&isNaN(currTime)){\n\nconsole.error(\"time is not a valid number\",this,i,currTime);\nvalid=false;\nbreak;\n\n}\n\nif(prevTime!==null&&prevTime>currTime){\n\nconsole.error(\"out of order keys\",this,i,currTime,prevTime);\nvalid=false;\nbreak;\n\n}\n\nprevTime=currTime;\n\n}\n\nif(values!==undefined){\n\nif(AnimationUtils.isTypedArray(values)){\n\nfor(var i=0,n=values.length;i!==n;++i){\n\nvar value=values[i];\n\nif(isNaN(value)){\n\nconsole.error(\"value is not a valid number\",this,i,value);\nvalid=false;\nbreak;\n\n}\n\n}\n\n}\n\n}\n\nreturn valid;\n\n},\n\n// removes equivalent sequential keys as common in morph target sequences\n// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\noptimize:function optimize(){\n\nvar times=this.times,\nvalues=this.values,\nstride=this.getValueSize(),\n\nsmoothInterpolation=this.getInterpolation()===InterpolateSmooth,\n\nwriteIndex=1,\nlastIndex=times.length-1;\n\nfor(var i=1;i<lastIndex;++i){\n\nvar keep=false;\n\nvar time=times[i];\nvar timeNext=times[i+1];\n\n// remove adjacent keyframes scheduled at the same time\n\nif(time!==timeNext&&(i!==1||time!==time[0])){\n\nif(!smoothInterpolation){\n\n// remove unnecessary keyframes same as their neighbors\n\nvar offset=i*stride,\noffsetP=offset-stride,\noffsetN=offset+stride;\n\nfor(var j=0;j!==stride;++j){\n\nvar value=values[offset+j];\n\nif(value!==values[offsetP+j]||\nvalue!==values[offsetN+j]){\n\nkeep=true;\nbreak;\n\n}\n\n}\n\n}else keep=true;\n\n}\n\n// in-place compaction\n\nif(keep){\n\nif(i!==writeIndex){\n\ntimes[writeIndex]=times[i];\n\nvar readOffset=i*stride,\nwriteOffset=writeIndex*stride;\n\nfor(var j=0;j!==stride;++j){\n\nvalues[writeOffset+j]=values[readOffset+j];}\n\n}\n\n++writeIndex;\n\n}\n\n}\n\n// flush last keyframe (compaction looks ahead)\n\nif(lastIndex>0){\n\ntimes[writeIndex]=times[lastIndex];\n\nfor(var readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j){\n\nvalues[writeOffset+j]=values[readOffset+j];}\n\n++writeIndex;\n\n}\n\nif(writeIndex!==times.length){\n\nthis.times=AnimationUtils.arraySlice(times,0,writeIndex);\nthis.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);\n\n}\n\nreturn this;\n\n}};\n\n\n\nfunction KeyframeTrackConstructor(name,times,values,interpolation){\n\nif(name===undefined)throw new Error(\"track name is undefined\");\n\nif(times===undefined||times.length===0){\n\nthrow new Error(\"no keyframes in track named \"+name);\n\n}\n\nthis.name=name;\n\nthis.times=AnimationUtils.convertArray(times,this.TimeBufferType);\nthis.values=AnimationUtils.convertArray(values,this.ValueBufferType);\n\nthis.setInterpolation(interpolation||this.DefaultInterpolation);\n\nthis.validate();\nthis.optimize();\n\n}\n\n/**\n\t *\n\t * A Track of vectored keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction VectorKeyframeTrack(name,times,values,interpolation){\n\nKeyframeTrackConstructor.call(this,name,times,values,interpolation);\n\n}\n\nVectorKeyframeTrack.prototype=\nObject.assign(Object.create(KeyframeTrackPrototype),{\n\nconstructor:VectorKeyframeTrack,\n\nValueTypeName:'vector'\n\n// ValueBufferType is inherited\n\n// DefaultInterpolation is inherited\n});\n\n\n/**\n\t * Spherical linear unit quaternion interpolant.\n\t *\n\t * @author tschw\n\t */\n\nfunction QuaternionLinearInterpolant(\nparameterPositions,sampleValues,sampleSize,resultBuffer){\n\nInterpolant.call(\nthis,parameterPositions,sampleValues,sampleSize,resultBuffer);\n\n}\n\nQuaternionLinearInterpolant.prototype=\nObject.assign(Object.create(Interpolant.prototype),{\n\nconstructor:QuaternionLinearInterpolant,\n\ninterpolate_:function interpolate_(i1,t0,t,t1){\n\nvar result=this.resultBuffer,\nvalues=this.sampleValues,\nstride=this.valueSize,\n\noffset=i1*stride,\n\nalpha=(t-t0)/(t1-t0);\n\nfor(var end=offset+stride;offset!==end;offset+=4){\n\nQuaternion.slerpFlat(result,0,\nvalues,offset-stride,values,offset,alpha);\n\n}\n\nreturn result;\n\n}});\n\n\n\n/**\n\t *\n\t * A Track of quaternion keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction QuaternionKeyframeTrack(name,times,values,interpolation){\n\nKeyframeTrackConstructor.call(this,name,times,values,interpolation);\n\n}\n\nQuaternionKeyframeTrack.prototype=\nObject.assign(Object.create(KeyframeTrackPrototype),{\n\nconstructor:QuaternionKeyframeTrack,\n\nValueTypeName:'quaternion',\n\n// ValueBufferType is inherited\n\nDefaultInterpolation:InterpolateLinear,\n\nInterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){\n\nreturn new QuaternionLinearInterpolant(\nthis.times,this.values,this.getValueSize(),result);\n\n},\n\nInterpolantFactoryMethodSmooth:undefined// not yet implemented\n});\n\n\n/**\n\t *\n\t * A Track of numeric keyframe values.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction NumberKeyframeTrack(name,times,values,interpolation){\n\nKeyframeTrackConstructor.call(this,name,times,values,interpolation);\n\n}\n\nNumberKeyframeTrack.prototype=\nObject.assign(Object.create(KeyframeTrackPrototype),{\n\nconstructor:NumberKeyframeTrack,\n\nValueTypeName:'number'\n\n// ValueBufferType is inherited\n\n// DefaultInterpolation is inherited\n});\n\n\n/**\n\t *\n\t * A Track that interpolates Strings\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction StringKeyframeTrack(name,times,values,interpolation){\n\nKeyframeTrackConstructor.call(this,name,times,values,interpolation);\n\n}\n\nStringKeyframeTrack.prototype=\nObject.assign(Object.create(KeyframeTrackPrototype),{\n\nconstructor:StringKeyframeTrack,\n\nValueTypeName:'string',\nValueBufferType:Array,\n\nDefaultInterpolation:InterpolateDiscrete,\n\nInterpolantFactoryMethodLinear:undefined,\n\nInterpolantFactoryMethodSmooth:undefined});\n\n\n\n/**\n\t *\n\t * A Track of Boolean keyframe values.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction BooleanKeyframeTrack(name,times,values){\n\nKeyframeTrackConstructor.call(this,name,times,values);\n\n}\n\nBooleanKeyframeTrack.prototype=\nObject.assign(Object.create(KeyframeTrackPrototype),{\n\nconstructor:BooleanKeyframeTrack,\n\nValueTypeName:'bool',\nValueBufferType:Array,\n\nDefaultInterpolation:InterpolateDiscrete,\n\nInterpolantFactoryMethodLinear:undefined,\nInterpolantFactoryMethodSmooth:undefined\n\n// Note: Actually this track could have a optimized / compressed\n// representation of a single value and a custom interpolant that\n// computes \"firstValue ^ isOdd( index )\".\n});\n\n\n/**\n\t *\n\t * A Track of keyframe values that represent color.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction ColorKeyframeTrack(name,times,values,interpolation){\n\nKeyframeTrackConstructor.call(this,name,times,values,interpolation);\n\n}\n\nColorKeyframeTrack.prototype=\nObject.assign(Object.create(KeyframeTrackPrototype),{\n\nconstructor:ColorKeyframeTrack,\n\nValueTypeName:'color'\n\n// ValueBufferType is inherited\n\n// DefaultInterpolation is inherited\n\n\n// Note: Very basic implementation and nothing special yet.\n// However, this is the place for color space parameterization.\n});\n\n\n/**\n\t *\n\t * A timed sequence of keyframes for a specific property.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction KeyframeTrack(name,times,values,interpolation){\n\nKeyframeTrackConstructor.apply(this,arguments);\n\n}\n\nKeyframeTrack.prototype=KeyframeTrackPrototype;\nKeyframeTrackPrototype.constructor=KeyframeTrack;\n\n// Static methods:\n\nObject.assign(KeyframeTrack,{\n\n// Serialization (in static context, because of constructor invocation\n// and automatic invocation of .toJSON):\n\nparse:function parse(json){\n\nif(json.type===undefined){\n\nthrow new Error(\"track type undefined, can not parse\");\n\n}\n\nvar trackType=KeyframeTrack._getTrackTypeForValueTypeName(json.type);\n\nif(json.times===undefined){\n\nvar times=[],values=[];\n\nAnimationUtils.flattenJSON(json.keys,times,values,'value');\n\njson.times=times;\njson.values=values;\n\n}\n\n// derived classes can define a static parse method\nif(trackType.parse!==undefined){\n\nreturn trackType.parse(json);\n\n}else{\n\n// by default, we asssume a constructor compatible with the base\nreturn new trackType(\njson.name,json.times,json.values,json.interpolation);\n\n}\n\n},\n\ntoJSON:function toJSON(track){\n\nvar trackType=track.constructor;\n\nvar json;\n\n// derived classes can define a static toJSON method\nif(trackType.toJSON!==undefined){\n\njson=trackType.toJSON(track);\n\n}else{\n\n// by default, we assume the data can be serialized as-is\njson={\n\n'name':track.name,\n'times':AnimationUtils.convertArray(track.times,Array),\n'values':AnimationUtils.convertArray(track.values,Array)};\n\n\n\nvar interpolation=track.getInterpolation();\n\nif(interpolation!==track.DefaultInterpolation){\n\njson.interpolation=interpolation;\n\n}\n\n}\n\njson.type=track.ValueTypeName;// mandatory\n\nreturn json;\n\n},\n\n_getTrackTypeForValueTypeName:function _getTrackTypeForValueTypeName(typeName){\n\nswitch(typeName.toLowerCase()){\n\ncase\"scalar\":\ncase\"double\":\ncase\"float\":\ncase\"number\":\ncase\"integer\":\n\nreturn NumberKeyframeTrack;\n\ncase\"vector\":\ncase\"vector2\":\ncase\"vector3\":\ncase\"vector4\":\n\nreturn VectorKeyframeTrack;\n\ncase\"color\":\n\nreturn ColorKeyframeTrack;\n\ncase\"quaternion\":\n\nreturn QuaternionKeyframeTrack;\n\ncase\"bool\":\ncase\"boolean\":\n\nreturn BooleanKeyframeTrack;\n\ncase\"string\":\n\nreturn StringKeyframeTrack;}\n\n\n\nthrow new Error(\"Unsupported typeName: \"+typeName);\n\n}});\n\n\n\n/**\n\t *\n\t * Reusable set of Tracks that represent an animation.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t */\n\nfunction AnimationClip(name,duration,tracks){\n\nthis.name=name;\nthis.tracks=tracks;\nthis.duration=duration!==undefined?duration:-1;\n\nthis.uuid=_Math.generateUUID();\n\n// this means it should figure out its duration by scanning the tracks\nif(this.duration<0){\n\nthis.resetDuration();\n\n}\n\nthis.optimize();\n\n}\n\nAnimationClip.prototype={\n\nconstructor:AnimationClip,\n\nresetDuration:function resetDuration(){\n\nvar tracks=this.tracks,\nduration=0;\n\nfor(var i=0,n=tracks.length;i!==n;++i){\n\nvar track=this.tracks[i];\n\nduration=Math.max(duration,track.times[track.times.length-1]);\n\n}\n\nthis.duration=duration;\n\n},\n\ntrim:function trim(){\n\nfor(var i=0;i<this.tracks.length;i++){\n\nthis.tracks[i].trim(0,this.duration);\n\n}\n\nreturn this;\n\n},\n\noptimize:function optimize(){\n\nfor(var i=0;i<this.tracks.length;i++){\n\nthis.tracks[i].optimize();\n\n}\n\nreturn this;\n\n}};\n\n\n\n// Static methods:\n\nObject.assign(AnimationClip,{\n\nparse:function parse(json){\n\nvar tracks=[],\njsonTracks=json.tracks,\nframeTime=1.0/(json.fps||1.0);\n\nfor(var i=0,n=jsonTracks.length;i!==n;++i){\n\ntracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));\n\n}\n\nreturn new AnimationClip(json.name,json.duration,tracks);\n\n},\n\n\ntoJSON:function toJSON(clip){\n\nvar tracks=[],\nclipTracks=clip.tracks;\n\nvar json={\n\n'name':clip.name,\n'duration':clip.duration,\n'tracks':tracks};\n\n\n\nfor(var i=0,n=clipTracks.length;i!==n;++i){\n\ntracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n\n}\n\nreturn json;\n\n},\n\n\nCreateFromMorphTargetSequence:function CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){\n\nvar numMorphTargets=morphTargetSequence.length;\nvar tracks=[];\n\nfor(var i=0;i<numMorphTargets;i++){\n\nvar times=[];\nvar values=[];\n\ntimes.push(\n(i+numMorphTargets-1)%numMorphTargets,\ni,\n(i+1)%numMorphTargets);\n\nvalues.push(0,1,0);\n\nvar order=AnimationUtils.getKeyframeOrder(times);\ntimes=AnimationUtils.sortedArray(times,1,order);\nvalues=AnimationUtils.sortedArray(values,1,order);\n\n// if there is a key at the first frame, duplicate it as the\n// last frame as well for perfect loop.\nif(!noLoop&&times[0]===0){\n\ntimes.push(numMorphTargets);\nvalues.push(values[0]);\n\n}\n\ntracks.push(\nnew NumberKeyframeTrack(\n'.morphTargetInfluences['+morphTargetSequence[i].name+']',\ntimes,values).\nscale(1.0/fps));\n}\n\nreturn new AnimationClip(name,-1,tracks);\n\n},\n\nfindByName:function findByName(objectOrClipArray,name){\n\nvar clipArray=objectOrClipArray;\n\nif(!Array.isArray(objectOrClipArray)){\n\nvar o=objectOrClipArray;\nclipArray=o.geometry&&o.geometry.animations||o.animations;\n\n}\n\nfor(var i=0;i<clipArray.length;i++){\n\nif(clipArray[i].name===name){\n\nreturn clipArray[i];\n\n}\n}\n\nreturn null;\n\n},\n\nCreateClipsFromMorphTargetSequences:function CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){\n\nvar animationToMorphTargets={};\n\n// tested with https://regex101.com/ on trick sequences\n// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\nvar pattern=/^([\\w-]*?)([\\d]+)$/;\n\n// sort morph target names into animation groups based\n// patterns like Walk_001, Walk_002, Run_001, Run_002\nfor(var i=0,il=morphTargets.length;i<il;i++){\n\nvar morphTarget=morphTargets[i];\nvar parts=morphTarget.name.match(pattern);\n\nif(parts&&parts.length>1){\n\nvar name=parts[1];\n\nvar animationMorphTargets=animationToMorphTargets[name];\nif(!animationMorphTargets){\n\nanimationToMorphTargets[name]=animationMorphTargets=[];\n\n}\n\nanimationMorphTargets.push(morphTarget);\n\n}\n\n}\n\nvar clips=[];\n\nfor(var name in animationToMorphTargets){\n\nclips.push(AnimationClip.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));\n\n}\n\nreturn clips;\n\n},\n\n// parse the animation.hierarchy format\nparseAnimation:function parseAnimation(animation,bones){\n\nif(!animation){\n\nconsole.error(\"  no animation in JSONLoader data\");\nreturn null;\n\n}\n\nvar addNonemptyTrack=function addNonemptyTrack(\ntrackType,trackName,animationKeys,propertyName,destTracks){\n\n// only return track if there are actually keys.\nif(animationKeys.length!==0){\n\nvar times=[];\nvar values=[];\n\nAnimationUtils.flattenJSON(\nanimationKeys,times,values,propertyName);\n\n// empty keys are filtered out, so check again\nif(times.length!==0){\n\ndestTracks.push(new trackType(trackName,times,values));\n\n}\n\n}\n\n};\n\nvar tracks=[];\n\nvar clipName=animation.name||'default';\n// automatic length determination in AnimationClip.\nvar duration=animation.length||-1;\nvar fps=animation.fps||30;\n\nvar hierarchyTracks=animation.hierarchy||[];\n\nfor(var h=0;h<hierarchyTracks.length;h++){\n\nvar animationKeys=hierarchyTracks[h].keys;\n\n// skip empty tracks\nif(!animationKeys||animationKeys.length===0)continue;\n\n// process morph targets in a way exactly compatible\n// with AnimationHandler.init( animation )\nif(animationKeys[0].morphTargets){\n\n// figure out all morph targets used in this track\nvar morphTargetNames={};\nfor(var k=0;k<animationKeys.length;k++){\n\nif(animationKeys[k].morphTargets){\n\nfor(var m=0;m<animationKeys[k].morphTargets.length;m++){\n\nmorphTargetNames[animationKeys[k].morphTargets[m]]=-1;\n}\n\n}\n\n}\n\n// create a track for each morph target with all zero\n// morphTargetInfluences except for the keys in which\n// the morphTarget is named.\nfor(var morphTargetName in morphTargetNames){\n\nvar times=[];\nvar values=[];\n\nfor(var m=0;m!==animationKeys[k].morphTargets.length;++m){\n\nvar animationKey=animationKeys[k];\n\ntimes.push(animationKey.time);\nvalues.push(animationKey.morphTarget===morphTargetName?1:0);\n\n}\n\ntracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));\n\n}\n\nduration=morphTargetNames.length*(fps||1.0);\n\n}else{\n// ...assume skeletal animation\n\nvar boneName='.bones['+bones[h].name+']';\n\naddNonemptyTrack(\nVectorKeyframeTrack,boneName+'.position',\nanimationKeys,'pos',tracks);\n\naddNonemptyTrack(\nQuaternionKeyframeTrack,boneName+'.quaternion',\nanimationKeys,'rot',tracks);\n\naddNonemptyTrack(\nVectorKeyframeTrack,boneName+'.scale',\nanimationKeys,'scl',tracks);\n\n}\n\n}\n\nif(tracks.length===0){\n\nreturn null;\n\n}\n\nvar clip=new AnimationClip(clipName,duration,tracks);\n\nreturn clip;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction MaterialLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\nthis.textures={};\n\n}\n\nObject.assign(MaterialLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nvar scope=this;\n\nvar loader=new FileLoader(scope.manager);\nloader.load(url,function(text){\n\nonLoad(scope.parse(JSON.parse(text)));\n\n},onProgress,onError);\n\n},\n\nsetTextures:function setTextures(value){\n\nthis.textures=value;\n\n},\n\nparse:function parse(json){\n\nvar textures=this.textures;\n\nfunction getTexture(name){\n\nif(textures[name]===undefined){\n\nconsole.warn('THREE.MaterialLoader: Undefined texture',name);\n\n}\n\nreturn textures[name];\n\n}\n\nvar material=new Materials[json.type]();\n\nif(json.uuid!==undefined)material.uuid=json.uuid;\nif(json.name!==undefined)material.name=json.name;\nif(json.color!==undefined)material.color.setHex(json.color);\nif(json.roughness!==undefined)material.roughness=json.roughness;\nif(json.metalness!==undefined)material.metalness=json.metalness;\nif(json.emissive!==undefined)material.emissive.setHex(json.emissive);\nif(json.specular!==undefined)material.specular.setHex(json.specular);\nif(json.shininess!==undefined)material.shininess=json.shininess;\nif(json.clearCoat!==undefined)material.clearCoat=json.clearCoat;\nif(json.clearCoatRoughness!==undefined)material.clearCoatRoughness=json.clearCoatRoughness;\nif(json.uniforms!==undefined)material.uniforms=json.uniforms;\nif(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;\nif(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;\nif(json.vertexColors!==undefined)material.vertexColors=json.vertexColors;\nif(json.fog!==undefined)material.fog=json.fog;\nif(json.shading!==undefined)material.shading=json.shading;\nif(json.blending!==undefined)material.blending=json.blending;\nif(json.side!==undefined)material.side=json.side;\nif(json.opacity!==undefined)material.opacity=json.opacity;\nif(json.transparent!==undefined)material.transparent=json.transparent;\nif(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;\nif(json.depthTest!==undefined)material.depthTest=json.depthTest;\nif(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;\nif(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;\nif(json.wireframe!==undefined)material.wireframe=json.wireframe;\nif(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;\nif(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;\nif(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;\nif(json.skinning!==undefined)material.skinning=json.skinning;\nif(json.morphTargets!==undefined)material.morphTargets=json.morphTargets;\n\n// for PointsMaterial\n\nif(json.size!==undefined)material.size=json.size;\nif(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;\n\n// maps\n\nif(json.map!==undefined)material.map=getTexture(json.map);\n\nif(json.alphaMap!==undefined){\n\nmaterial.alphaMap=getTexture(json.alphaMap);\nmaterial.transparent=true;\n\n}\n\nif(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);\nif(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;\n\nif(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);\nif(json.normalScale!==undefined){\n\nvar normalScale=json.normalScale;\n\nif(Array.isArray(normalScale)===false){\n\n// Blender exporter used to export a scalar. See #7459\n\nnormalScale=[normalScale,normalScale];\n\n}\n\nmaterial.normalScale=new Vector2().fromArray(normalScale);\n\n}\n\nif(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);\nif(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;\nif(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;\n\nif(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);\nif(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);\n\nif(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);\nif(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;\n\nif(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);\n\nif(json.envMap!==undefined)material.envMap=getTexture(json.envMap);\n\nif(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;\n\nif(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);\nif(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;\n\nif(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);\nif(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;\n\nif(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);\n\n// MultiMaterial\n\nif(json.materials!==undefined){\n\nfor(var i=0,l=json.materials.length;i<l;i++){\n\nmaterial.materials.push(this.parse(json.materials[i]));\n\n}\n\n}\n\nreturn material;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction BufferGeometryLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n}\n\nObject.assign(BufferGeometryLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nvar scope=this;\n\nvar loader=new FileLoader(scope.manager);\nloader.load(url,function(text){\n\nonLoad(scope.parse(JSON.parse(text)));\n\n},onProgress,onError);\n\n},\n\nparse:function parse(json){\n\nvar geometry=new BufferGeometry();\n\nvar index=json.data.index;\n\nvar TYPED_ARRAYS={\n'Int8Array':Int8Array,\n'Uint8Array':Uint8Array,\n'Uint8ClampedArray':Uint8ClampedArray,\n'Int16Array':Int16Array,\n'Uint16Array':Uint16Array,\n'Int32Array':Int32Array,\n'Uint32Array':Uint32Array,\n'Float32Array':Float32Array,\n'Float64Array':Float64Array};\n\n\nif(index!==undefined){\n\nvar typedArray=new TYPED_ARRAYS[index.type](index.array);\ngeometry.setIndex(new BufferAttribute(typedArray,1));\n\n}\n\nvar attributes=json.data.attributes;\n\nfor(var key in attributes){\n\nvar attribute=attributes[key];\nvar typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);\n\ngeometry.addAttribute(key,new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized));\n\n}\n\nvar groups=json.data.groups||json.data.drawcalls||json.data.offsets;\n\nif(groups!==undefined){\n\nfor(var i=0,n=groups.length;i!==n;++i){\n\nvar group=groups[i];\n\ngeometry.addGroup(group.start,group.count,group.materialIndex);\n\n}\n\n}\n\nvar boundingSphere=json.data.boundingSphere;\n\nif(boundingSphere!==undefined){\n\nvar center=new Vector3();\n\nif(boundingSphere.center!==undefined){\n\ncenter.fromArray(boundingSphere.center);\n\n}\n\ngeometry.boundingSphere=new Sphere(center,boundingSphere.radius);\n\n}\n\nreturn geometry;\n\n}});\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction Loader(){\n\nthis.onLoadStart=function(){};\nthis.onLoadProgress=function(){};\nthis.onLoadComplete=function(){};\n\n}\n\nLoader.prototype={\n\nconstructor:Loader,\n\ncrossOrigin:undefined,\n\nextractUrlBase:function extractUrlBase(url){\n\nvar parts=url.split('/');\n\nif(parts.length===1)return'./';\n\nparts.pop();\n\nreturn parts.join('/')+'/';\n\n},\n\ninitMaterials:function initMaterials(materials,texturePath,crossOrigin){\n\nvar array=[];\n\nfor(var i=0;i<materials.length;++i){\n\narray[i]=this.createMaterial(materials[i],texturePath,crossOrigin);\n\n}\n\nreturn array;\n\n},\n\ncreateMaterial:function(){\n\nvar BlendingMode={\nNoBlending:NoBlending,\nNormalBlending:NormalBlending,\nAdditiveBlending:AdditiveBlending,\nSubtractiveBlending:SubtractiveBlending,\nMultiplyBlending:MultiplyBlending,\nCustomBlending:CustomBlending};\n\n\nvar color,textureLoader,materialLoader;\n\nreturn function createMaterial(m,texturePath,crossOrigin){\n\nif(color===undefined)color=new Color();\nif(textureLoader===undefined)textureLoader=new TextureLoader();\nif(materialLoader===undefined)materialLoader=new MaterialLoader();\n\n// convert from old material format\n\nvar textures={};\n\nfunction loadTexture(path,repeat,offset,wrap,anisotropy){\n\nvar fullPath=texturePath+path;\nvar loader=Loader.Handlers.get(fullPath);\n\nvar texture;\n\nif(loader!==null){\n\ntexture=loader.load(fullPath);\n\n}else{\n\ntextureLoader.setCrossOrigin(crossOrigin);\ntexture=textureLoader.load(fullPath);\n\n}\n\nif(repeat!==undefined){\n\ntexture.repeat.fromArray(repeat);\n\nif(repeat[0]!==1)texture.wrapS=RepeatWrapping;\nif(repeat[1]!==1)texture.wrapT=RepeatWrapping;\n\n}\n\nif(offset!==undefined){\n\ntexture.offset.fromArray(offset);\n\n}\n\nif(wrap!==undefined){\n\nif(wrap[0]==='repeat')texture.wrapS=RepeatWrapping;\nif(wrap[0]==='mirror')texture.wrapS=MirroredRepeatWrapping;\n\nif(wrap[1]==='repeat')texture.wrapT=RepeatWrapping;\nif(wrap[1]==='mirror')texture.wrapT=MirroredRepeatWrapping;\n\n}\n\nif(anisotropy!==undefined){\n\ntexture.anisotropy=anisotropy;\n\n}\n\nvar uuid=_Math.generateUUID();\n\ntextures[uuid]=texture;\n\nreturn uuid;\n\n}\n\n//\n\nvar json={\nuuid:_Math.generateUUID(),\ntype:'MeshLambertMaterial'};\n\n\nfor(var name in m){\n\nvar value=m[name];\n\nswitch(name){\n\ncase'DbgColor':\ncase'DbgIndex':\ncase'opticalDensity':\ncase'illumination':\nbreak;\ncase'DbgName':\njson.name=value;\nbreak;\ncase'blending':\njson.blending=BlendingMode[value];\nbreak;\ncase'colorAmbient':\ncase'mapAmbient':\nconsole.warn('THREE.Loader.createMaterial:',name,'is no longer supported.');\nbreak;\ncase'colorDiffuse':\njson.color=color.fromArray(value).getHex();\nbreak;\ncase'colorSpecular':\njson.specular=color.fromArray(value).getHex();\nbreak;\ncase'colorEmissive':\njson.emissive=color.fromArray(value).getHex();\nbreak;\ncase'specularCoef':\njson.shininess=value;\nbreak;\ncase'shading':\nif(value.toLowerCase()==='basic')json.type='MeshBasicMaterial';\nif(value.toLowerCase()==='phong')json.type='MeshPhongMaterial';\nif(value.toLowerCase()==='standard')json.type='MeshStandardMaterial';\nbreak;\ncase'mapDiffuse':\njson.map=loadTexture(value,m.mapDiffuseRepeat,m.mapDiffuseOffset,m.mapDiffuseWrap,m.mapDiffuseAnisotropy);\nbreak;\ncase'mapDiffuseRepeat':\ncase'mapDiffuseOffset':\ncase'mapDiffuseWrap':\ncase'mapDiffuseAnisotropy':\nbreak;\ncase'mapEmissive':\njson.emissiveMap=loadTexture(value,m.mapEmissiveRepeat,m.mapEmissiveOffset,m.mapEmissiveWrap,m.mapEmissiveAnisotropy);\nbreak;\ncase'mapEmissiveRepeat':\ncase'mapEmissiveOffset':\ncase'mapEmissiveWrap':\ncase'mapEmissiveAnisotropy':\nbreak;\ncase'mapLight':\njson.lightMap=loadTexture(value,m.mapLightRepeat,m.mapLightOffset,m.mapLightWrap,m.mapLightAnisotropy);\nbreak;\ncase'mapLightRepeat':\ncase'mapLightOffset':\ncase'mapLightWrap':\ncase'mapLightAnisotropy':\nbreak;\ncase'mapAO':\njson.aoMap=loadTexture(value,m.mapAORepeat,m.mapAOOffset,m.mapAOWrap,m.mapAOAnisotropy);\nbreak;\ncase'mapAORepeat':\ncase'mapAOOffset':\ncase'mapAOWrap':\ncase'mapAOAnisotropy':\nbreak;\ncase'mapBump':\njson.bumpMap=loadTexture(value,m.mapBumpRepeat,m.mapBumpOffset,m.mapBumpWrap,m.mapBumpAnisotropy);\nbreak;\ncase'mapBumpScale':\njson.bumpScale=value;\nbreak;\ncase'mapBumpRepeat':\ncase'mapBumpOffset':\ncase'mapBumpWrap':\ncase'mapBumpAnisotropy':\nbreak;\ncase'mapNormal':\njson.normalMap=loadTexture(value,m.mapNormalRepeat,m.mapNormalOffset,m.mapNormalWrap,m.mapNormalAnisotropy);\nbreak;\ncase'mapNormalFactor':\njson.normalScale=[value,value];\nbreak;\ncase'mapNormalRepeat':\ncase'mapNormalOffset':\ncase'mapNormalWrap':\ncase'mapNormalAnisotropy':\nbreak;\ncase'mapSpecular':\njson.specularMap=loadTexture(value,m.mapSpecularRepeat,m.mapSpecularOffset,m.mapSpecularWrap,m.mapSpecularAnisotropy);\nbreak;\ncase'mapSpecularRepeat':\ncase'mapSpecularOffset':\ncase'mapSpecularWrap':\ncase'mapSpecularAnisotropy':\nbreak;\ncase'mapMetalness':\njson.metalnessMap=loadTexture(value,m.mapMetalnessRepeat,m.mapMetalnessOffset,m.mapMetalnessWrap,m.mapMetalnessAnisotropy);\nbreak;\ncase'mapMetalnessRepeat':\ncase'mapMetalnessOffset':\ncase'mapMetalnessWrap':\ncase'mapMetalnessAnisotropy':\nbreak;\ncase'mapRoughness':\njson.roughnessMap=loadTexture(value,m.mapRoughnessRepeat,m.mapRoughnessOffset,m.mapRoughnessWrap,m.mapRoughnessAnisotropy);\nbreak;\ncase'mapRoughnessRepeat':\ncase'mapRoughnessOffset':\ncase'mapRoughnessWrap':\ncase'mapRoughnessAnisotropy':\nbreak;\ncase'mapAlpha':\njson.alphaMap=loadTexture(value,m.mapAlphaRepeat,m.mapAlphaOffset,m.mapAlphaWrap,m.mapAlphaAnisotropy);\nbreak;\ncase'mapAlphaRepeat':\ncase'mapAlphaOffset':\ncase'mapAlphaWrap':\ncase'mapAlphaAnisotropy':\nbreak;\ncase'flipSided':\njson.side=BackSide;\nbreak;\ncase'doubleSided':\njson.side=DoubleSide;\nbreak;\ncase'transparency':\nconsole.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');\njson.opacity=value;\nbreak;\ncase'depthTest':\ncase'depthWrite':\ncase'colorWrite':\ncase'opacity':\ncase'reflectivity':\ncase'transparent':\ncase'visible':\ncase'wireframe':\njson[name]=value;\nbreak;\ncase'vertexColors':\nif(value===true)json.vertexColors=VertexColors;\nif(value==='face')json.vertexColors=FaceColors;\nbreak;\ndefault:\nconsole.error('THREE.Loader.createMaterial: Unsupported',name,value);\nbreak;}\n\n\n\n}\n\nif(json.type==='MeshBasicMaterial')delete json.emissive;\nif(json.type!=='MeshPhongMaterial')delete json.specular;\n\nif(json.opacity<1)json.transparent=true;\n\nmaterialLoader.setTextures(textures);\n\nreturn materialLoader.parse(json);\n\n};\n\n}()};\n\n\n\nLoader.Handlers={\n\nhandlers:[],\n\nadd:function add(regex,loader){\n\nthis.handlers.push(regex,loader);\n\n},\n\nget:function get(file){\n\nvar handlers=this.handlers;\n\nfor(var i=0,l=handlers.length;i<l;i+=2){\n\nvar regex=handlers[i];\nvar loader=handlers[i+1];\n\nif(regex.test(file)){\n\nreturn loader;\n\n}\n\n}\n\nreturn null;\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction JSONLoader(manager){\n\nif(typeof manager==='boolean'){\n\nconsole.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');\nmanager=undefined;\n\n}\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\nthis.withCredentials=false;\n\n}\n\nObject.assign(JSONLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nvar scope=this;\n\nvar texturePath=this.texturePath&&typeof this.texturePath===\"string\"?this.texturePath:Loader.prototype.extractUrlBase(url);\n\nvar loader=new FileLoader(this.manager);\nloader.setWithCredentials(this.withCredentials);\nloader.load(url,function(text){\n\nvar json=JSON.parse(text);\nvar metadata=json.metadata;\n\nif(metadata!==undefined){\n\nvar type=metadata.type;\n\nif(type!==undefined){\n\nif(type.toLowerCase()==='object'){\n\nconsole.error('THREE.JSONLoader: '+url+' should be loaded with THREE.ObjectLoader instead.');\nreturn;\n\n}\n\nif(type.toLowerCase()==='scene'){\n\nconsole.error('THREE.JSONLoader: '+url+' should be loaded with THREE.SceneLoader instead.');\nreturn;\n\n}\n\n}\n\n}\n\nvar object=scope.parse(json,texturePath);\nonLoad(object.geometry,object.materials);\n\n},onProgress,onError);\n\n},\n\nsetTexturePath:function setTexturePath(value){\n\nthis.texturePath=value;\n\n},\n\nparse:function parse(json,texturePath){\n\nvar geometry=new Geometry(),\nscale=json.scale!==undefined?1.0/json.scale:1.0;\n\nparseModel(scale);\n\nparseSkin();\nparseMorphing(scale);\nparseAnimations();\n\ngeometry.computeFaceNormals();\ngeometry.computeBoundingSphere();\n\nfunction parseModel(scale){\n\nfunction isBitSet(value,position){\n\nreturn value&1<<position;\n\n}\n\nvar i,j,fi,\n\noffset,zLength,\n\ncolorIndex,normalIndex,uvIndex,materialIndex,\n\ntype,\nisQuad,\nhasMaterial,\nhasFaceVertexUv,\nhasFaceNormal,hasFaceVertexNormal,\nhasFaceColor,hasFaceVertexColor,\n\nvertex,face,faceA,faceB,hex,normal,\n\nuvLayer,uv,u,v,\n\nfaces=json.faces,\nvertices=json.vertices,\nnormals=json.normals,\ncolors=json.colors,\n\nnUvLayers=0;\n\nif(json.uvs!==undefined){\n\n// disregard empty arrays\n\nfor(i=0;i<json.uvs.length;i++){\n\nif(json.uvs[i].length)nUvLayers++;\n\n}\n\nfor(i=0;i<nUvLayers;i++){\n\ngeometry.faceVertexUvs[i]=[];\n\n}\n\n}\n\noffset=0;\nzLength=vertices.length;\n\nwhile(offset<zLength){\n\nvertex=new Vector3();\n\nvertex.x=vertices[offset++]*scale;\nvertex.y=vertices[offset++]*scale;\nvertex.z=vertices[offset++]*scale;\n\ngeometry.vertices.push(vertex);\n\n}\n\noffset=0;\nzLength=faces.length;\n\nwhile(offset<zLength){\n\ntype=faces[offset++];\n\n\nisQuad=isBitSet(type,0);\nhasMaterial=isBitSet(type,1);\nhasFaceVertexUv=isBitSet(type,3);\nhasFaceNormal=isBitSet(type,4);\nhasFaceVertexNormal=isBitSet(type,5);\nhasFaceColor=isBitSet(type,6);\nhasFaceVertexColor=isBitSet(type,7);\n\n// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\nif(isQuad){\n\nfaceA=new Face3();\nfaceA.a=faces[offset];\nfaceA.b=faces[offset+1];\nfaceA.c=faces[offset+3];\n\nfaceB=new Face3();\nfaceB.a=faces[offset+1];\nfaceB.b=faces[offset+2];\nfaceB.c=faces[offset+3];\n\noffset+=4;\n\nif(hasMaterial){\n\nmaterialIndex=faces[offset++];\nfaceA.materialIndex=materialIndex;\nfaceB.materialIndex=materialIndex;\n\n}\n\n// to get face <=> uv index correspondence\n\nfi=geometry.faces.length;\n\nif(hasFaceVertexUv){\n\nfor(i=0;i<nUvLayers;i++){\n\nuvLayer=json.uvs[i];\n\ngeometry.faceVertexUvs[i][fi]=[];\ngeometry.faceVertexUvs[i][fi+1]=[];\n\nfor(j=0;j<4;j++){\n\nuvIndex=faces[offset++];\n\nu=uvLayer[uvIndex*2];\nv=uvLayer[uvIndex*2+1];\n\nuv=new Vector2(u,v);\n\nif(j!==2)geometry.faceVertexUvs[i][fi].push(uv);\nif(j!==0)geometry.faceVertexUvs[i][fi+1].push(uv);\n\n}\n\n}\n\n}\n\nif(hasFaceNormal){\n\nnormalIndex=faces[offset++]*3;\n\nfaceA.normal.set(\nnormals[normalIndex++],\nnormals[normalIndex++],\nnormals[normalIndex]);\n\n\nfaceB.normal.copy(faceA.normal);\n\n}\n\nif(hasFaceVertexNormal){\n\nfor(i=0;i<4;i++){\n\nnormalIndex=faces[offset++]*3;\n\nnormal=new Vector3(\nnormals[normalIndex++],\nnormals[normalIndex++],\nnormals[normalIndex]);\n\n\n\nif(i!==2)faceA.vertexNormals.push(normal);\nif(i!==0)faceB.vertexNormals.push(normal);\n\n}\n\n}\n\n\nif(hasFaceColor){\n\ncolorIndex=faces[offset++];\nhex=colors[colorIndex];\n\nfaceA.color.setHex(hex);\nfaceB.color.setHex(hex);\n\n}\n\n\nif(hasFaceVertexColor){\n\nfor(i=0;i<4;i++){\n\ncolorIndex=faces[offset++];\nhex=colors[colorIndex];\n\nif(i!==2)faceA.vertexColors.push(new Color(hex));\nif(i!==0)faceB.vertexColors.push(new Color(hex));\n\n}\n\n}\n\ngeometry.faces.push(faceA);\ngeometry.faces.push(faceB);\n\n}else{\n\nface=new Face3();\nface.a=faces[offset++];\nface.b=faces[offset++];\nface.c=faces[offset++];\n\nif(hasMaterial){\n\nmaterialIndex=faces[offset++];\nface.materialIndex=materialIndex;\n\n}\n\n// to get face <=> uv index correspondence\n\nfi=geometry.faces.length;\n\nif(hasFaceVertexUv){\n\nfor(i=0;i<nUvLayers;i++){\n\nuvLayer=json.uvs[i];\n\ngeometry.faceVertexUvs[i][fi]=[];\n\nfor(j=0;j<3;j++){\n\nuvIndex=faces[offset++];\n\nu=uvLayer[uvIndex*2];\nv=uvLayer[uvIndex*2+1];\n\nuv=new Vector2(u,v);\n\ngeometry.faceVertexUvs[i][fi].push(uv);\n\n}\n\n}\n\n}\n\nif(hasFaceNormal){\n\nnormalIndex=faces[offset++]*3;\n\nface.normal.set(\nnormals[normalIndex++],\nnormals[normalIndex++],\nnormals[normalIndex]);\n\n\n}\n\nif(hasFaceVertexNormal){\n\nfor(i=0;i<3;i++){\n\nnormalIndex=faces[offset++]*3;\n\nnormal=new Vector3(\nnormals[normalIndex++],\nnormals[normalIndex++],\nnormals[normalIndex]);\n\n\nface.vertexNormals.push(normal);\n\n}\n\n}\n\n\nif(hasFaceColor){\n\ncolorIndex=faces[offset++];\nface.color.setHex(colors[colorIndex]);\n\n}\n\n\nif(hasFaceVertexColor){\n\nfor(i=0;i<3;i++){\n\ncolorIndex=faces[offset++];\nface.vertexColors.push(new Color(colors[colorIndex]));\n\n}\n\n}\n\ngeometry.faces.push(face);\n\n}\n\n}\n\n}\n\nfunction parseSkin(){\n\nvar influencesPerVertex=json.influencesPerVertex!==undefined?json.influencesPerVertex:2;\n\nif(json.skinWeights){\n\nfor(var i=0,l=json.skinWeights.length;i<l;i+=influencesPerVertex){\n\nvar x=json.skinWeights[i];\nvar y=influencesPerVertex>1?json.skinWeights[i+1]:0;\nvar z=influencesPerVertex>2?json.skinWeights[i+2]:0;\nvar w=influencesPerVertex>3?json.skinWeights[i+3]:0;\n\ngeometry.skinWeights.push(new Vector4(x,y,z,w));\n\n}\n\n}\n\nif(json.skinIndices){\n\nfor(var i=0,l=json.skinIndices.length;i<l;i+=influencesPerVertex){\n\nvar a=json.skinIndices[i];\nvar b=influencesPerVertex>1?json.skinIndices[i+1]:0;\nvar c=influencesPerVertex>2?json.skinIndices[i+2]:0;\nvar d=influencesPerVertex>3?json.skinIndices[i+3]:0;\n\ngeometry.skinIndices.push(new Vector4(a,b,c,d));\n\n}\n\n}\n\ngeometry.bones=json.bones;\n\nif(geometry.bones&&geometry.bones.length>0&&(geometry.skinWeights.length!==geometry.skinIndices.length||geometry.skinIndices.length!==geometry.vertices.length)){\n\nconsole.warn('When skinning, number of vertices ('+geometry.vertices.length+'), skinIndices ('+\ngeometry.skinIndices.length+'), and skinWeights ('+geometry.skinWeights.length+') should match.');\n\n}\n\n}\n\nfunction parseMorphing(scale){\n\nif(json.morphTargets!==undefined){\n\nfor(var i=0,l=json.morphTargets.length;i<l;i++){\n\ngeometry.morphTargets[i]={};\ngeometry.morphTargets[i].name=json.morphTargets[i].name;\ngeometry.morphTargets[i].vertices=[];\n\nvar dstVertices=geometry.morphTargets[i].vertices;\nvar srcVertices=json.morphTargets[i].vertices;\n\nfor(var v=0,vl=srcVertices.length;v<vl;v+=3){\n\nvar vertex=new Vector3();\nvertex.x=srcVertices[v]*scale;\nvertex.y=srcVertices[v+1]*scale;\nvertex.z=srcVertices[v+2]*scale;\n\ndstVertices.push(vertex);\n\n}\n\n}\n\n}\n\nif(json.morphColors!==undefined&&json.morphColors.length>0){\n\nconsole.warn('THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.');\n\nvar faces=geometry.faces;\nvar morphColors=json.morphColors[0].colors;\n\nfor(var i=0,l=faces.length;i<l;i++){\n\nfaces[i].color.fromArray(morphColors,i*3);\n\n}\n\n}\n\n}\n\nfunction parseAnimations(){\n\nvar outputAnimations=[];\n\n// parse old style Bone/Hierarchy animations\nvar animations=[];\n\nif(json.animation!==undefined){\n\nanimations.push(json.animation);\n\n}\n\nif(json.animations!==undefined){\n\nif(json.animations.length){\n\nanimations=animations.concat(json.animations);\n\n}else{\n\nanimations.push(json.animations);\n\n}\n\n}\n\nfor(var i=0;i<animations.length;i++){\n\nvar clip=AnimationClip.parseAnimation(animations[i],geometry.bones);\nif(clip)outputAnimations.push(clip);\n\n}\n\n// parse implicit morph animations\nif(geometry.morphTargets){\n\n// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\nvar morphAnimationClips=AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets,10);\noutputAnimations=outputAnimations.concat(morphAnimationClips);\n\n}\n\nif(outputAnimations.length>0)geometry.animations=outputAnimations;\n\n}\n\nif(json.materials===undefined||json.materials.length===0){\n\nreturn{geometry:geometry};\n\n}else{\n\nvar materials=Loader.prototype.initMaterials(json.materials,texturePath,this.crossOrigin);\n\nreturn{geometry:geometry,materials:materials};\n\n}\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction ObjectLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\nthis.texturePath='';\n\n}\n\nObject.assign(ObjectLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nif(this.texturePath===''){\n\nthis.texturePath=url.substring(0,url.lastIndexOf('/')+1);\n\n}\n\nvar scope=this;\n\nvar loader=new FileLoader(scope.manager);\nloader.load(url,function(text){\n\nvar json=null;\n\ntry{\n\njson=JSON.parse(text);\n\n}catch(error){\n\nif(onError!==undefined)onError(error);\n\nconsole.error('THREE:ObjectLoader: Can\\'t parse '+url+'.',error.message);\n\nreturn;\n\n}\n\nvar metadata=json.metadata;\n\nif(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){\n\nconsole.error('THREE.ObjectLoader: Can\\'t load '+url+'. Use THREE.JSONLoader instead.');\nreturn;\n\n}\n\nscope.parse(json,onLoad);\n\n},onProgress,onError);\n\n},\n\nsetTexturePath:function setTexturePath(value){\n\nthis.texturePath=value;\n\n},\n\nsetCrossOrigin:function setCrossOrigin(value){\n\nthis.crossOrigin=value;\n\n},\n\nparse:function parse(json,onLoad){\n\nvar geometries=this.parseGeometries(json.geometries);\n\nvar images=this.parseImages(json.images,function(){\n\nif(onLoad!==undefined)onLoad(object);\n\n});\n\nvar textures=this.parseTextures(json.textures,images);\nvar materials=this.parseMaterials(json.materials,textures);\n\nvar object=this.parseObject(json.object,geometries,materials);\n\nif(json.animations){\n\nobject.animations=this.parseAnimations(json.animations);\n\n}\n\nif(json.images===undefined||json.images.length===0){\n\nif(onLoad!==undefined)onLoad(object);\n\n}\n\nreturn object;\n\n},\n\nparseGeometries:function parseGeometries(json){\n\nvar geometries={};\n\nif(json!==undefined){\n\nvar geometryLoader=new JSONLoader();\nvar bufferGeometryLoader=new BufferGeometryLoader();\n\nfor(var i=0,l=json.length;i<l;i++){\n\nvar geometry;\nvar data=json[i];\n\nswitch(data.type){\n\ncase'PlaneGeometry':\ncase'PlaneBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.width,\ndata.height,\ndata.widthSegments,\ndata.heightSegments);\n\n\nbreak;\n\ncase'BoxGeometry':\ncase'BoxBufferGeometry':\ncase'CubeGeometry':// backwards compatible\n\ngeometry=new Geometries[data.type](\ndata.width,\ndata.height,\ndata.depth,\ndata.widthSegments,\ndata.heightSegments,\ndata.depthSegments);\n\n\nbreak;\n\ncase'CircleGeometry':\ncase'CircleBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.radius,\ndata.segments,\ndata.thetaStart,\ndata.thetaLength);\n\n\nbreak;\n\ncase'CylinderGeometry':\ncase'CylinderBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.radiusTop,\ndata.radiusBottom,\ndata.height,\ndata.radialSegments,\ndata.heightSegments,\ndata.openEnded,\ndata.thetaStart,\ndata.thetaLength);\n\n\nbreak;\n\ncase'ConeGeometry':\ncase'ConeBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.radius,\ndata.height,\ndata.radialSegments,\ndata.heightSegments,\ndata.openEnded,\ndata.thetaStart,\ndata.thetaLength);\n\n\nbreak;\n\ncase'SphereGeometry':\ncase'SphereBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.radius,\ndata.widthSegments,\ndata.heightSegments,\ndata.phiStart,\ndata.phiLength,\ndata.thetaStart,\ndata.thetaLength);\n\n\nbreak;\n\ncase'DodecahedronGeometry':\ncase'IcosahedronGeometry':\ncase'OctahedronGeometry':\ncase'TetrahedronGeometry':\n\ngeometry=new Geometries[data.type](\ndata.radius,\ndata.detail);\n\n\nbreak;\n\ncase'RingGeometry':\ncase'RingBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.innerRadius,\ndata.outerRadius,\ndata.thetaSegments,\ndata.phiSegments,\ndata.thetaStart,\ndata.thetaLength);\n\n\nbreak;\n\ncase'TorusGeometry':\ncase'TorusBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.radius,\ndata.tube,\ndata.radialSegments,\ndata.tubularSegments,\ndata.arc);\n\n\nbreak;\n\ncase'TorusKnotGeometry':\ncase'TorusKnotBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.radius,\ndata.tube,\ndata.tubularSegments,\ndata.radialSegments,\ndata.p,\ndata.q);\n\n\nbreak;\n\ncase'LatheGeometry':\ncase'LatheBufferGeometry':\n\ngeometry=new Geometries[data.type](\ndata.points,\ndata.segments,\ndata.phiStart,\ndata.phiLength);\n\n\nbreak;\n\ncase'BufferGeometry':\n\ngeometry=bufferGeometryLoader.parse(data);\n\nbreak;\n\ncase'Geometry':\n\ngeometry=geometryLoader.parse(data.data,this.texturePath).geometry;\n\nbreak;\n\ndefault:\n\nconsole.warn('THREE.ObjectLoader: Unsupported geometry type \"'+data.type+'\"');\n\ncontinue;}\n\n\n\ngeometry.uuid=data.uuid;\n\nif(data.name!==undefined)geometry.name=data.name;\n\ngeometries[data.uuid]=geometry;\n\n}\n\n}\n\nreturn geometries;\n\n},\n\nparseMaterials:function parseMaterials(json,textures){\n\nvar materials={};\n\nif(json!==undefined){\n\nvar loader=new MaterialLoader();\nloader.setTextures(textures);\n\nfor(var i=0,l=json.length;i<l;i++){\n\nvar material=loader.parse(json[i]);\nmaterials[material.uuid]=material;\n\n}\n\n}\n\nreturn materials;\n\n},\n\nparseAnimations:function parseAnimations(json){\n\nvar animations=[];\n\nfor(var i=0;i<json.length;i++){\n\nvar clip=AnimationClip.parse(json[i]);\n\nanimations.push(clip);\n\n}\n\nreturn animations;\n\n},\n\nparseImages:function parseImages(json,onLoad){\n\nvar scope=this;\nvar images={};\n\nfunction loadImage(url){\n\nscope.manager.itemStart(url);\n\nreturn loader.load(url,function(){\n\nscope.manager.itemEnd(url);\n\n},undefined,function(){\n\nscope.manager.itemError(url);\n\n});\n\n}\n\nif(json!==undefined&&json.length>0){\n\nvar manager=new LoadingManager(onLoad);\n\nvar loader=new ImageLoader(manager);\nloader.setCrossOrigin(this.crossOrigin);\n\nfor(var i=0,l=json.length;i<l;i++){\n\nvar image=json[i];\nvar path=/^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(image.url)?image.url:scope.texturePath+image.url;\n\nimages[image.uuid]=loadImage(path);\n\n}\n\n}\n\nreturn images;\n\n},\n\nparseTextures:function parseTextures(json,images){\n\nvar TextureMapping={\nUVMapping:UVMapping,\nCubeReflectionMapping:CubeReflectionMapping,\nCubeRefractionMapping:CubeRefractionMapping,\nEquirectangularReflectionMapping:EquirectangularReflectionMapping,\nEquirectangularRefractionMapping:EquirectangularRefractionMapping,\nSphericalReflectionMapping:SphericalReflectionMapping,\nCubeUVReflectionMapping:CubeUVReflectionMapping,\nCubeUVRefractionMapping:CubeUVRefractionMapping};\n\n\nvar TextureWrapping={\nRepeatWrapping:RepeatWrapping,\nClampToEdgeWrapping:ClampToEdgeWrapping,\nMirroredRepeatWrapping:MirroredRepeatWrapping};\n\n\nvar TextureFilter={\nNearestFilter:NearestFilter,\nNearestMipMapNearestFilter:NearestMipMapNearestFilter,\nNearestMipMapLinearFilter:NearestMipMapLinearFilter,\nLinearFilter:LinearFilter,\nLinearMipMapNearestFilter:LinearMipMapNearestFilter,\nLinearMipMapLinearFilter:LinearMipMapLinearFilter};\n\n\nfunction parseConstant(value,type){\n\nif(typeof value==='number')return value;\n\nconsole.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',value);\n\nreturn type[value];\n\n}\n\nvar textures={};\n\nif(json!==undefined){\n\nfor(var i=0,l=json.length;i<l;i++){\n\nvar data=json[i];\n\nif(data.image===undefined){\n\nconsole.warn('THREE.ObjectLoader: No \"image\" specified for',data.uuid);\n\n}\n\nif(images[data.image]===undefined){\n\nconsole.warn('THREE.ObjectLoader: Undefined image',data.image);\n\n}\n\nvar texture=new Texture(images[data.image]);\ntexture.needsUpdate=true;\n\ntexture.uuid=data.uuid;\n\nif(data.name!==undefined)texture.name=data.name;\n\nif(data.mapping!==undefined)texture.mapping=parseConstant(data.mapping,TextureMapping);\n\nif(data.offset!==undefined)texture.offset.fromArray(data.offset);\nif(data.repeat!==undefined)texture.repeat.fromArray(data.repeat);\nif(data.wrap!==undefined){\n\ntexture.wrapS=parseConstant(data.wrap[0],TextureWrapping);\ntexture.wrapT=parseConstant(data.wrap[1],TextureWrapping);\n\n}\n\nif(data.minFilter!==undefined)texture.minFilter=parseConstant(data.minFilter,TextureFilter);\nif(data.magFilter!==undefined)texture.magFilter=parseConstant(data.magFilter,TextureFilter);\nif(data.anisotropy!==undefined)texture.anisotropy=data.anisotropy;\n\nif(data.flipY!==undefined)texture.flipY=data.flipY;\n\ntextures[data.uuid]=texture;\n\n}\n\n}\n\nreturn textures;\n\n},\n\nparseObject:function(){\n\nvar matrix=new Matrix4();\n\nreturn function parseObject(data,geometries,materials){\n\nvar object;\n\nfunction getGeometry(name){\n\nif(geometries[name]===undefined){\n\nconsole.warn('THREE.ObjectLoader: Undefined geometry',name);\n\n}\n\nreturn geometries[name];\n\n}\n\nfunction getMaterial(name){\n\nif(name===undefined)return undefined;\n\nif(materials[name]===undefined){\n\nconsole.warn('THREE.ObjectLoader: Undefined material',name);\n\n}\n\nreturn materials[name];\n\n}\n\nswitch(data.type){\n\ncase'Scene':\n\nobject=new Scene();\n\nif(data.background!==undefined){\n\nif(Number.isInteger(data.background)){\n\nobject.background=new Color(data.background);\n\n}\n\n}\n\nif(data.fog!==undefined){\n\nif(data.fog.type==='Fog'){\n\nobject.fog=new Fog(data.fog.color,data.fog.near,data.fog.far);\n\n}else if(data.fog.type==='FogExp2'){\n\nobject.fog=new FogExp2(data.fog.color,data.fog.density);\n\n}\n\n}\n\nbreak;\n\ncase'PerspectiveCamera':\n\nobject=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);\n\nif(data.focus!==undefined)object.focus=data.focus;\nif(data.zoom!==undefined)object.zoom=data.zoom;\nif(data.filmGauge!==undefined)object.filmGauge=data.filmGauge;\nif(data.filmOffset!==undefined)object.filmOffset=data.filmOffset;\nif(data.view!==undefined)object.view=Object.assign({},data.view);\n\nbreak;\n\ncase'OrthographicCamera':\n\nobject=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);\n\nbreak;\n\ncase'AmbientLight':\n\nobject=new AmbientLight(data.color,data.intensity);\n\nbreak;\n\ncase'DirectionalLight':\n\nobject=new DirectionalLight(data.color,data.intensity);\n\nbreak;\n\ncase'PointLight':\n\nobject=new PointLight(data.color,data.intensity,data.distance,data.decay);\n\nbreak;\n\ncase'SpotLight':\n\nobject=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);\n\nbreak;\n\ncase'HemisphereLight':\n\nobject=new HemisphereLight(data.color,data.groundColor,data.intensity);\n\nbreak;\n\ncase'Mesh':\n\nvar geometry=getGeometry(data.geometry);\nvar material=getMaterial(data.material);\n\nif(geometry.bones&&geometry.bones.length>0){\n\nobject=new SkinnedMesh(geometry,material);\n\n}else{\n\nobject=new Mesh(geometry,material);\n\n}\n\nbreak;\n\ncase'LOD':\n\nobject=new LOD();\n\nbreak;\n\ncase'Line':\n\nobject=new Line(getGeometry(data.geometry),getMaterial(data.material),data.mode);\n\nbreak;\n\ncase'LineSegments':\n\nobject=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));\n\nbreak;\n\ncase'PointCloud':\ncase'Points':\n\nobject=new Points(getGeometry(data.geometry),getMaterial(data.material));\n\nbreak;\n\ncase'Sprite':\n\nobject=new Sprite(getMaterial(data.material));\n\nbreak;\n\ncase'Group':\n\nobject=new Group();\n\nbreak;\n\ncase'SkinnedMesh':\n\nconsole.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.');\n\ndefault:\n\nobject=new Object3D();}\n\n\n\nobject.uuid=data.uuid;\n\nif(data.name!==undefined)object.name=data.name;\nif(data.matrix!==undefined){\n\nmatrix.fromArray(data.matrix);\nmatrix.decompose(object.position,object.quaternion,object.scale);\n\n}else{\n\nif(data.position!==undefined)object.position.fromArray(data.position);\nif(data.rotation!==undefined)object.rotation.fromArray(data.rotation);\nif(data.quaternion!==undefined)object.quaternion.fromArray(data.quaternion);\nif(data.scale!==undefined)object.scale.fromArray(data.scale);\n\n}\n\nif(data.castShadow!==undefined)object.castShadow=data.castShadow;\nif(data.receiveShadow!==undefined)object.receiveShadow=data.receiveShadow;\n\nif(data.shadow){\n\nif(data.shadow.bias!==undefined)object.shadow.bias=data.shadow.bias;\nif(data.shadow.radius!==undefined)object.shadow.radius=data.shadow.radius;\nif(data.shadow.mapSize!==undefined)object.shadow.mapSize.fromArray(data.shadow.mapSize);\nif(data.shadow.camera!==undefined)object.shadow.camera=this.parseObject(data.shadow.camera);\n\n}\n\nif(data.visible!==undefined)object.visible=data.visible;\nif(data.userData!==undefined)object.userData=data.userData;\n\nif(data.children!==undefined){\n\nfor(var child in data.children){\n\nobject.add(this.parseObject(data.children[child],geometries,materials));\n\n}\n\n}\n\nif(data.type==='LOD'){\n\nvar levels=data.levels;\n\nfor(var l=0;l<levels.length;l++){\n\nvar level=levels[l];\nvar child=object.getObjectByProperty('uuid',level.object);\n\nif(child!==undefined){\n\nobject.addLevel(child,level.distance);\n\n}\n\n}\n\n}\n\nreturn object;\n\n};\n\n}()});\n\n\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t * Bezier Curves formulas obtained from\n\t * http://en.wikipedia.org/wiki/Bézier_curve\n\t */\n\nfunction CatmullRom(t,p0,p1,p2,p3){\n\nvar v0=(p2-p0)*0.5;\nvar v1=(p3-p1)*0.5;\nvar t2=t*t;\nvar t3=t*t2;\nreturn(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0(t,p){\n\nvar k=1-t;\nreturn k*k*p;\n\n}\n\nfunction QuadraticBezierP1(t,p){\n\nreturn 2*(1-t)*t*p;\n\n}\n\nfunction QuadraticBezierP2(t,p){\n\nreturn t*t*p;\n\n}\n\nfunction QuadraticBezier(t,p0,p1,p2){\n\nreturn QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+\nQuadraticBezierP2(t,p2);\n\n}\n\n//\n\nfunction CubicBezierP0(t,p){\n\nvar k=1-t;\nreturn k*k*k*p;\n\n}\n\nfunction CubicBezierP1(t,p){\n\nvar k=1-t;\nreturn 3*k*k*t*p;\n\n}\n\nfunction CubicBezierP2(t,p){\n\nreturn 3*(1-t)*t*t*p;\n\n}\n\nfunction CubicBezierP3(t,p){\n\nreturn t*t*t*p;\n\n}\n\nfunction CubicBezier(t,p0,p1,p2,p3){\n\nreturn CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+\nCubicBezierP3(t,p3);\n\n}\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Extensible curve object\n\t *\n\t * Some common of Curve methods\n\t * .getPoint(t), getTangent(t)\n\t * .getPointAt(u), getTangentAt(u)\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following classes subclasses THREE.Curve:\n\t *\n\t * -- 2d classes --\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.SplineCurve\n\t * THREE.ArcCurve\n\t * THREE.EllipseCurve\n\t *\n\t * -- 3d classes --\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.CatmullRomCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath\n\t *\n\t **/\n\n/**************************************************************\n\t *\tAbstract Curve base class\n\t **************************************************************/\n\nfunction Curve(){}\n\nCurve.prototype={\n\nconstructor:Curve,\n\n// Virtual base class method to overwrite and implement in subclasses\n//\t- t [0 .. 1]\n\ngetPoint:function getPoint(t){\n\nconsole.warn(\"THREE.Curve: Warning, getPoint() not implemented!\");\nreturn null;\n\n},\n\n// Get point at relative position in curve according to arc length\n// - u [0 .. 1]\n\ngetPointAt:function getPointAt(u){\n\nvar t=this.getUtoTmapping(u);\nreturn this.getPoint(t);\n\n},\n\n// Get sequence of points using getPoint( t )\n\ngetPoints:function getPoints(divisions){\n\nif(isNaN(divisions))divisions=5;\n\nvar points=[];\n\nfor(var d=0;d<=divisions;d++){\n\npoints.push(this.getPoint(d/divisions));\n\n}\n\nreturn points;\n\n},\n\n// Get sequence of points using getPointAt( u )\n\ngetSpacedPoints:function getSpacedPoints(divisions){\n\nif(isNaN(divisions))divisions=5;\n\nvar points=[];\n\nfor(var d=0;d<=divisions;d++){\n\npoints.push(this.getPointAt(d/divisions));\n\n}\n\nreturn points;\n\n},\n\n// Get total curve arc length\n\ngetLength:function getLength(){\n\nvar lengths=this.getLengths();\nreturn lengths[lengths.length-1];\n\n},\n\n// Get list of cumulative segment lengths\n\ngetLengths:function getLengths(divisions){\n\nif(isNaN(divisions))divisions=this.__arcLengthDivisions?this.__arcLengthDivisions:200;\n\nif(this.cacheArcLengths&&\nthis.cacheArcLengths.length===divisions+1&&\n!this.needsUpdate){\n\n//console.log( \"cached\", this.cacheArcLengths );\nreturn this.cacheArcLengths;\n\n}\n\nthis.needsUpdate=false;\n\nvar cache=[];\nvar current,last=this.getPoint(0);\nvar p,sum=0;\n\ncache.push(0);\n\nfor(p=1;p<=divisions;p++){\n\ncurrent=this.getPoint(p/divisions);\nsum+=current.distanceTo(last);\ncache.push(sum);\nlast=current;\n\n}\n\nthis.cacheArcLengths=cache;\n\nreturn cache;// { sums: cache, sum:sum }; Sum is in the last element.\n\n},\n\nupdateArcLengths:function updateArcLengths(){\n\nthis.needsUpdate=true;\nthis.getLengths();\n\n},\n\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\ngetUtoTmapping:function getUtoTmapping(u,distance){\n\nvar arcLengths=this.getLengths();\n\nvar i=0,il=arcLengths.length;\n\nvar targetArcLength;// The targeted u distance value to get\n\nif(distance){\n\ntargetArcLength=distance;\n\n}else{\n\ntargetArcLength=u*arcLengths[il-1];\n\n}\n\n//var time = Date.now();\n\n// binary search for the index with largest value smaller than target u distance\n\nvar low=0,high=il-1,comparison;\n\nwhile(low<=high){\n\ni=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\ncomparison=arcLengths[i]-targetArcLength;\n\nif(comparison<0){\n\nlow=i+1;\n\n}else if(comparison>0){\n\nhigh=i-1;\n\n}else{\n\nhigh=i;\nbreak;\n\n// DONE\n\n}\n\n}\n\ni=high;\n\n//console.log('b' , i, low, high, Date.now()- time);\n\nif(arcLengths[i]===targetArcLength){\n\nvar t=i/(il-1);\nreturn t;\n\n}\n\n// we could get finer grain at lengths, or use simple interpolation between two points\n\nvar lengthBefore=arcLengths[i];\nvar lengthAfter=arcLengths[i+1];\n\nvar segmentLength=lengthAfter-lengthBefore;\n\n// determine where we are between the 'before' and 'after' points\n\nvar segmentFraction=(targetArcLength-lengthBefore)/segmentLength;\n\n// add that fractional amount to t\n\nvar t=(i+segmentFraction)/(il-1);\n\nreturn t;\n\n},\n\n// Returns a unit vector tangent at t\n// In case any sub curve does not implement its tangent derivation,\n// 2 points a small delta apart will be used to find its gradient\n// which seems to give a reasonable approximation\n\ngetTangent:function getTangent(t){\n\nvar delta=0.0001;\nvar t1=t-delta;\nvar t2=t+delta;\n\n// Capping in case of danger\n\nif(t1<0)t1=0;\nif(t2>1)t2=1;\n\nvar pt1=this.getPoint(t1);\nvar pt2=this.getPoint(t2);\n\nvar vec=pt2.clone().sub(pt1);\nreturn vec.normalize();\n\n},\n\ngetTangentAt:function getTangentAt(u){\n\nvar t=this.getUtoTmapping(u);\nreturn this.getTangent(t);\n\n},\n\ncomputeFrenetFrames:function computeFrenetFrames(segments,closed){\n\n// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\nvar normal=new Vector3();\n\nvar tangents=[];\nvar normals=[];\nvar binormals=[];\n\nvar vec=new Vector3();\nvar mat=new Matrix4();\n\nvar i,u,theta;\n\n// compute the tangent vectors for each segment on the curve\n\nfor(i=0;i<=segments;i++){\n\nu=i/segments;\n\ntangents[i]=this.getTangentAt(u);\ntangents[i].normalize();\n\n}\n\n// select an initial normal vector perpendicular to the first tangent vector,\n// and in the direction of the minimum tangent xyz component\n\nnormals[0]=new Vector3();\nbinormals[0]=new Vector3();\nvar min=Number.MAX_VALUE;\nvar tx=Math.abs(tangents[0].x);\nvar ty=Math.abs(tangents[0].y);\nvar tz=Math.abs(tangents[0].z);\n\nif(tx<=min){\n\nmin=tx;\nnormal.set(1,0,0);\n\n}\n\nif(ty<=min){\n\nmin=ty;\nnormal.set(0,1,0);\n\n}\n\nif(tz<=min){\n\nnormal.set(0,0,1);\n\n}\n\nvec.crossVectors(tangents[0],normal).normalize();\n\nnormals[0].crossVectors(tangents[0],vec);\nbinormals[0].crossVectors(tangents[0],normals[0]);\n\n\n// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\nfor(i=1;i<=segments;i++){\n\nnormals[i]=normals[i-1].clone();\n\nbinormals[i]=binormals[i-1].clone();\n\nvec.crossVectors(tangents[i-1],tangents[i]);\n\nif(vec.length()>Number.EPSILON){\n\nvec.normalize();\n\ntheta=Math.acos(_Math.clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors\n\nnormals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));\n\n}\n\nbinormals[i].crossVectors(tangents[i],normals[i]);\n\n}\n\n// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\nif(closed===true){\n\ntheta=Math.acos(_Math.clamp(normals[0].dot(normals[segments]),-1,1));\ntheta/=segments;\n\nif(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){\n\ntheta=-theta;\n\n}\n\nfor(i=1;i<=segments;i++){\n\n// twist a little...\nnormals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));\nbinormals[i].crossVectors(tangents[i],normals[i]);\n\n}\n\n}\n\nreturn{\ntangents:tangents,\nnormals:normals,\nbinormals:binormals};\n\n\n}};\n\n\n\nfunction LineCurve(v1,v2){\n\nthis.v1=v1;\nthis.v2=v2;\n\n}\n\nLineCurve.prototype=Object.create(Curve.prototype);\nLineCurve.prototype.constructor=LineCurve;\n\nLineCurve.prototype.isLineCurve=true;\n\nLineCurve.prototype.getPoint=function(t){\n\nif(t===1){\n\nreturn this.v2.clone();\n\n}\n\nvar point=this.v2.clone().sub(this.v1);\npoint.multiplyScalar(t).add(this.v1);\n\nreturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nLineCurve.prototype.getPointAt=function(u){\n\nreturn this.getPoint(u);\n\n};\n\nLineCurve.prototype.getTangent=function(t){\n\nvar tangent=this.v2.clone().sub(this.v1);\n\nreturn tangent.normalize();\n\n};\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t *\n\t **/\n\n/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *  curves, but retains the api of a curve\n\t **************************************************************/\n\nfunction CurvePath(){\n\nthis.curves=[];\n\nthis.autoClose=false;// Automatically closes the path\n\n}\n\nCurvePath.prototype=Object.assign(Object.create(Curve.prototype),{\n\nconstructor:CurvePath,\n\nadd:function add(curve){\n\nthis.curves.push(curve);\n\n},\n\nclosePath:function closePath(){\n\n// Add a line curve if start and end of lines are not connected\nvar startPoint=this.curves[0].getPoint(0);\nvar endPoint=this.curves[this.curves.length-1].getPoint(1);\n\nif(!startPoint.equals(endPoint)){\n\nthis.curves.push(new LineCurve(endPoint,startPoint));\n\n}\n\n},\n\n// To get accurate point with reference to\n// entire path distance at time t,\n// following has to be done:\n\n// 1. Length of each sub path have to be known\n// 2. Locate and identify type of curve\n// 3. Get t for the curve\n// 4. Return curve.getPointAt(t')\n\ngetPoint:function getPoint(t){\n\nvar d=t*this.getLength();\nvar curveLengths=this.getCurveLengths();\nvar i=0;\n\n// To think about boundaries points.\n\nwhile(i<curveLengths.length){\n\nif(curveLengths[i]>=d){\n\nvar diff=curveLengths[i]-d;\nvar curve=this.curves[i];\n\nvar segmentLength=curve.getLength();\nvar u=segmentLength===0?0:1-diff/segmentLength;\n\nreturn curve.getPointAt(u);\n\n}\n\ni++;\n\n}\n\nreturn null;\n\n// loop where sum != 0, sum > d , sum+1 <d\n\n},\n\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n// getPoint() depends on getLength\n\ngetLength:function getLength(){\n\nvar lens=this.getCurveLengths();\nreturn lens[lens.length-1];\n\n},\n\n// cacheLengths must be recalculated.\nupdateArcLengths:function updateArcLengths(){\n\nthis.needsUpdate=true;\nthis.cacheLengths=null;\nthis.getLengths();\n\n},\n\n// Compute lengths and cache them\n// We cannot overwrite getLengths() because UtoT mapping uses it.\n\ngetCurveLengths:function getCurveLengths(){\n\n// We use cache values if curves and cache array are same length\n\nif(this.cacheLengths&&this.cacheLengths.length===this.curves.length){\n\nreturn this.cacheLengths;\n\n}\n\n// Get length of sub-curve\n// Push sums into cached array\n\nvar lengths=[],sums=0;\n\nfor(var i=0,l=this.curves.length;i<l;i++){\n\nsums+=this.curves[i].getLength();\nlengths.push(sums);\n\n}\n\nthis.cacheLengths=lengths;\n\nreturn lengths;\n\n},\n\ngetSpacedPoints:function getSpacedPoints(divisions){\n\nif(isNaN(divisions))divisions=40;\n\nvar points=[];\n\nfor(var i=0;i<=divisions;i++){\n\npoints.push(this.getPoint(i/divisions));\n\n}\n\nif(this.autoClose){\n\npoints.push(points[0]);\n\n}\n\nreturn points;\n\n},\n\ngetPoints:function getPoints(divisions){\n\ndivisions=divisions||12;\n\nvar points=[],last;\n\nfor(var i=0,curves=this.curves;i<curves.length;i++){\n\nvar curve=curves[i];\nvar resolution=curve&&curve.isEllipseCurve?divisions*2:\ncurve&&curve.isLineCurve?1:\ncurve&&curve.isSplineCurve?divisions*curve.points.length:\ndivisions;\n\nvar pts=curve.getPoints(resolution);\n\nfor(var j=0;j<pts.length;j++){\n\nvar point=pts[j];\n\nif(last&&last.equals(point))continue;// ensures no consecutive points are duplicates\n\npoints.push(point);\nlast=point;\n\n}\n\n}\n\nif(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){\n\npoints.push(points[0]);\n\n}\n\nreturn points;\n\n},\n\n/**************************************************************\n\t\t *\tCreate Geometries Helpers\n\t\t **************************************************************/\n\n/// Generate geometry from path points (for Line or Points objects)\n\ncreatePointsGeometry:function createPointsGeometry(divisions){\n\nvar pts=this.getPoints(divisions);\nreturn this.createGeometry(pts);\n\n},\n\n// Generate geometry from equidistant sampling along the path\n\ncreateSpacedPointsGeometry:function createSpacedPointsGeometry(divisions){\n\nvar pts=this.getSpacedPoints(divisions);\nreturn this.createGeometry(pts);\n\n},\n\ncreateGeometry:function createGeometry(points){\n\nvar geometry=new Geometry();\n\nfor(var i=0,l=points.length;i<l;i++){\n\nvar point=points[i];\ngeometry.vertices.push(new Vector3(point.x,point.y,point.z||0));\n\n}\n\nreturn geometry;\n\n}});\n\n\n\nfunction EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){\n\nthis.aX=aX;\nthis.aY=aY;\n\nthis.xRadius=xRadius;\nthis.yRadius=yRadius;\n\nthis.aStartAngle=aStartAngle;\nthis.aEndAngle=aEndAngle;\n\nthis.aClockwise=aClockwise;\n\nthis.aRotation=aRotation||0;\n\n}\n\nEllipseCurve.prototype=Object.create(Curve.prototype);\nEllipseCurve.prototype.constructor=EllipseCurve;\n\nEllipseCurve.prototype.isEllipseCurve=true;\n\nEllipseCurve.prototype.getPoint=function(t){\n\nvar twoPi=Math.PI*2;\nvar deltaAngle=this.aEndAngle-this.aStartAngle;\nvar samePoints=Math.abs(deltaAngle)<Number.EPSILON;\n\n// ensures that deltaAngle is 0 .. 2 PI\nwhile(deltaAngle<0){deltaAngle+=twoPi;}\nwhile(deltaAngle>twoPi){deltaAngle-=twoPi;}\n\nif(deltaAngle<Number.EPSILON){\n\nif(samePoints){\n\ndeltaAngle=0;\n\n}else{\n\ndeltaAngle=twoPi;\n\n}\n\n}\n\nif(this.aClockwise===true&&!samePoints){\n\nif(deltaAngle===twoPi){\n\ndeltaAngle=-twoPi;\n\n}else{\n\ndeltaAngle=deltaAngle-twoPi;\n\n}\n\n}\n\nvar angle=this.aStartAngle+t*deltaAngle;\nvar x=this.aX+this.xRadius*Math.cos(angle);\nvar y=this.aY+this.yRadius*Math.sin(angle);\n\nif(this.aRotation!==0){\n\nvar cos=Math.cos(this.aRotation);\nvar sin=Math.sin(this.aRotation);\n\nvar tx=x-this.aX;\nvar ty=y-this.aY;\n\n// Rotate the point about the center of the ellipse.\nx=tx*cos-ty*sin+this.aX;\ny=tx*sin+ty*cos+this.aY;\n\n}\n\nreturn new Vector2(x,y);\n\n};\n\nfunction SplineCurve(points/* array of Vector2 */){\n\nthis.points=points===undefined?[]:points;\n\n}\n\nSplineCurve.prototype=Object.create(Curve.prototype);\nSplineCurve.prototype.constructor=SplineCurve;\n\nSplineCurve.prototype.isSplineCurve=true;\n\nSplineCurve.prototype.getPoint=function(t){\n\nvar points=this.points;\nvar point=(points.length-1)*t;\n\nvar intPoint=Math.floor(point);\nvar weight=point-intPoint;\n\nvar point0=points[intPoint===0?intPoint:intPoint-1];\nvar point1=points[intPoint];\nvar point2=points[intPoint>points.length-2?points.length-1:intPoint+1];\nvar point3=points[intPoint>points.length-3?points.length-1:intPoint+2];\n\nreturn new Vector2(\nCatmullRom(weight,point0.x,point1.x,point2.x,point3.x),\nCatmullRom(weight,point0.y,point1.y,point2.y,point3.y));\n\n\n};\n\nfunction CubicBezierCurve(v0,v1,v2,v3){\n\nthis.v0=v0;\nthis.v1=v1;\nthis.v2=v2;\nthis.v3=v3;\n\n}\n\nCubicBezierCurve.prototype=Object.create(Curve.prototype);\nCubicBezierCurve.prototype.constructor=CubicBezierCurve;\n\nCubicBezierCurve.prototype.getPoint=function(t){\n\nvar v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;\n\nreturn new Vector2(\nCubicBezier(t,v0.x,v1.x,v2.x,v3.x),\nCubicBezier(t,v0.y,v1.y,v2.y,v3.y));\n\n\n};\n\nfunction QuadraticBezierCurve(v0,v1,v2){\n\nthis.v0=v0;\nthis.v1=v1;\nthis.v2=v2;\n\n}\n\nQuadraticBezierCurve.prototype=Object.create(Curve.prototype);\nQuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve;\n\nQuadraticBezierCurve.prototype.getPoint=function(t){\n\nvar v0=this.v0,v1=this.v1,v2=this.v2;\n\nreturn new Vector2(\nQuadraticBezier(t,v0.x,v1.x,v2.x),\nQuadraticBezier(t,v0.y,v1.y,v2.y));\n\n\n};\n\nvar PathPrototype=Object.assign(Object.create(CurvePath.prototype),{\n\nfromPoints:function fromPoints(vectors){\n\nthis.moveTo(vectors[0].x,vectors[0].y);\n\nfor(var i=1,l=vectors.length;i<l;i++){\n\nthis.lineTo(vectors[i].x,vectors[i].y);\n\n}\n\n},\n\nmoveTo:function moveTo(x,y){\n\nthis.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?\n\n},\n\nlineTo:function lineTo(x,y){\n\nvar curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));\nthis.curves.push(curve);\n\nthis.currentPoint.set(x,y);\n\n},\n\nquadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){\n\nvar curve=new QuadraticBezierCurve(\nthis.currentPoint.clone(),\nnew Vector2(aCPx,aCPy),\nnew Vector2(aX,aY));\n\n\nthis.curves.push(curve);\n\nthis.currentPoint.set(aX,aY);\n\n},\n\nbezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){\n\nvar curve=new CubicBezierCurve(\nthis.currentPoint.clone(),\nnew Vector2(aCP1x,aCP1y),\nnew Vector2(aCP2x,aCP2y),\nnew Vector2(aX,aY));\n\n\nthis.curves.push(curve);\n\nthis.currentPoint.set(aX,aY);\n\n},\n\nsplineThru:function splineThru(pts/*Array of Vector*/){\n\nvar npts=[this.currentPoint.clone()].concat(pts);\n\nvar curve=new SplineCurve(npts);\nthis.curves.push(curve);\n\nthis.currentPoint.copy(pts[pts.length-1]);\n\n},\n\narc:function arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){\n\nvar x0=this.currentPoint.x;\nvar y0=this.currentPoint.y;\n\nthis.absarc(aX+x0,aY+y0,aRadius,\naStartAngle,aEndAngle,aClockwise);\n\n},\n\nabsarc:function absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){\n\nthis.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);\n\n},\n\nellipse:function ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){\n\nvar x0=this.currentPoint.x;\nvar y0=this.currentPoint.y;\n\nthis.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);\n\n},\n\nabsellipse:function absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){\n\nvar curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);\n\nif(this.curves.length>0){\n\n// if a previous curve is present, attempt to join\nvar firstPoint=curve.getPoint(0);\n\nif(!firstPoint.equals(this.currentPoint)){\n\nthis.lineTo(firstPoint.x,firstPoint.y);\n\n}\n\n}\n\nthis.curves.push(curve);\n\nvar lastPoint=curve.getPoint(1);\nthis.currentPoint.copy(lastPoint);\n\n}});\n\n\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Creates free form 2d path using series of points, lines or curves.\n\t **/\n\nfunction Path(points){\n\nCurvePath.call(this);\nthis.currentPoint=new Vector2();\n\nif(points){\n\nthis.fromPoints(points);\n\n}\n\n}\n\nPath.prototype=PathPrototype;\nPathPrototype.constructor=Path;\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * Defines a 2d shape plane using paths.\n\t **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nfunction Shape(){\n\nPath.apply(this,arguments);\n\nthis.holes=[];\n\n}\n\nShape.prototype=Object.assign(Object.create(PathPrototype),{\n\nconstructor:Shape,\n\ngetPointsHoles:function getPointsHoles(divisions){\n\nvar holesPts=[];\n\nfor(var i=0,l=this.holes.length;i<l;i++){\n\nholesPts[i]=this.holes[i].getPoints(divisions);\n\n}\n\nreturn holesPts;\n\n},\n\n// Get points of shape and holes (keypoints based on segments parameter)\n\nextractAllPoints:function extractAllPoints(divisions){\n\nreturn{\n\nshape:this.getPoints(divisions),\nholes:this.getPointsHoles(divisions)};\n\n\n\n},\n\nextractPoints:function extractPoints(divisions){\n\nreturn this.extractAllPoints(divisions);\n\n}});\n\n\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * minimal class for proxing functions to Path. Replaces old \"extractSubpaths()\"\n\t **/\n\nfunction ShapePath(){\n\nthis.subPaths=[];\nthis.currentPath=null;\n\n}\n\nShapePath.prototype={\n\nmoveTo:function moveTo(x,y){\n\nthis.currentPath=new Path();\nthis.subPaths.push(this.currentPath);\nthis.currentPath.moveTo(x,y);\n\n},\n\nlineTo:function lineTo(x,y){\n\nthis.currentPath.lineTo(x,y);\n\n},\n\nquadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){\n\nthis.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);\n\n},\n\nbezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){\n\nthis.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);\n\n},\n\nsplineThru:function splineThru(pts){\n\nthis.currentPath.splineThru(pts);\n\n},\n\ntoShapes:function toShapes(isCCW,noHoles){\n\nfunction toShapesNoHoles(inSubpaths){\n\nvar shapes=[];\n\nfor(var i=0,l=inSubpaths.length;i<l;i++){\n\nvar tmpPath=inSubpaths[i];\n\nvar tmpShape=new Shape();\ntmpShape.curves=tmpPath.curves;\n\nshapes.push(tmpShape);\n\n}\n\nreturn shapes;\n\n}\n\nfunction isPointInsidePolygon(inPt,inPolygon){\n\nvar polyLen=inPolygon.length;\n\n// inPt on polygon contour => immediate success    or\n// toggling of inside/outside at every single! intersection point of an edge\n//  with the horizontal line through inPt, left of inPt\n//  not counting lowerY endpoints of edges and whole edges on that line\nvar inside=false;\nfor(var p=polyLen-1,q=0;q<polyLen;p=q++){\n\nvar edgeLowPt=inPolygon[p];\nvar edgeHighPt=inPolygon[q];\n\nvar edgeDx=edgeHighPt.x-edgeLowPt.x;\nvar edgeDy=edgeHighPt.y-edgeLowPt.y;\n\nif(Math.abs(edgeDy)>Number.EPSILON){\n\n// not parallel\nif(edgeDy<0){\n\nedgeLowPt=inPolygon[q];edgeDx=-edgeDx;\nedgeHighPt=inPolygon[p];edgeDy=-edgeDy;\n\n}\nif(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;\n\nif(inPt.y===edgeLowPt.y){\n\nif(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?\n// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n}else{\n\nvar perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);\nif(perpEdge===0)return true;// inPt is on contour ?\nif(perpEdge<0)continue;\ninside=!inside;// true intersection left of inPt\n\n}\n\n}else{\n\n// parallel or collinear\nif(inPt.y!==edgeLowPt.y)continue;// parallel\n// edge lies on the same horizontal line as inPt\nif(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||\nedgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !\n// continue;\n\n}\n\n}\n\nreturn inside;\n\n}\n\nvar isClockWise=ShapeUtils.isClockWise;\n\nvar subPaths=this.subPaths;\nif(subPaths.length===0)return[];\n\nif(noHoles===true)return toShapesNoHoles(subPaths);\n\n\nvar solid,tmpPath,tmpShape,shapes=[];\n\nif(subPaths.length===1){\n\ntmpPath=subPaths[0];\ntmpShape=new Shape();\ntmpShape.curves=tmpPath.curves;\nshapes.push(tmpShape);\nreturn shapes;\n\n}\n\nvar holesFirst=!isClockWise(subPaths[0].getPoints());\nholesFirst=isCCW?!holesFirst:holesFirst;\n\n// console.log(\"Holes first\", holesFirst);\n\nvar betterShapeHoles=[];\nvar newShapes=[];\nvar newShapeHoles=[];\nvar mainIdx=0;\nvar tmpPoints;\n\nnewShapes[mainIdx]=undefined;\nnewShapeHoles[mainIdx]=[];\n\nfor(var i=0,l=subPaths.length;i<l;i++){\n\ntmpPath=subPaths[i];\ntmpPoints=tmpPath.getPoints();\nsolid=isClockWise(tmpPoints);\nsolid=isCCW?!solid:solid;\n\nif(solid){\n\nif(!holesFirst&&newShapes[mainIdx])mainIdx++;\n\nnewShapes[mainIdx]={s:new Shape(),p:tmpPoints};\nnewShapes[mainIdx].s.curves=tmpPath.curves;\n\nif(holesFirst)mainIdx++;\nnewShapeHoles[mainIdx]=[];\n\n//console.log('cw', i);\n\n}else{\n\nnewShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});\n\n//console.log('ccw', i);\n\n}\n\n}\n\n// only Holes? -> probably all Shapes with wrong orientation\nif(!newShapes[0])return toShapesNoHoles(subPaths);\n\n\nif(newShapes.length>1){\n\nvar ambiguous=false;\nvar toChange=[];\n\nfor(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){\n\nbetterShapeHoles[sIdx]=[];\n\n}\n\nfor(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){\n\nvar sho=newShapeHoles[sIdx];\n\nfor(var hIdx=0;hIdx<sho.length;hIdx++){\n\nvar ho=sho[hIdx];\nvar hole_unassigned=true;\n\nfor(var s2Idx=0;s2Idx<newShapes.length;s2Idx++){\n\nif(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){\n\nif(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});\nif(hole_unassigned){\n\nhole_unassigned=false;\nbetterShapeHoles[s2Idx].push(ho);\n\n}else{\n\nambiguous=true;\n\n}\n\n}\n\n}\nif(hole_unassigned){\n\nbetterShapeHoles[sIdx].push(ho);\n\n}\n\n}\n\n}\n// console.log(\"ambiguous: \", ambiguous);\nif(toChange.length>0){\n\n// console.log(\"to change: \", toChange);\nif(!ambiguous)newShapeHoles=betterShapeHoles;\n\n}\n\n}\n\nvar tmpHoles;\n\nfor(var i=0,il=newShapes.length;i<il;i++){\n\ntmpShape=newShapes[i].s;\nshapes.push(tmpShape);\ntmpHoles=newShapeHoles[i];\n\nfor(var j=0,jl=tmpHoles.length;j<jl;j++){\n\ntmpShape.holes.push(tmpHoles[j].h);\n\n}\n\n}\n\n//console.log(\"shape\", shapes);\n\nreturn shapes;\n\n}};\n\n\n\n/**\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Font(data){\n\nthis.data=data;\n\n}\n\nObject.assign(Font.prototype,{\n\nisFont:true,\n\ngenerateShapes:function generateShapes(text,size,divisions){\n\nfunction createPaths(text){\n\nvar chars=String(text).split('');\nvar scale=size/data.resolution;\nvar line_height=(data.boundingBox.yMax-data.boundingBox.yMin+data.underlineThickness)*scale;\n\nvar offsetX=0,offsetY=0;\n\nvar paths=[];\n\nfor(var i=0;i<chars.length;i++){\n\nvar char=chars[i];\n\nif(char==='\\n'){\n\noffsetX=0;\noffsetY-=line_height;\n\n}else{\n\nvar ret=createPath(char,scale,offsetX,offsetY);\noffsetX+=ret.offsetX;\npaths.push(ret.path);\n\n}\n\n}\n\nreturn paths;\n\n}\n\nfunction createPath(c,scale,offsetX,offsetY){\n\nvar glyph=data.glyphs[c]||data.glyphs['?'];\n\nif(!glyph)return;\n\nvar path=new ShapePath();\n\nvar pts=[];\nvar x,y,cpx,cpy,cpx0,cpy0,cpx1,cpy1,cpx2,cpy2,laste;\n\nif(glyph.o){\n\nvar outline=glyph._cachedOutline||(glyph._cachedOutline=glyph.o.split(' '));\n\nfor(var i=0,l=outline.length;i<l;){\n\nvar action=outline[i++];\n\nswitch(action){\n\ncase'm':// moveTo\n\nx=outline[i++]*scale+offsetX;\ny=outline[i++]*scale+offsetY;\n\npath.moveTo(x,y);\n\nbreak;\n\ncase'l':// lineTo\n\nx=outline[i++]*scale+offsetX;\ny=outline[i++]*scale+offsetY;\n\npath.lineTo(x,y);\n\nbreak;\n\ncase'q':// quadraticCurveTo\n\ncpx=outline[i++]*scale+offsetX;\ncpy=outline[i++]*scale+offsetY;\ncpx1=outline[i++]*scale+offsetX;\ncpy1=outline[i++]*scale+offsetY;\n\npath.quadraticCurveTo(cpx1,cpy1,cpx,cpy);\n\nlaste=pts[pts.length-1];\n\nif(laste){\n\ncpx0=laste.x;\ncpy0=laste.y;\n\nfor(var i2=1;i2<=divisions;i2++){\n\nvar t=i2/divisions;\nQuadraticBezier(t,cpx0,cpx1,cpx);\nQuadraticBezier(t,cpy0,cpy1,cpy);\n\n}\n\n}\n\nbreak;\n\ncase'b':// bezierCurveTo\n\ncpx=outline[i++]*scale+offsetX;\ncpy=outline[i++]*scale+offsetY;\ncpx1=outline[i++]*scale+offsetX;\ncpy1=outline[i++]*scale+offsetY;\ncpx2=outline[i++]*scale+offsetX;\ncpy2=outline[i++]*scale+offsetY;\n\npath.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,cpx,cpy);\n\nlaste=pts[pts.length-1];\n\nif(laste){\n\ncpx0=laste.x;\ncpy0=laste.y;\n\nfor(var i2=1;i2<=divisions;i2++){\n\nvar t=i2/divisions;\nCubicBezier(t,cpx0,cpx1,cpx2,cpx);\nCubicBezier(t,cpy0,cpy1,cpy2,cpy);\n\n}\n\n}\n\nbreak;}\n\n\n\n}\n\n}\n\nreturn{offsetX:glyph.ha*scale,path:path};\n\n}\n\n//\n\nif(size===undefined)size=100;\nif(divisions===undefined)divisions=4;\n\nvar data=this.data;\n\nvar paths=createPaths(text);\nvar shapes=[];\n\nfor(var p=0,pl=paths.length;p<pl;p++){\n\nArray.prototype.push.apply(shapes,paths[p].toShapes());\n\n}\n\nreturn shapes;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction FontLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n}\n\nObject.assign(FontLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nvar scope=this;\n\nvar loader=new FileLoader(this.manager);\nloader.load(url,function(text){\n\nvar json;\n\ntry{\n\njson=JSON.parse(text);\n\n}catch(e){\n\nconsole.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');\njson=JSON.parse(text.substring(65,text.length-2));\n\n}\n\nvar font=scope.parse(json);\n\nif(onLoad)onLoad(font);\n\n},onProgress,onError);\n\n},\n\nparse:function parse(json){\n\nreturn new Font(json);\n\n}});\n\n\n\nvar context;\n\nvar AudioContext={\n\ngetContext:function getContext(){\n\nif(context===undefined){\n\ncontext=new(window.AudioContext||window.webkitAudioContext)();\n\n}\n\nreturn context;\n\n},\n\nsetContext:function setContext(value){\n\ncontext=value;\n\n}};\n\n\n\n/**\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\nfunction AudioLoader(manager){\n\nthis.manager=manager!==undefined?manager:DefaultLoadingManager;\n\n}\n\nObject.assign(AudioLoader.prototype,{\n\nload:function load(url,onLoad,onProgress,onError){\n\nvar loader=new FileLoader(this.manager);\nloader.setResponseType('arraybuffer');\nloader.load(url,function(buffer){\n\nvar context=AudioContext.getContext();\n\ncontext.decodeAudioData(buffer,function(audioBuffer){\n\nonLoad(audioBuffer);\n\n});\n\n},onProgress,onError);\n\n}});\n\n\n\n/**\n\t * @author abelnation / http://github.com/abelnation\n\t */\n\nfunction RectAreaLight(color,intensity,width,height){\n\nLight.call(this,color,intensity);\n\nthis.type='RectAreaLight';\n\nthis.position.set(0,1,0);\nthis.updateMatrix();\n\nthis.width=width!==undefined?width:10;\nthis.height=height!==undefined?height:10;\n\n// TODO (abelnation): distance/decay\n\n// TODO (abelnation): update method for RectAreaLight to update transform to lookat target\n\n// TODO (abelnation): shadows\n// this.shadow = new THREE.RectAreaLightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n}\n\n// TODO (abelnation): RectAreaLight update when light shape is changed\nRectAreaLight.prototype=Object.assign(Object.create(Light.prototype),{\n\nconstructor:RectAreaLight,\n\nisRectAreaLight:true,\n\ncopy:function copy(source){\n\nLight.prototype.copy.call(this,source);\n\nthis.width=source.width;\nthis.height=source.height;\n\n// this.shadow = source.shadow.clone();\n\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction StereoCamera(){\n\nthis.type='StereoCamera';\n\nthis.aspect=1;\n\nthis.eyeSep=0.064;\n\nthis.cameraL=new PerspectiveCamera();\nthis.cameraL.layers.enable(1);\nthis.cameraL.matrixAutoUpdate=false;\n\nthis.cameraR=new PerspectiveCamera();\nthis.cameraR.layers.enable(2);\nthis.cameraR.matrixAutoUpdate=false;\n\n}\n\nObject.assign(StereoCamera.prototype,{\n\nupdate:function(){\n\nvar instance,focus,fov,aspect,near,far,zoom;\n\nvar eyeRight=new Matrix4();\nvar eyeLeft=new Matrix4();\n\nreturn function update(camera){\n\nvar needsUpdate=instance!==this||focus!==camera.focus||fov!==camera.fov||\naspect!==camera.aspect*this.aspect||near!==camera.near||\nfar!==camera.far||zoom!==camera.zoom;\n\nif(needsUpdate){\n\ninstance=this;\nfocus=camera.focus;\nfov=camera.fov;\naspect=camera.aspect*this.aspect;\nnear=camera.near;\nfar=camera.far;\nzoom=camera.zoom;\n\n// Off-axis stereoscopic effect based on\n// http://paulbourke.net/stereographics/stereorender/\n\nvar projectionMatrix=camera.projectionMatrix.clone();\nvar eyeSep=this.eyeSep/2;\nvar eyeSepOnProjection=eyeSep*near/focus;\nvar ymax=near*Math.tan(_Math.DEG2RAD*fov*0.5)/zoom;\nvar xmin,xmax;\n\n// translate xOffset\n\neyeLeft.elements[12]=-eyeSep;\neyeRight.elements[12]=eyeSep;\n\n// for left eye\n\nxmin=-ymax*aspect+eyeSepOnProjection;\nxmax=ymax*aspect+eyeSepOnProjection;\n\nprojectionMatrix.elements[0]=2*near/(xmax-xmin);\nprojectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);\n\nthis.cameraL.projectionMatrix.copy(projectionMatrix);\n\n// for right eye\n\nxmin=-ymax*aspect-eyeSepOnProjection;\nxmax=ymax*aspect-eyeSepOnProjection;\n\nprojectionMatrix.elements[0]=2*near/(xmax-xmin);\nprojectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);\n\nthis.cameraR.projectionMatrix.copy(projectionMatrix);\n\n}\n\nthis.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);\nthis.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);\n\n};\n\n}()});\n\n\n\n/**\n\t * Camera for rendering cube maps\n\t *\t- renders scene into axis-aligned cube\n\t *\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction CubeCamera(near,far,cubeResolution){\n\nObject3D.call(this);\n\nthis.type='CubeCamera';\n\nvar fov=90,aspect=1;\n\nvar cameraPX=new PerspectiveCamera(fov,aspect,near,far);\ncameraPX.up.set(0,-1,0);\ncameraPX.lookAt(new Vector3(1,0,0));\nthis.add(cameraPX);\n\nvar cameraNX=new PerspectiveCamera(fov,aspect,near,far);\ncameraNX.up.set(0,-1,0);\ncameraNX.lookAt(new Vector3(-1,0,0));\nthis.add(cameraNX);\n\nvar cameraPY=new PerspectiveCamera(fov,aspect,near,far);\ncameraPY.up.set(0,0,1);\ncameraPY.lookAt(new Vector3(0,1,0));\nthis.add(cameraPY);\n\nvar cameraNY=new PerspectiveCamera(fov,aspect,near,far);\ncameraNY.up.set(0,0,-1);\ncameraNY.lookAt(new Vector3(0,-1,0));\nthis.add(cameraNY);\n\nvar cameraPZ=new PerspectiveCamera(fov,aspect,near,far);\ncameraPZ.up.set(0,-1,0);\ncameraPZ.lookAt(new Vector3(0,0,1));\nthis.add(cameraPZ);\n\nvar cameraNZ=new PerspectiveCamera(fov,aspect,near,far);\ncameraNZ.up.set(0,-1,0);\ncameraNZ.lookAt(new Vector3(0,0,-1));\nthis.add(cameraNZ);\n\nvar options={format:RGBFormat,magFilter:LinearFilter,minFilter:LinearFilter};\n\nthis.renderTarget=new WebGLRenderTargetCube(cubeResolution,cubeResolution,options);\n\nthis.updateCubeMap=function(renderer,scene){\n\nif(this.parent===null)this.updateMatrixWorld();\n\nvar renderTarget=this.renderTarget;\nvar generateMipmaps=renderTarget.texture.generateMipmaps;\n\nrenderTarget.texture.generateMipmaps=false;\n\nrenderTarget.activeCubeFace=0;\nrenderer.render(scene,cameraPX,renderTarget);\n\nrenderTarget.activeCubeFace=1;\nrenderer.render(scene,cameraNX,renderTarget);\n\nrenderTarget.activeCubeFace=2;\nrenderer.render(scene,cameraPY,renderTarget);\n\nrenderTarget.activeCubeFace=3;\nrenderer.render(scene,cameraNY,renderTarget);\n\nrenderTarget.activeCubeFace=4;\nrenderer.render(scene,cameraPZ,renderTarget);\n\nrenderTarget.texture.generateMipmaps=generateMipmaps;\n\nrenderTarget.activeCubeFace=5;\nrenderer.render(scene,cameraNZ,renderTarget);\n\nrenderer.setRenderTarget(null);\n\n};\n\n}\n\nCubeCamera.prototype=Object.create(Object3D.prototype);\nCubeCamera.prototype.constructor=CubeCamera;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction AudioListener(){\n\nObject3D.call(this);\n\nthis.type='AudioListener';\n\nthis.context=AudioContext.getContext();\n\nthis.gain=this.context.createGain();\nthis.gain.connect(this.context.destination);\n\nthis.filter=null;\n\n}\n\nAudioListener.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:AudioListener,\n\ngetInput:function getInput(){\n\nreturn this.gain;\n\n},\n\nremoveFilter:function removeFilter(){\n\nif(this.filter!==null){\n\nthis.gain.disconnect(this.filter);\nthis.filter.disconnect(this.context.destination);\nthis.gain.connect(this.context.destination);\nthis.filter=null;\n\n}\n\n},\n\ngetFilter:function getFilter(){\n\nreturn this.filter;\n\n},\n\nsetFilter:function setFilter(value){\n\nif(this.filter!==null){\n\nthis.gain.disconnect(this.filter);\nthis.filter.disconnect(this.context.destination);\n\n}else{\n\nthis.gain.disconnect(this.context.destination);\n\n}\n\nthis.filter=value;\nthis.gain.connect(this.filter);\nthis.filter.connect(this.context.destination);\n\n},\n\ngetMasterVolume:function getMasterVolume(){\n\nreturn this.gain.gain.value;\n\n},\n\nsetMasterVolume:function setMasterVolume(value){\n\nthis.gain.gain.value=value;\n\n},\n\nupdateMatrixWorld:function(){\n\nvar position=new Vector3();\nvar quaternion=new Quaternion();\nvar scale=new Vector3();\n\nvar orientation=new Vector3();\n\nreturn function updateMatrixWorld(force){\n\nObject3D.prototype.updateMatrixWorld.call(this,force);\n\nvar listener=this.context.listener;\nvar up=this.up;\n\nthis.matrixWorld.decompose(position,quaternion,scale);\n\norientation.set(0,0,-1).applyQuaternion(quaternion);\n\nif(listener.positionX){\n\nlistener.positionX.setValueAtTime(position.x,this.context.currentTime);\nlistener.positionY.setValueAtTime(position.y,this.context.currentTime);\nlistener.positionZ.setValueAtTime(position.z,this.context.currentTime);\nlistener.forwardX.setValueAtTime(orientation.x,this.context.currentTime);\nlistener.forwardY.setValueAtTime(orientation.y,this.context.currentTime);\nlistener.forwardZ.setValueAtTime(orientation.z,this.context.currentTime);\nlistener.upX.setValueAtTime(up.x,this.context.currentTime);\nlistener.upY.setValueAtTime(up.y,this.context.currentTime);\nlistener.upZ.setValueAtTime(up.z,this.context.currentTime);\n\n}else{\n\nlistener.setPosition(position.x,position.y,position.z);\nlistener.setOrientation(orientation.x,orientation.y,orientation.z,up.x,up.y,up.z);\n\n}\n\n};\n\n}()});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\n\t */\n\nfunction Audio(listener){\n\nObject3D.call(this);\n\nthis.type='Audio';\n\nthis.context=listener.context;\n\nthis.gain=this.context.createGain();\nthis.gain.connect(listener.getInput());\n\nthis.autoplay=false;\n\nthis.buffer=null;\nthis.loop=false;\nthis.startTime=0;\nthis.playbackRate=1;\nthis.isPlaying=false;\nthis.hasPlaybackControl=true;\nthis.sourceType='empty';\n\nthis.filters=[];\n\n}\n\nAudio.prototype=Object.assign(Object.create(Object3D.prototype),{\n\nconstructor:Audio,\n\ngetOutput:function getOutput(){\n\nreturn this.gain;\n\n},\n\nsetNodeSource:function setNodeSource(audioNode){\n\nthis.hasPlaybackControl=false;\nthis.sourceType='audioNode';\nthis.source=audioNode;\nthis.connect();\n\nreturn this;\n\n},\n\nsetBuffer:function setBuffer(audioBuffer){\n\nthis.buffer=audioBuffer;\nthis.sourceType='buffer';\n\nif(this.autoplay)this.play();\n\nreturn this;\n\n},\n\nplay:function play(){\n\nif(this.isPlaying===true){\n\nconsole.warn('THREE.Audio: Audio is already playing.');\nreturn;\n\n}\n\nif(this.hasPlaybackControl===false){\n\nconsole.warn('THREE.Audio: this Audio has no playback control.');\nreturn;\n\n}\n\nvar source=this.context.createBufferSource();\n\nsource.buffer=this.buffer;\nsource.loop=this.loop;\nsource.onended=this.onEnded.bind(this);\nsource.playbackRate.setValueAtTime(this.playbackRate,this.startTime);\nsource.start(0,this.startTime);\n\nthis.isPlaying=true;\n\nthis.source=source;\n\nreturn this.connect();\n\n},\n\npause:function pause(){\n\nif(this.hasPlaybackControl===false){\n\nconsole.warn('THREE.Audio: this Audio has no playback control.');\nreturn;\n\n}\n\nthis.source.stop();\nthis.startTime=this.context.currentTime;\nthis.isPlaying=false;\n\nreturn this;\n\n},\n\nstop:function stop(){\n\nif(this.hasPlaybackControl===false){\n\nconsole.warn('THREE.Audio: this Audio has no playback control.');\nreturn;\n\n}\n\nthis.source.stop();\nthis.startTime=0;\nthis.isPlaying=false;\n\nreturn this;\n\n},\n\nconnect:function connect(){\n\nif(this.filters.length>0){\n\nthis.source.connect(this.filters[0]);\n\nfor(var i=1,l=this.filters.length;i<l;i++){\n\nthis.filters[i-1].connect(this.filters[i]);\n\n}\n\nthis.filters[this.filters.length-1].connect(this.getOutput());\n\n}else{\n\nthis.source.connect(this.getOutput());\n\n}\n\nreturn this;\n\n},\n\ndisconnect:function disconnect(){\n\nif(this.filters.length>0){\n\nthis.source.disconnect(this.filters[0]);\n\nfor(var i=1,l=this.filters.length;i<l;i++){\n\nthis.filters[i-1].disconnect(this.filters[i]);\n\n}\n\nthis.filters[this.filters.length-1].disconnect(this.getOutput());\n\n}else{\n\nthis.source.disconnect(this.getOutput());\n\n}\n\nreturn this;\n\n},\n\ngetFilters:function getFilters(){\n\nreturn this.filters;\n\n},\n\nsetFilters:function setFilters(value){\n\nif(!value)value=[];\n\nif(this.isPlaying===true){\n\nthis.disconnect();\nthis.filters=value;\nthis.connect();\n\n}else{\n\nthis.filters=value;\n\n}\n\nreturn this;\n\n},\n\ngetFilter:function getFilter(){\n\nreturn this.getFilters()[0];\n\n},\n\nsetFilter:function setFilter(filter){\n\nreturn this.setFilters(filter?[filter]:[]);\n\n},\n\nsetPlaybackRate:function setPlaybackRate(value){\n\nif(this.hasPlaybackControl===false){\n\nconsole.warn('THREE.Audio: this Audio has no playback control.');\nreturn;\n\n}\n\nthis.playbackRate=value;\n\nif(this.isPlaying===true){\n\nthis.source.playbackRate.setValueAtTime(this.playbackRate,this.context.currentTime);\n\n}\n\nreturn this;\n\n},\n\ngetPlaybackRate:function getPlaybackRate(){\n\nreturn this.playbackRate;\n\n},\n\nonEnded:function onEnded(){\n\nthis.isPlaying=false;\n\n},\n\ngetLoop:function getLoop(){\n\nif(this.hasPlaybackControl===false){\n\nconsole.warn('THREE.Audio: this Audio has no playback control.');\nreturn false;\n\n}\n\nreturn this.loop;\n\n},\n\nsetLoop:function setLoop(value){\n\nif(this.hasPlaybackControl===false){\n\nconsole.warn('THREE.Audio: this Audio has no playback control.');\nreturn;\n\n}\n\nthis.loop=value;\n\nif(this.isPlaying===true){\n\nthis.source.loop=this.loop;\n\n}\n\nreturn this;\n\n},\n\ngetVolume:function getVolume(){\n\nreturn this.gain.gain.value;\n\n},\n\n\nsetVolume:function setVolume(value){\n\nthis.gain.gain.value=value;\n\nreturn this;\n\n}});\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction PositionalAudio(listener){\n\nAudio.call(this,listener);\n\nthis.panner=this.context.createPanner();\nthis.panner.connect(this.gain);\n\n}\n\nPositionalAudio.prototype=Object.assign(Object.create(Audio.prototype),{\n\nconstructor:PositionalAudio,\n\ngetOutput:function getOutput(){\n\nreturn this.panner;\n\n},\n\ngetRefDistance:function getRefDistance(){\n\nreturn this.panner.refDistance;\n\n},\n\nsetRefDistance:function setRefDistance(value){\n\nthis.panner.refDistance=value;\n\n},\n\ngetRolloffFactor:function getRolloffFactor(){\n\nreturn this.panner.rolloffFactor;\n\n},\n\nsetRolloffFactor:function setRolloffFactor(value){\n\nthis.panner.rolloffFactor=value;\n\n},\n\ngetDistanceModel:function getDistanceModel(){\n\nreturn this.panner.distanceModel;\n\n},\n\nsetDistanceModel:function setDistanceModel(value){\n\nthis.panner.distanceModel=value;\n\n},\n\ngetMaxDistance:function getMaxDistance(){\n\nreturn this.panner.maxDistance;\n\n},\n\nsetMaxDistance:function setMaxDistance(value){\n\nthis.panner.maxDistance=value;\n\n},\n\nupdateMatrixWorld:function(){\n\nvar position=new Vector3();\n\nreturn function updateMatrixWorld(force){\n\nObject3D.prototype.updateMatrixWorld.call(this,force);\n\nposition.setFromMatrixPosition(this.matrixWorld);\n\nthis.panner.setPosition(position.x,position.y,position.z);\n\n};\n\n}()});\n\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction AudioAnalyser(audio,fftSize){\n\nthis.analyser=audio.context.createAnalyser();\nthis.analyser.fftSize=fftSize!==undefined?fftSize:2048;\n\nthis.data=new Uint8Array(this.analyser.frequencyBinCount);\n\naudio.getOutput().connect(this.analyser);\n\n}\n\nObject.assign(AudioAnalyser.prototype,{\n\ngetFrequencyData:function getFrequencyData(){\n\nthis.analyser.getByteFrequencyData(this.data);\n\nreturn this.data;\n\n},\n\ngetAverageFrequency:function getAverageFrequency(){\n\nvar value=0,data=this.getFrequencyData();\n\nfor(var i=0;i<data.length;i++){\n\nvalue+=data[i];\n\n}\n\nreturn value/data.length;\n\n}});\n\n\n\n/**\n\t *\n\t * Buffered scene graph property that allows weighted accumulation.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction PropertyMixer(binding,typeName,valueSize){\n\nthis.binding=binding;\nthis.valueSize=valueSize;\n\nvar bufferType=Float64Array,\nmixFunction;\n\nswitch(typeName){\n\ncase'quaternion':\nmixFunction=this._slerp;\nbreak;\n\ncase'string':\ncase'bool':\nbufferType=Array;\nmixFunction=this._select;\nbreak;\n\ndefault:\nmixFunction=this._lerp;}\n\n\n\nthis.buffer=new bufferType(valueSize*4);\n// layout: [ incoming | accu0 | accu1 | orig ]\n//\n// interpolators can use .buffer as their .result\n// the data then goes to 'incoming'\n//\n// 'accu0' and 'accu1' are used frame-interleaved for\n// the cumulative result and are compared to detect\n// changes\n//\n// 'orig' stores the original state of the property\n\nthis._mixBufferRegion=mixFunction;\n\nthis.cumulativeWeight=0;\n\nthis.useCount=0;\nthis.referenceCount=0;\n\n}\n\nPropertyMixer.prototype={\n\nconstructor:PropertyMixer,\n\n// accumulate data in the 'incoming' region into 'accu<i>'\naccumulate:function accumulate(accuIndex,weight){\n\n// note: happily accumulating nothing when weight = 0, the caller knows\n// the weight and shouldn't have made the call in the first place\n\nvar buffer=this.buffer,\nstride=this.valueSize,\noffset=accuIndex*stride+stride,\n\ncurrentWeight=this.cumulativeWeight;\n\nif(currentWeight===0){\n\n// accuN := incoming * weight\n\nfor(var i=0;i!==stride;++i){\n\nbuffer[offset+i]=buffer[i];\n\n}\n\ncurrentWeight=weight;\n\n}else{\n\n// accuN := accuN + incoming * weight\n\ncurrentWeight+=weight;\nvar mix=weight/currentWeight;\nthis._mixBufferRegion(buffer,offset,0,mix,stride);\n\n}\n\nthis.cumulativeWeight=currentWeight;\n\n},\n\n// apply the state of 'accu<i>' to the binding when accus differ\napply:function apply(accuIndex){\n\nvar stride=this.valueSize,\nbuffer=this.buffer,\noffset=accuIndex*stride+stride,\n\nweight=this.cumulativeWeight,\n\nbinding=this.binding;\n\nthis.cumulativeWeight=0;\n\nif(weight<1){\n\n// accuN := accuN + original * ( 1 - cumulativeWeight )\n\nvar originalValueOffset=stride*3;\n\nthis._mixBufferRegion(\nbuffer,offset,originalValueOffset,1-weight,stride);\n\n}\n\nfor(var i=stride,e=stride+stride;i!==e;++i){\n\nif(buffer[i]!==buffer[i+stride]){\n\n// value has changed -> update scene graph\n\nbinding.setValue(buffer,offset);\nbreak;\n\n}\n\n}\n\n},\n\n// remember the state of the bound property and copy it to both accus\nsaveOriginalState:function saveOriginalState(){\n\nvar binding=this.binding;\n\nvar buffer=this.buffer,\nstride=this.valueSize,\n\noriginalValueOffset=stride*3;\n\nbinding.getValue(buffer,originalValueOffset);\n\n// accu[0..1] := orig -- initially detect changes against the original\nfor(var i=stride,e=originalValueOffset;i!==e;++i){\n\nbuffer[i]=buffer[originalValueOffset+i%stride];\n\n}\n\nthis.cumulativeWeight=0;\n\n},\n\n// apply the state previously taken via 'saveOriginalState' to the binding\nrestoreOriginalState:function restoreOriginalState(){\n\nvar originalValueOffset=this.valueSize*3;\nthis.binding.setValue(this.buffer,originalValueOffset);\n\n},\n\n\n// mix functions\n\n_select:function _select(buffer,dstOffset,srcOffset,t,stride){\n\nif(t>=0.5){\n\nfor(var i=0;i!==stride;++i){\n\nbuffer[dstOffset+i]=buffer[srcOffset+i];\n\n}\n\n}\n\n},\n\n_slerp:function _slerp(buffer,dstOffset,srcOffset,t,stride){\n\nQuaternion.slerpFlat(buffer,dstOffset,\nbuffer,dstOffset,buffer,srcOffset,t);\n\n},\n\n_lerp:function _lerp(buffer,dstOffset,srcOffset,t,stride){\n\nvar s=1-t;\n\nfor(var i=0;i!==stride;++i){\n\nvar j=dstOffset+i;\n\nbuffer[j]=buffer[j]*s+buffer[srcOffset+i]*t;\n\n}\n\n}};\n\n\n\n/**\n\t *\n\t * A reference to a real property in the scene graph.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction PropertyBinding(rootNode,path,parsedPath){\n\nthis.path=path;\nthis.parsedPath=parsedPath||\nPropertyBinding.parseTrackName(path);\n\nthis.node=PropertyBinding.findNode(\nrootNode,this.parsedPath.nodeName)||rootNode;\n\nthis.rootNode=rootNode;\n\n}\n\nPropertyBinding.prototype={\n\nconstructor:PropertyBinding,\n\ngetValue:function getValue_unbound(targetArray,offset){\n\nthis.bind();\nthis.getValue(targetArray,offset);\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\n\n},\n\nsetValue:function getValue_unbound(sourceArray,offset){\n\nthis.bind();\nthis.setValue(sourceArray,offset);\n\n},\n\n// create getter / setter pair for a property in the scene graph\nbind:function bind(){\n\nvar targetObject=this.node,\nparsedPath=this.parsedPath,\n\nobjectName=parsedPath.objectName,\npropertyName=parsedPath.propertyName,\npropertyIndex=parsedPath.propertyIndex;\n\nif(!targetObject){\n\ntargetObject=PropertyBinding.findNode(\nthis.rootNode,parsedPath.nodeName)||this.rootNode;\n\nthis.node=targetObject;\n\n}\n\n// set fail state so we can just 'return' on error\nthis.getValue=this._getValue_unavailable;\nthis.setValue=this._setValue_unavailable;\n\n// ensure there is a value node\nif(!targetObject){\n\nconsole.error(\"  trying to update node for track: \"+this.path+\" but it wasn't found.\");\nreturn;\n\n}\n\nif(objectName){\n\nvar objectIndex=parsedPath.objectIndex;\n\n// special cases were we need to reach deeper into the hierarchy to get the face materials....\nswitch(objectName){\n\ncase'materials':\n\nif(!targetObject.material){\n\nconsole.error('  can not bind to material as node does not have a material',this);\nreturn;\n\n}\n\nif(!targetObject.material.materials){\n\nconsole.error('  can not bind to material.materials as node.material does not have a materials array',this);\nreturn;\n\n}\n\ntargetObject=targetObject.material.materials;\n\nbreak;\n\ncase'bones':\n\nif(!targetObject.skeleton){\n\nconsole.error('  can not bind to bones as node does not have a skeleton',this);\nreturn;\n\n}\n\n// potential future optimization: skip this if propertyIndex is already an integer\n// and convert the integer string to a true integer.\n\ntargetObject=targetObject.skeleton.bones;\n\n// support resolving morphTarget names into indices.\nfor(var i=0;i<targetObject.length;i++){\n\nif(targetObject[i].name===objectIndex){\n\nobjectIndex=i;\nbreak;\n\n}\n\n}\n\nbreak;\n\ndefault:\n\nif(targetObject[objectName]===undefined){\n\nconsole.error('  can not bind to objectName of node, undefined',this);\nreturn;\n\n}\n\ntargetObject=targetObject[objectName];}\n\n\n\n\nif(objectIndex!==undefined){\n\nif(targetObject[objectIndex]===undefined){\n\nconsole.error(\"  trying to bind to objectIndex of objectName, but is undefined:\",this,targetObject);\nreturn;\n\n}\n\ntargetObject=targetObject[objectIndex];\n\n}\n\n}\n\n// resolve property\nvar nodeProperty=targetObject[propertyName];\n\nif(nodeProperty===undefined){\n\nvar nodeName=parsedPath.nodeName;\n\nconsole.error(\"  trying to update property for track: \"+nodeName+\n'.'+propertyName+\" but it wasn't found.\",targetObject);\nreturn;\n\n}\n\n// determine versioning scheme\nvar versioning=this.Versioning.None;\n\nif(targetObject.needsUpdate!==undefined){// material\n\nversioning=this.Versioning.NeedsUpdate;\nthis.targetObject=targetObject;\n\n}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform\n\nversioning=this.Versioning.MatrixWorldNeedsUpdate;\nthis.targetObject=targetObject;\n\n}\n\n// determine how the property gets bound\nvar bindingType=this.BindingType.Direct;\n\nif(propertyIndex!==undefined){\n// access a sub element of the property array (only primitives are supported right now)\n\nif(propertyName===\"morphTargetInfluences\"){\n// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n// support resolving morphTarget names into indices.\nif(!targetObject.geometry){\n\nconsole.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry',this);\nreturn;\n\n}\n\nif(!targetObject.geometry.morphTargets){\n\nconsole.error('  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets',this);\nreturn;\n\n}\n\nfor(var i=0;i<this.node.geometry.morphTargets.length;i++){\n\nif(targetObject.geometry.morphTargets[i].name===propertyIndex){\n\npropertyIndex=i;\nbreak;\n\n}\n\n}\n\n}\n\nbindingType=this.BindingType.ArrayElement;\n\nthis.resolvedProperty=nodeProperty;\nthis.propertyIndex=propertyIndex;\n\n}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){\n// must use copy for Object3D.Euler/Quaternion\n\nbindingType=this.BindingType.HasFromToArray;\n\nthis.resolvedProperty=nodeProperty;\n\n}else if(nodeProperty.length!==undefined){\n\nbindingType=this.BindingType.EntireArray;\n\nthis.resolvedProperty=nodeProperty;\n\n}else{\n\nthis.propertyName=propertyName;\n\n}\n\n// select getter / setter\nthis.getValue=this.GetterByBindingType[bindingType];\nthis.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n\n},\n\nunbind:function unbind(){\n\nthis.node=null;\n\n// back to the prototype version of getValue / setValue\n// note: avoiding to mutate the shape of 'this' via 'delete'\nthis.getValue=this._getValue_unbound;\nthis.setValue=this._setValue_unbound;\n\n}};\n\n\n\nObject.assign(PropertyBinding.prototype,{// prototype, continued\n\n// these are used to \"bind\" a nonexistent property\n_getValue_unavailable:function _getValue_unavailable(){},\n_setValue_unavailable:function _setValue_unavailable(){},\n\n// initial state of these methods that calls 'bind'\n_getValue_unbound:PropertyBinding.prototype.getValue,\n_setValue_unbound:PropertyBinding.prototype.setValue,\n\nBindingType:{\nDirect:0,\nEntireArray:1,\nArrayElement:2,\nHasFromToArray:3},\n\n\nVersioning:{\nNone:0,\nNeedsUpdate:1,\nMatrixWorldNeedsUpdate:2},\n\n\nGetterByBindingType:[\n\nfunction getValue_direct(buffer,offset){\n\nbuffer[offset]=this.node[this.propertyName];\n\n},\n\nfunction getValue_array(buffer,offset){\n\nvar source=this.resolvedProperty;\n\nfor(var i=0,n=source.length;i!==n;++i){\n\nbuffer[offset++]=source[i];\n\n}\n\n},\n\nfunction getValue_arrayElement(buffer,offset){\n\nbuffer[offset]=this.resolvedProperty[this.propertyIndex];\n\n},\n\nfunction getValue_toArray(buffer,offset){\n\nthis.resolvedProperty.toArray(buffer,offset);\n\n}],\n\n\n\nSetterByBindingTypeAndVersioning:[\n\n[\n// Direct\n\nfunction setValue_direct(buffer,offset){\n\nthis.node[this.propertyName]=buffer[offset];\n\n},\n\nfunction setValue_direct_setNeedsUpdate(buffer,offset){\n\nthis.node[this.propertyName]=buffer[offset];\nthis.targetObject.needsUpdate=true;\n\n},\n\nfunction setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){\n\nthis.node[this.propertyName]=buffer[offset];\nthis.targetObject.matrixWorldNeedsUpdate=true;\n\n}],\n\n[\n\n// EntireArray\n\nfunction setValue_array(buffer,offset){\n\nvar dest=this.resolvedProperty;\n\nfor(var i=0,n=dest.length;i!==n;++i){\n\ndest[i]=buffer[offset++];\n\n}\n\n},\n\nfunction setValue_array_setNeedsUpdate(buffer,offset){\n\nvar dest=this.resolvedProperty;\n\nfor(var i=0,n=dest.length;i!==n;++i){\n\ndest[i]=buffer[offset++];\n\n}\n\nthis.targetObject.needsUpdate=true;\n\n},\n\nfunction setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){\n\nvar dest=this.resolvedProperty;\n\nfor(var i=0,n=dest.length;i!==n;++i){\n\ndest[i]=buffer[offset++];\n\n}\n\nthis.targetObject.matrixWorldNeedsUpdate=true;\n\n}],\n\n[\n\n// ArrayElement\n\nfunction setValue_arrayElement(buffer,offset){\n\nthis.resolvedProperty[this.propertyIndex]=buffer[offset];\n\n},\n\nfunction setValue_arrayElement_setNeedsUpdate(buffer,offset){\n\nthis.resolvedProperty[this.propertyIndex]=buffer[offset];\nthis.targetObject.needsUpdate=true;\n\n},\n\nfunction setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){\n\nthis.resolvedProperty[this.propertyIndex]=buffer[offset];\nthis.targetObject.matrixWorldNeedsUpdate=true;\n\n}],\n\n[\n\n// HasToFromArray\n\nfunction setValue_fromArray(buffer,offset){\n\nthis.resolvedProperty.fromArray(buffer,offset);\n\n},\n\nfunction setValue_fromArray_setNeedsUpdate(buffer,offset){\n\nthis.resolvedProperty.fromArray(buffer,offset);\nthis.targetObject.needsUpdate=true;\n\n},\n\nfunction setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){\n\nthis.resolvedProperty.fromArray(buffer,offset);\nthis.targetObject.matrixWorldNeedsUpdate=true;\n\n}]]});\n\n\n\n\n\n\n\nPropertyBinding.Composite=\nfunction(targetGroup,path,optionalParsedPath){\n\nvar parsedPath=optionalParsedPath||\nPropertyBinding.parseTrackName(path);\n\nthis._targetGroup=targetGroup;\nthis._bindings=targetGroup.subscribe_(path,parsedPath);\n\n};\n\nPropertyBinding.Composite.prototype={\n\nconstructor:PropertyBinding.Composite,\n\ngetValue:function getValue(array,offset){\n\nthis.bind();// bind all binding\n\nvar firstValidIndex=this._targetGroup.nCachedObjects_,\nbinding=this._bindings[firstValidIndex];\n\n// and only call .getValue on the first\nif(binding!==undefined)binding.getValue(array,offset);\n\n},\n\nsetValue:function setValue(array,offset){\n\nvar bindings=this._bindings;\n\nfor(var i=this._targetGroup.nCachedObjects_,\nn=bindings.length;i!==n;++i){\n\nbindings[i].setValue(array,offset);\n\n}\n\n},\n\nbind:function bind(){\n\nvar bindings=this._bindings;\n\nfor(var i=this._targetGroup.nCachedObjects_,\nn=bindings.length;i!==n;++i){\n\nbindings[i].bind();\n\n}\n\n},\n\nunbind:function unbind(){\n\nvar bindings=this._bindings;\n\nfor(var i=this._targetGroup.nCachedObjects_,\nn=bindings.length;i!==n;++i){\n\nbindings[i].unbind();\n\n}\n\n}};\n\n\n\nPropertyBinding.create=function(root,path,parsedPath){\n\nif(!(root&&root.isAnimationObjectGroup)){\n\nreturn new PropertyBinding(root,path,parsedPath);\n\n}else{\n\nreturn new PropertyBinding.Composite(root,path,parsedPath);\n\n}\n\n};\n\nPropertyBinding.parseTrackName=function(trackName){\n\n// matches strings in the form of:\n//    nodeName.property\n//    nodeName.property[accessor]\n//    nodeName.material.property[accessor]\n//    uuid.property[accessor]\n//    uuid.objectName[objectIndex].propertyName[propertyIndex]\n//    parentName/nodeName.property\n//    parentName/parentName/nodeName.property[index]\n//    .bone[Armature.DEF_cog].position\n//    scene:helium_balloon_model:helium_balloon_model.position\n// created and tested via https://regex101.com/#javascript\n\nvar re=/^((?:[\\w-]+[\\/:])*)([\\w-]+)?(?:\\.([\\w-]+)(?:\\[(.+)\\])?)?\\.([\\w-]+)(?:\\[(.+)\\])?$/;\nvar matches=re.exec(trackName);\n\nif(!matches){\n\nthrow new Error(\"cannot parse trackName at all: \"+trackName);\n\n}\n\nvar results={\n// directoryName: matches[ 1 ], // (tschw) currently unused\nnodeName:matches[2],// allowed to be null, specified root node.\nobjectName:matches[3],\nobjectIndex:matches[4],\npropertyName:matches[5],\npropertyIndex:matches[6]// allowed to be null, specifies that the whole property is set.\n};\n\nif(results.propertyName===null||results.propertyName.length===0){\n\nthrow new Error(\"can not parse propertyName from trackName: \"+trackName);\n\n}\n\nreturn results;\n\n};\n\nPropertyBinding.findNode=function(root,nodeName){\n\nif(!nodeName||nodeName===\"\"||nodeName===\"root\"||nodeName===\".\"||nodeName===-1||nodeName===root.name||nodeName===root.uuid){\n\nreturn root;\n\n}\n\n// search into skeleton bones.\nif(root.skeleton){\n\nvar searchSkeleton=function searchSkeleton(skeleton){\n\nfor(var i=0;i<skeleton.bones.length;i++){\n\nvar bone=skeleton.bones[i];\n\nif(bone.name===nodeName){\n\nreturn bone;\n\n}\n}\n\nreturn null;\n\n};\n\nvar bone=searchSkeleton(root.skeleton);\n\nif(bone){\n\nreturn bone;\n\n}\n}\n\n// search into node subtree.\nif(root.children){\n\nvar searchNodeSubtree=function searchNodeSubtree(children){\n\nfor(var i=0;i<children.length;i++){\n\nvar childNode=children[i];\n\nif(childNode.name===nodeName||childNode.uuid===nodeName){\n\nreturn childNode;\n\n}\n\nvar result=searchNodeSubtree(childNode.children);\n\nif(result)return result;\n\n}\n\nreturn null;\n\n};\n\nvar subTreeNode=searchNodeSubtree(root.children);\n\nif(subTreeNode){\n\nreturn subTreeNode;\n\n}\n\n}\n\nreturn null;\n\n};\n\n/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t * \t-\tInstead pass this object as 'root'.\n\t *\n\t * \t-\tYou can also add and remove objects later when the mixer\n\t * \t\tis running.\n\t *\n\t * Note:\n\t *\n\t *  \tObjects of this class appear as one object to the mixer,\n\t *  \tso cache control of the individual objects must be done\n\t *  \ton the group.\n\t *\n\t * Limitation:\n\t *\n\t * \t- \tThe animated properties must be compatible among the\n\t * \t\tall objects in the group.\n\t *\n\t *  -\tA single property can either be controlled through a\n\t *  \ttarget group or directly, but not both.\n\t *\n\t * @author tschw\n\t */\n\nfunction AnimationObjectGroup(var_args){\n\nthis.uuid=_Math.generateUUID();\n\n// cached objects followed by the active ones\nthis._objects=Array.prototype.slice.call(arguments);\n\nthis.nCachedObjects_=0;// threshold\n// note: read by PropertyBinding.Composite\n\nvar indices={};\nthis._indicesByUUID=indices;// for bookkeeping\n\nfor(var i=0,n=arguments.length;i!==n;++i){\n\nindices[arguments[i].uuid]=i;\n\n}\n\nthis._paths=[];// inside: string\nthis._parsedPaths=[];// inside: { we don't care, here }\nthis._bindings=[];// inside: Array< PropertyBinding >\nthis._bindingsIndicesByPath={};// inside: indices in these arrays\n\nvar scope=this;\n\nthis.stats={\n\nobjects:{\nget total(){return scope._objects.length;},\nget inUse(){return this.total-scope.nCachedObjects_;}},\n\n\nget bindingsPerObject(){return scope._bindings.length;}};\n\n\n\n}\n\nAnimationObjectGroup.prototype={\n\nconstructor:AnimationObjectGroup,\n\nisAnimationObjectGroup:true,\n\nadd:function add(var_args){\n\nvar objects=this._objects,\nnObjects=objects.length,\nnCachedObjects=this.nCachedObjects_,\nindicesByUUID=this._indicesByUUID,\npaths=this._paths,\nparsedPaths=this._parsedPaths,\nbindings=this._bindings,\nnBindings=bindings.length;\n\nfor(var i=0,n=arguments.length;i!==n;++i){\n\nvar object=arguments[i],\nuuid=object.uuid,\nindex=indicesByUUID[uuid],\nknownObject=undefined;\n\nif(index===undefined){\n\n// unknown object -> add it to the ACTIVE region\n\nindex=nObjects++;\nindicesByUUID[uuid]=index;\nobjects.push(object);\n\n// accounting is done, now do the same for all bindings\n\nfor(var j=0,m=nBindings;j!==m;++j){\n\nbindings[j].push(\nnew PropertyBinding(\nobject,paths[j],parsedPaths[j]));\n\n}\n\n}else if(index<nCachedObjects){\n\nknownObject=objects[index];\n\n// move existing object to the ACTIVE region\n\nvar firstActiveIndex=--nCachedObjects,\nlastCachedObject=objects[firstActiveIndex];\n\nindicesByUUID[lastCachedObject.uuid]=index;\nobjects[index]=lastCachedObject;\n\nindicesByUUID[uuid]=firstActiveIndex;\nobjects[firstActiveIndex]=object;\n\n// accounting is done, now do the same for all bindings\n\nfor(var j=0,m=nBindings;j!==m;++j){\n\nvar bindingsForPath=bindings[j],\nlastCached=bindingsForPath[firstActiveIndex],\nbinding=bindingsForPath[index];\n\nbindingsForPath[index]=lastCached;\n\nif(binding===undefined){\n\n// since we do not bother to create new bindings\n// for objects that are cached, the binding may\n// or may not exist\n\nbinding=new PropertyBinding(\nobject,paths[j],parsedPaths[j]);\n\n}\n\nbindingsForPath[firstActiveIndex]=binding;\n\n}\n\n}else if(objects[index]!==knownObject){\n\nconsole.error(\"Different objects with the same UUID \"+\n\"detected. Clean the caches or recreate your \"+\n\"infrastructure when reloading scenes...\");\n\n}// else the object is already where we want it to be\n\n}// for arguments\n\nthis.nCachedObjects_=nCachedObjects;\n\n},\n\nremove:function remove(var_args){\n\nvar objects=this._objects,\nnCachedObjects=this.nCachedObjects_,\nindicesByUUID=this._indicesByUUID,\nbindings=this._bindings,\nnBindings=bindings.length;\n\nfor(var i=0,n=arguments.length;i!==n;++i){\n\nvar object=arguments[i],\nuuid=object.uuid,\nindex=indicesByUUID[uuid];\n\nif(index!==undefined&&index>=nCachedObjects){\n\n// move existing object into the CACHED region\n\nvar lastCachedIndex=nCachedObjects++,\nfirstActiveObject=objects[lastCachedIndex];\n\nindicesByUUID[firstActiveObject.uuid]=index;\nobjects[index]=firstActiveObject;\n\nindicesByUUID[uuid]=lastCachedIndex;\nobjects[lastCachedIndex]=object;\n\n// accounting is done, now do the same for all bindings\n\nfor(var j=0,m=nBindings;j!==m;++j){\n\nvar bindingsForPath=bindings[j],\nfirstActive=bindingsForPath[lastCachedIndex],\nbinding=bindingsForPath[index];\n\nbindingsForPath[index]=firstActive;\nbindingsForPath[lastCachedIndex]=binding;\n\n}\n\n}\n\n}// for arguments\n\nthis.nCachedObjects_=nCachedObjects;\n\n},\n\n// remove & forget\nuncache:function uncache(var_args){\n\nvar objects=this._objects,\nnObjects=objects.length,\nnCachedObjects=this.nCachedObjects_,\nindicesByUUID=this._indicesByUUID,\nbindings=this._bindings,\nnBindings=bindings.length;\n\nfor(var i=0,n=arguments.length;i!==n;++i){\n\nvar object=arguments[i],\nuuid=object.uuid,\nindex=indicesByUUID[uuid];\n\nif(index!==undefined){\n\ndelete indicesByUUID[uuid];\n\nif(index<nCachedObjects){\n\n// object is cached, shrink the CACHED region\n\nvar firstActiveIndex=--nCachedObjects,\nlastCachedObject=objects[firstActiveIndex],\nlastIndex=--nObjects,\nlastObject=objects[lastIndex];\n\n// last cached object takes this object's place\nindicesByUUID[lastCachedObject.uuid]=index;\nobjects[index]=lastCachedObject;\n\n// last object goes to the activated slot and pop\nindicesByUUID[lastObject.uuid]=firstActiveIndex;\nobjects[firstActiveIndex]=lastObject;\nobjects.pop();\n\n// accounting is done, now do the same for all bindings\n\nfor(var j=0,m=nBindings;j!==m;++j){\n\nvar bindingsForPath=bindings[j],\nlastCached=bindingsForPath[firstActiveIndex],\nlast=bindingsForPath[lastIndex];\n\nbindingsForPath[index]=lastCached;\nbindingsForPath[firstActiveIndex]=last;\nbindingsForPath.pop();\n\n}\n\n}else{\n\n// object is active, just swap with the last and pop\n\nvar lastIndex=--nObjects,\nlastObject=objects[lastIndex];\n\nindicesByUUID[lastObject.uuid]=index;\nobjects[index]=lastObject;\nobjects.pop();\n\n// accounting is done, now do the same for all bindings\n\nfor(var j=0,m=nBindings;j!==m;++j){\n\nvar bindingsForPath=bindings[j];\n\nbindingsForPath[index]=bindingsForPath[lastIndex];\nbindingsForPath.pop();\n\n}\n\n}// cached or active\n\n}// if object is known\n\n}// for arguments\n\nthis.nCachedObjects_=nCachedObjects;\n\n},\n\n// Internal interface used by befriended PropertyBinding.Composite:\n\nsubscribe_:function subscribe_(path,parsedPath){\n// returns an array of bindings for the given path that is changed\n// according to the contained objects in the group\n\nvar indicesByPath=this._bindingsIndicesByPath,\nindex=indicesByPath[path],\nbindings=this._bindings;\n\nif(index!==undefined)return bindings[index];\n\nvar paths=this._paths,\nparsedPaths=this._parsedPaths,\nobjects=this._objects,\nnObjects=objects.length,\nnCachedObjects=this.nCachedObjects_,\nbindingsForPath=new Array(nObjects);\n\nindex=bindings.length;\n\nindicesByPath[path]=index;\n\npaths.push(path);\nparsedPaths.push(parsedPath);\nbindings.push(bindingsForPath);\n\nfor(var i=nCachedObjects,\nn=objects.length;i!==n;++i){\n\nvar object=objects[i];\n\nbindingsForPath[i]=\nnew PropertyBinding(object,path,parsedPath);\n\n}\n\nreturn bindingsForPath;\n\n},\n\nunsubscribe_:function unsubscribe_(path){\n// tells the group to forget about a property path and no longer\n// update the array previously obtained with 'subscribe_'\n\nvar indicesByPath=this._bindingsIndicesByPath,\nindex=indicesByPath[path];\n\nif(index!==undefined){\n\nvar paths=this._paths,\nparsedPaths=this._parsedPaths,\nbindings=this._bindings,\nlastBindingsIndex=bindings.length-1,\nlastBindings=bindings[lastBindingsIndex],\nlastBindingsPath=path[lastBindingsIndex];\n\nindicesByPath[lastBindingsPath]=index;\n\nbindings[index]=lastBindings;\nbindings.pop();\n\nparsedPaths[index]=parsedPaths[lastBindingsIndex];\nparsedPaths.pop();\n\npaths[index]=paths[lastBindingsIndex];\npaths.pop();\n\n}\n\n}};\n\n\n\n/**\n\t *\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\n\t * objects.\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t *\n\t */\n\nfunction AnimationAction(mixer,clip,localRoot){\n\nthis._mixer=mixer;\nthis._clip=clip;\nthis._localRoot=localRoot||null;\n\nvar tracks=clip.tracks,\nnTracks=tracks.length,\ninterpolants=new Array(nTracks);\n\nvar interpolantSettings={\nendingStart:ZeroCurvatureEnding,\nendingEnd:ZeroCurvatureEnding};\n\n\nfor(var i=0;i!==nTracks;++i){\n\nvar interpolant=tracks[i].createInterpolant(null);\ninterpolants[i]=interpolant;\ninterpolant.settings=interpolantSettings;\n\n}\n\nthis._interpolantSettings=interpolantSettings;\n\nthis._interpolants=interpolants;// bound by the mixer\n\n// inside: PropertyMixer (managed by the mixer)\nthis._propertyBindings=new Array(nTracks);\n\nthis._cacheIndex=null;// for the memory manager\nthis._byClipCacheIndex=null;// for the memory manager\n\nthis._timeScaleInterpolant=null;\nthis._weightInterpolant=null;\n\nthis.loop=LoopRepeat;\nthis._loopCount=-1;\n\n// global mixer time when the action is to be started\n// it's set back to 'null' upon start of the action\nthis._startTime=null;\n\n// scaled local time of the action\n// gets clamped or wrapped to 0..clip.duration according to loop\nthis.time=0;\n\nthis.timeScale=1;\nthis._effectiveTimeScale=1;\n\nthis.weight=1;\nthis._effectiveWeight=1;\n\nthis.repetitions=Infinity;// no. of repetitions when looping\n\nthis.paused=false;// false -> zero effective time scale\nthis.enabled=true;// true -> zero effective weight\n\nthis.clampWhenFinished=false;// keep feeding the last frame?\n\nthis.zeroSlopeAtStart=true;// for smooth interpolation w/o separate\nthis.zeroSlopeAtEnd=true;// clips for start, loop and end\n\n}\n\nAnimationAction.prototype={\n\nconstructor:AnimationAction,\n\n// State & Scheduling\n\nplay:function play(){\n\nthis._mixer._activateAction(this);\n\nreturn this;\n\n},\n\nstop:function stop(){\n\nthis._mixer._deactivateAction(this);\n\nreturn this.reset();\n\n},\n\nreset:function reset(){\n\nthis.paused=false;\nthis.enabled=true;\n\nthis.time=0;// restart clip\nthis._loopCount=-1;// forget previous loops\nthis._startTime=null;// forget scheduling\n\nreturn this.stopFading().stopWarping();\n\n},\n\nisRunning:function isRunning(){\n\nreturn this.enabled&&!this.paused&&this.timeScale!==0&&\nthis._startTime===null&&this._mixer._isActiveAction(this);\n\n},\n\n// return true when play has been called\nisScheduled:function isScheduled(){\n\nreturn this._mixer._isActiveAction(this);\n\n},\n\nstartAt:function startAt(time){\n\nthis._startTime=time;\n\nreturn this;\n\n},\n\nsetLoop:function setLoop(mode,repetitions){\n\nthis.loop=mode;\nthis.repetitions=repetitions;\n\nreturn this;\n\n},\n\n// Weight\n\n// set the weight stopping any scheduled fading\n// although .enabled = false yields an effective weight of zero, this\n// method does *not* change .enabled, because it would be confusing\nsetEffectiveWeight:function setEffectiveWeight(weight){\n\nthis.weight=weight;\n\n// note: same logic as when updated at runtime\nthis._effectiveWeight=this.enabled?weight:0;\n\nreturn this.stopFading();\n\n},\n\n// return the weight considering fading and .enabled\ngetEffectiveWeight:function getEffectiveWeight(){\n\nreturn this._effectiveWeight;\n\n},\n\nfadeIn:function fadeIn(duration){\n\nreturn this._scheduleFading(duration,0,1);\n\n},\n\nfadeOut:function fadeOut(duration){\n\nreturn this._scheduleFading(duration,1,0);\n\n},\n\ncrossFadeFrom:function crossFadeFrom(fadeOutAction,duration,warp){\n\nfadeOutAction.fadeOut(duration);\nthis.fadeIn(duration);\n\nif(warp){\n\nvar fadeInDuration=this._clip.duration,\nfadeOutDuration=fadeOutAction._clip.duration,\n\nstartEndRatio=fadeOutDuration/fadeInDuration,\nendStartRatio=fadeInDuration/fadeOutDuration;\n\nfadeOutAction.warp(1.0,startEndRatio,duration);\nthis.warp(endStartRatio,1.0,duration);\n\n}\n\nreturn this;\n\n},\n\ncrossFadeTo:function crossFadeTo(fadeInAction,duration,warp){\n\nreturn fadeInAction.crossFadeFrom(this,duration,warp);\n\n},\n\nstopFading:function stopFading(){\n\nvar weightInterpolant=this._weightInterpolant;\n\nif(weightInterpolant!==null){\n\nthis._weightInterpolant=null;\nthis._mixer._takeBackControlInterpolant(weightInterpolant);\n\n}\n\nreturn this;\n\n},\n\n// Time Scale Control\n\n// set the weight stopping any scheduled warping\n// although .paused = true yields an effective time scale of zero, this\n// method does *not* change .paused, because it would be confusing\nsetEffectiveTimeScale:function setEffectiveTimeScale(timeScale){\n\nthis.timeScale=timeScale;\nthis._effectiveTimeScale=this.paused?0:timeScale;\n\nreturn this.stopWarping();\n\n},\n\n// return the time scale considering warping and .paused\ngetEffectiveTimeScale:function getEffectiveTimeScale(){\n\nreturn this._effectiveTimeScale;\n\n},\n\nsetDuration:function setDuration(duration){\n\nthis.timeScale=this._clip.duration/duration;\n\nreturn this.stopWarping();\n\n},\n\nsyncWith:function syncWith(action){\n\nthis.time=action.time;\nthis.timeScale=action.timeScale;\n\nreturn this.stopWarping();\n\n},\n\nhalt:function halt(duration){\n\nreturn this.warp(this._effectiveTimeScale,0,duration);\n\n},\n\nwarp:function warp(startTimeScale,endTimeScale,duration){\n\nvar mixer=this._mixer,now=mixer.time,\ninterpolant=this._timeScaleInterpolant,\n\ntimeScale=this.timeScale;\n\nif(interpolant===null){\n\ninterpolant=mixer._lendControlInterpolant();\nthis._timeScaleInterpolant=interpolant;\n\n}\n\nvar times=interpolant.parameterPositions,\nvalues=interpolant.sampleValues;\n\ntimes[0]=now;\ntimes[1]=now+duration;\n\nvalues[0]=startTimeScale/timeScale;\nvalues[1]=endTimeScale/timeScale;\n\nreturn this;\n\n},\n\nstopWarping:function stopWarping(){\n\nvar timeScaleInterpolant=this._timeScaleInterpolant;\n\nif(timeScaleInterpolant!==null){\n\nthis._timeScaleInterpolant=null;\nthis._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n\n}\n\nreturn this;\n\n},\n\n// Object Accessors\n\ngetMixer:function getMixer(){\n\nreturn this._mixer;\n\n},\n\ngetClip:function getClip(){\n\nreturn this._clip;\n\n},\n\ngetRoot:function getRoot(){\n\nreturn this._localRoot||this._mixer._root;\n\n},\n\n// Interna\n\n_update:function _update(time,deltaTime,timeDirection,accuIndex){\n// called by the mixer\n\nvar startTime=this._startTime;\n\nif(startTime!==null){\n\n// check for scheduled start of action\n\nvar timeRunning=(time-startTime)*timeDirection;\nif(timeRunning<0||timeDirection===0){\n\nreturn;// yet to come / don't decide when delta = 0\n\n}\n\n// start\n\nthis._startTime=null;// unschedule\ndeltaTime=timeDirection*timeRunning;\n\n}\n\n// apply time scale and advance time\n\ndeltaTime*=this._updateTimeScale(time);\nvar clipTime=this._updateTime(deltaTime);\n\n// note: _updateTime may disable the action resulting in\n// an effective weight of 0\n\nvar weight=this._updateWeight(time);\n\nif(weight>0){\n\nvar interpolants=this._interpolants;\nvar propertyMixers=this._propertyBindings;\n\nfor(var j=0,m=interpolants.length;j!==m;++j){\n\ninterpolants[j].evaluate(clipTime);\npropertyMixers[j].accumulate(accuIndex,weight);\n\n}\n\n}\n\n},\n\n_updateWeight:function _updateWeight(time){\n\nvar weight=0;\n\nif(this.enabled){\n\nweight=this.weight;\nvar interpolant=this._weightInterpolant;\n\nif(interpolant!==null){\n\nvar interpolantValue=interpolant.evaluate(time)[0];\n\nweight*=interpolantValue;\n\nif(time>interpolant.parameterPositions[1]){\n\nthis.stopFading();\n\nif(interpolantValue===0){\n\n// faded out, disable\nthis.enabled=false;\n\n}\n\n}\n\n}\n\n}\n\nthis._effectiveWeight=weight;\nreturn weight;\n\n},\n\n_updateTimeScale:function _updateTimeScale(time){\n\nvar timeScale=0;\n\nif(!this.paused){\n\ntimeScale=this.timeScale;\n\nvar interpolant=this._timeScaleInterpolant;\n\nif(interpolant!==null){\n\nvar interpolantValue=interpolant.evaluate(time)[0];\n\ntimeScale*=interpolantValue;\n\nif(time>interpolant.parameterPositions[1]){\n\nthis.stopWarping();\n\nif(timeScale===0){\n\n// motion has halted, pause\nthis.paused=true;\n\n}else{\n\n// warp done - apply final time scale\nthis.timeScale=timeScale;\n\n}\n\n}\n\n}\n\n}\n\nthis._effectiveTimeScale=timeScale;\nreturn timeScale;\n\n},\n\n_updateTime:function _updateTime(deltaTime){\n\nvar time=this.time+deltaTime;\n\nif(deltaTime===0)return time;\n\nvar duration=this._clip.duration,\n\nloop=this.loop,\nloopCount=this._loopCount;\n\nif(loop===LoopOnce){\n\nif(loopCount===-1){\n// just started\n\nthis._loopCount=0;\nthis._setEndings(true,true,false);\n\n}\n\nhandle_stop:{\n\nif(time>=duration){\n\ntime=duration;\n\n}else if(time<0){\n\ntime=0;\n\n}else break handle_stop;\n\nif(this.clampWhenFinished)this.paused=true;else\nthis.enabled=false;\n\nthis._mixer.dispatchEvent({\ntype:'finished',action:this,\ndirection:deltaTime<0?-1:1});\n\n\n}\n\n}else{// repetitive Repeat or PingPong\n\nvar pingPong=loop===LoopPingPong;\n\nif(loopCount===-1){\n// just started\n\nif(deltaTime>=0){\n\nloopCount=0;\n\nthis._setEndings(\ntrue,this.repetitions===0,pingPong);\n\n}else{\n\n// when looping in reverse direction, the initial\n// transition through zero counts as a repetition,\n// so leave loopCount at -1\n\nthis._setEndings(\nthis.repetitions===0,true,pingPong);\n\n}\n\n}\n\nif(time>=duration||time<0){\n// wrap around\n\nvar loopDelta=Math.floor(time/duration);// signed\ntime-=duration*loopDelta;\n\nloopCount+=Math.abs(loopDelta);\n\nvar pending=this.repetitions-loopCount;\n\nif(pending<0){\n// have to stop (switch state, clamp time, fire event)\n\nif(this.clampWhenFinished)this.paused=true;else\nthis.enabled=false;\n\ntime=deltaTime>0?duration:0;\n\nthis._mixer.dispatchEvent({\ntype:'finished',action:this,\ndirection:deltaTime>0?1:-1});\n\n\n}else{\n// keep running\n\nif(pending===0){\n// entering the last round\n\nvar atStart=deltaTime<0;\nthis._setEndings(atStart,!atStart,pingPong);\n\n}else{\n\nthis._setEndings(false,false,pingPong);\n\n}\n\nthis._loopCount=loopCount;\n\nthis._mixer.dispatchEvent({\ntype:'loop',action:this,loopDelta:loopDelta});\n\n\n}\n\n}\n\nif(pingPong&&(loopCount&1)===1){\n// invert time for the \"pong round\"\n\nthis.time=time;\nreturn duration-time;\n\n}\n\n}\n\nthis.time=time;\nreturn time;\n\n},\n\n_setEndings:function _setEndings(atStart,atEnd,pingPong){\n\nvar settings=this._interpolantSettings;\n\nif(pingPong){\n\nsettings.endingStart=ZeroSlopeEnding;\nsettings.endingEnd=ZeroSlopeEnding;\n\n}else{\n\n// assuming for LoopOnce atStart == atEnd == true\n\nif(atStart){\n\nsettings.endingStart=this.zeroSlopeAtStart?\nZeroSlopeEnding:ZeroCurvatureEnding;\n\n}else{\n\nsettings.endingStart=WrapAroundEnding;\n\n}\n\nif(atEnd){\n\nsettings.endingEnd=this.zeroSlopeAtEnd?\nZeroSlopeEnding:ZeroCurvatureEnding;\n\n}else{\n\nsettings.endingEnd=WrapAroundEnding;\n\n}\n\n}\n\n},\n\n_scheduleFading:function _scheduleFading(duration,weightNow,weightThen){\n\nvar mixer=this._mixer,now=mixer.time,\ninterpolant=this._weightInterpolant;\n\nif(interpolant===null){\n\ninterpolant=mixer._lendControlInterpolant();\nthis._weightInterpolant=interpolant;\n\n}\n\nvar times=interpolant.parameterPositions,\nvalues=interpolant.sampleValues;\n\ntimes[0]=now;values[0]=weightNow;\ntimes[1]=now+duration;values[1]=weightThen;\n\nreturn this;\n\n}};\n\n\n\n/**\n\t *\n\t * Player for AnimationClips.\n\t *\n\t *\n\t * @author Ben Houston / http://clara.io/\n\t * @author David Sarno / http://lighthaus.us/\n\t * @author tschw\n\t */\n\nfunction AnimationMixer(root){\n\nthis._root=root;\nthis._initMemoryManager();\nthis._accuIndex=0;\n\nthis.time=0;\n\nthis.timeScale=1.0;\n\n}\n\nAnimationMixer.prototype={\n\nconstructor:AnimationMixer,\n\n// return an action for a clip optionally using a custom root target\n// object (this method allocates a lot of dynamic memory in case a\n// previously unknown clip/root combination is specified)\nclipAction:function clipAction(clip,optionalRoot){\n\nvar root=optionalRoot||this._root,\nrootUuid=root.uuid,\n\nclipObject=typeof clip==='string'?\nAnimationClip.findByName(root,clip):clip,\n\nclipUuid=clipObject!==null?clipObject.uuid:clip,\n\nactionsForClip=this._actionsByClip[clipUuid],\nprototypeAction=null;\n\nif(actionsForClip!==undefined){\n\nvar existingAction=\nactionsForClip.actionByRoot[rootUuid];\n\nif(existingAction!==undefined){\n\nreturn existingAction;\n\n}\n\n// we know the clip, so we don't have to parse all\n// the bindings again but can just copy\nprototypeAction=actionsForClip.knownActions[0];\n\n// also, take the clip from the prototype action\nif(clipObject===null)\nclipObject=prototypeAction._clip;\n\n}\n\n// clip must be known when specified via string\nif(clipObject===null)return null;\n\n// allocate all resources required to run it\nvar newAction=new AnimationAction(this,clipObject,optionalRoot);\n\nthis._bindAction(newAction,prototypeAction);\n\n// and make the action known to the memory manager\nthis._addInactiveAction(newAction,clipUuid,rootUuid);\n\nreturn newAction;\n\n},\n\n// get an existing action\nexistingAction:function existingAction(clip,optionalRoot){\n\nvar root=optionalRoot||this._root,\nrootUuid=root.uuid,\n\nclipObject=typeof clip==='string'?\nAnimationClip.findByName(root,clip):clip,\n\nclipUuid=clipObject?clipObject.uuid:clip,\n\nactionsForClip=this._actionsByClip[clipUuid];\n\nif(actionsForClip!==undefined){\n\nreturn actionsForClip.actionByRoot[rootUuid]||null;\n\n}\n\nreturn null;\n\n},\n\n// deactivates all previously scheduled actions\nstopAllAction:function stopAllAction(){\n\nvar actions=this._actions,\nnActions=this._nActiveActions,\nbindings=this._bindings,\nnBindings=this._nActiveBindings;\n\nthis._nActiveActions=0;\nthis._nActiveBindings=0;\n\nfor(var i=0;i!==nActions;++i){\n\nactions[i].reset();\n\n}\n\nfor(var i=0;i!==nBindings;++i){\n\nbindings[i].useCount=0;\n\n}\n\nreturn this;\n\n},\n\n// advance the time and update apply the animation\nupdate:function update(deltaTime){\n\ndeltaTime*=this.timeScale;\n\nvar actions=this._actions,\nnActions=this._nActiveActions,\n\ntime=this.time+=deltaTime,\ntimeDirection=Math.sign(deltaTime),\n\naccuIndex=this._accuIndex^=1;\n\n// run active actions\n\nfor(var i=0;i!==nActions;++i){\n\nvar action=actions[i];\n\nif(action.enabled){\n\naction._update(time,deltaTime,timeDirection,accuIndex);\n\n}\n\n}\n\n// update scene graph\n\nvar bindings=this._bindings,\nnBindings=this._nActiveBindings;\n\nfor(var i=0;i!==nBindings;++i){\n\nbindings[i].apply(accuIndex);\n\n}\n\nreturn this;\n\n},\n\n// return this mixer's root target object\ngetRoot:function getRoot(){\n\nreturn this._root;\n\n},\n\n// free all resources specific to a particular clip\nuncacheClip:function uncacheClip(clip){\n\nvar actions=this._actions,\nclipUuid=clip.uuid,\nactionsByClip=this._actionsByClip,\nactionsForClip=actionsByClip[clipUuid];\n\nif(actionsForClip!==undefined){\n\n// note: just calling _removeInactiveAction would mess up the\n// iteration state and also require updating the state we can\n// just throw away\n\nvar actionsToRemove=actionsForClip.knownActions;\n\nfor(var i=0,n=actionsToRemove.length;i!==n;++i){\n\nvar action=actionsToRemove[i];\n\nthis._deactivateAction(action);\n\nvar cacheIndex=action._cacheIndex,\nlastInactiveAction=actions[actions.length-1];\n\naction._cacheIndex=null;\naction._byClipCacheIndex=null;\n\nlastInactiveAction._cacheIndex=cacheIndex;\nactions[cacheIndex]=lastInactiveAction;\nactions.pop();\n\nthis._removeInactiveBindingsForAction(action);\n\n}\n\ndelete actionsByClip[clipUuid];\n\n}\n\n},\n\n// free all resources specific to a particular root target object\nuncacheRoot:function uncacheRoot(root){\n\nvar rootUuid=root.uuid,\nactionsByClip=this._actionsByClip;\n\nfor(var clipUuid in actionsByClip){\n\nvar actionByRoot=actionsByClip[clipUuid].actionByRoot,\naction=actionByRoot[rootUuid];\n\nif(action!==undefined){\n\nthis._deactivateAction(action);\nthis._removeInactiveAction(action);\n\n}\n\n}\n\nvar bindingsByRoot=this._bindingsByRootAndName,\nbindingByName=bindingsByRoot[rootUuid];\n\nif(bindingByName!==undefined){\n\nfor(var trackName in bindingByName){\n\nvar binding=bindingByName[trackName];\nbinding.restoreOriginalState();\nthis._removeInactiveBinding(binding);\n\n}\n\n}\n\n},\n\n// remove a targeted clip from the cache\nuncacheAction:function uncacheAction(clip,optionalRoot){\n\nvar action=this.existingAction(clip,optionalRoot);\n\nif(action!==null){\n\nthis._deactivateAction(action);\nthis._removeInactiveAction(action);\n\n}\n\n}};\n\n\n\n// Implementation details:\n\nObject.assign(AnimationMixer.prototype,{\n\n_bindAction:function _bindAction(action,prototypeAction){\n\nvar root=action._localRoot||this._root,\ntracks=action._clip.tracks,\nnTracks=tracks.length,\nbindings=action._propertyBindings,\ninterpolants=action._interpolants,\nrootUuid=root.uuid,\nbindingsByRoot=this._bindingsByRootAndName,\nbindingsByName=bindingsByRoot[rootUuid];\n\nif(bindingsByName===undefined){\n\nbindingsByName={};\nbindingsByRoot[rootUuid]=bindingsByName;\n\n}\n\nfor(var i=0;i!==nTracks;++i){\n\nvar track=tracks[i],\ntrackName=track.name,\nbinding=bindingsByName[trackName];\n\nif(binding!==undefined){\n\nbindings[i]=binding;\n\n}else{\n\nbinding=bindings[i];\n\nif(binding!==undefined){\n\n// existing binding, make sure the cache knows\n\nif(binding._cacheIndex===null){\n\n++binding.referenceCount;\nthis._addInactiveBinding(binding,rootUuid,trackName);\n\n}\n\ncontinue;\n\n}\n\nvar path=prototypeAction&&prototypeAction.\n_propertyBindings[i].binding.parsedPath;\n\nbinding=new PropertyMixer(\nPropertyBinding.create(root,trackName,path),\ntrack.ValueTypeName,track.getValueSize());\n\n++binding.referenceCount;\nthis._addInactiveBinding(binding,rootUuid,trackName);\n\nbindings[i]=binding;\n\n}\n\ninterpolants[i].resultBuffer=binding.buffer;\n\n}\n\n},\n\n_activateAction:function _activateAction(action){\n\nif(!this._isActiveAction(action)){\n\nif(action._cacheIndex===null){\n\n// this action has been forgotten by the cache, but the user\n// appears to be still using it -> rebind\n\nvar rootUuid=(action._localRoot||this._root).uuid,\nclipUuid=action._clip.uuid,\nactionsForClip=this._actionsByClip[clipUuid];\n\nthis._bindAction(action,\nactionsForClip&&actionsForClip.knownActions[0]);\n\nthis._addInactiveAction(action,clipUuid,rootUuid);\n\n}\n\nvar bindings=action._propertyBindings;\n\n// increment reference counts / sort out state\nfor(var i=0,n=bindings.length;i!==n;++i){\n\nvar binding=bindings[i];\n\nif(binding.useCount++===0){\n\nthis._lendBinding(binding);\nbinding.saveOriginalState();\n\n}\n\n}\n\nthis._lendAction(action);\n\n}\n\n},\n\n_deactivateAction:function _deactivateAction(action){\n\nif(this._isActiveAction(action)){\n\nvar bindings=action._propertyBindings;\n\n// decrement reference counts / sort out state\nfor(var i=0,n=bindings.length;i!==n;++i){\n\nvar binding=bindings[i];\n\nif(--binding.useCount===0){\n\nbinding.restoreOriginalState();\nthis._takeBackBinding(binding);\n\n}\n\n}\n\nthis._takeBackAction(action);\n\n}\n\n},\n\n// Memory manager\n\n_initMemoryManager:function _initMemoryManager(){\n\nthis._actions=[];// 'nActiveActions' followed by inactive ones\nthis._nActiveActions=0;\n\nthis._actionsByClip={};\n// inside:\n// {\n// \t\tknownActions: Array< AnimationAction >\t- used as prototypes\n// \t\tactionByRoot: AnimationAction\t\t\t- lookup\n// }\n\n\nthis._bindings=[];// 'nActiveBindings' followed by inactive ones\nthis._nActiveBindings=0;\n\nthis._bindingsByRootAndName={};// inside: Map< name, PropertyMixer >\n\n\nthis._controlInterpolants=[];// same game as above\nthis._nActiveControlInterpolants=0;\n\nvar scope=this;\n\nthis.stats={\n\nactions:{\nget total(){return scope._actions.length;},\nget inUse(){return scope._nActiveActions;}},\n\nbindings:{\nget total(){return scope._bindings.length;},\nget inUse(){return scope._nActiveBindings;}},\n\ncontrolInterpolants:{\nget total(){return scope._controlInterpolants.length;},\nget inUse(){return scope._nActiveControlInterpolants;}}};\n\n\n\n\n},\n\n// Memory management for AnimationAction objects\n\n_isActiveAction:function _isActiveAction(action){\n\nvar index=action._cacheIndex;\nreturn index!==null&&index<this._nActiveActions;\n\n},\n\n_addInactiveAction:function _addInactiveAction(action,clipUuid,rootUuid){\n\nvar actions=this._actions,\nactionsByClip=this._actionsByClip,\nactionsForClip=actionsByClip[clipUuid];\n\nif(actionsForClip===undefined){\n\nactionsForClip={\n\nknownActions:[action],\nactionByRoot:{}};\n\n\n\naction._byClipCacheIndex=0;\n\nactionsByClip[clipUuid]=actionsForClip;\n\n}else{\n\nvar knownActions=actionsForClip.knownActions;\n\naction._byClipCacheIndex=knownActions.length;\nknownActions.push(action);\n\n}\n\naction._cacheIndex=actions.length;\nactions.push(action);\n\nactionsForClip.actionByRoot[rootUuid]=action;\n\n},\n\n_removeInactiveAction:function _removeInactiveAction(action){\n\nvar actions=this._actions,\nlastInactiveAction=actions[actions.length-1],\ncacheIndex=action._cacheIndex;\n\nlastInactiveAction._cacheIndex=cacheIndex;\nactions[cacheIndex]=lastInactiveAction;\nactions.pop();\n\naction._cacheIndex=null;\n\n\nvar clipUuid=action._clip.uuid,\nactionsByClip=this._actionsByClip,\nactionsForClip=actionsByClip[clipUuid],\nknownActionsForClip=actionsForClip.knownActions,\n\nlastKnownAction=\nknownActionsForClip[knownActionsForClip.length-1],\n\nbyClipCacheIndex=action._byClipCacheIndex;\n\nlastKnownAction._byClipCacheIndex=byClipCacheIndex;\nknownActionsForClip[byClipCacheIndex]=lastKnownAction;\nknownActionsForClip.pop();\n\naction._byClipCacheIndex=null;\n\n\nvar actionByRoot=actionsForClip.actionByRoot,\nrootUuid=(actions._localRoot||this._root).uuid;\n\ndelete actionByRoot[rootUuid];\n\nif(knownActionsForClip.length===0){\n\ndelete actionsByClip[clipUuid];\n\n}\n\nthis._removeInactiveBindingsForAction(action);\n\n},\n\n_removeInactiveBindingsForAction:function _removeInactiveBindingsForAction(action){\n\nvar bindings=action._propertyBindings;\nfor(var i=0,n=bindings.length;i!==n;++i){\n\nvar binding=bindings[i];\n\nif(--binding.referenceCount===0){\n\nthis._removeInactiveBinding(binding);\n\n}\n\n}\n\n},\n\n_lendAction:function _lendAction(action){\n\n// [ active actions |  inactive actions  ]\n// [  active actions >| inactive actions ]\n//                 s        a\n//                  <-swap->\n//                 a        s\n\nvar actions=this._actions,\nprevIndex=action._cacheIndex,\n\nlastActiveIndex=this._nActiveActions++,\n\nfirstInactiveAction=actions[lastActiveIndex];\n\naction._cacheIndex=lastActiveIndex;\nactions[lastActiveIndex]=action;\n\nfirstInactiveAction._cacheIndex=prevIndex;\nactions[prevIndex]=firstInactiveAction;\n\n},\n\n_takeBackAction:function _takeBackAction(action){\n\n// [  active actions  | inactive actions ]\n// [ active actions |< inactive actions  ]\n//        a        s\n//         <-swap->\n//        s        a\n\nvar actions=this._actions,\nprevIndex=action._cacheIndex,\n\nfirstInactiveIndex=--this._nActiveActions,\n\nlastActiveAction=actions[firstInactiveIndex];\n\naction._cacheIndex=firstInactiveIndex;\nactions[firstInactiveIndex]=action;\n\nlastActiveAction._cacheIndex=prevIndex;\nactions[prevIndex]=lastActiveAction;\n\n},\n\n// Memory management for PropertyMixer objects\n\n_addInactiveBinding:function _addInactiveBinding(binding,rootUuid,trackName){\n\nvar bindingsByRoot=this._bindingsByRootAndName,\nbindingByName=bindingsByRoot[rootUuid],\n\nbindings=this._bindings;\n\nif(bindingByName===undefined){\n\nbindingByName={};\nbindingsByRoot[rootUuid]=bindingByName;\n\n}\n\nbindingByName[trackName]=binding;\n\nbinding._cacheIndex=bindings.length;\nbindings.push(binding);\n\n},\n\n_removeInactiveBinding:function _removeInactiveBinding(binding){\n\nvar bindings=this._bindings,\npropBinding=binding.binding,\nrootUuid=propBinding.rootNode.uuid,\ntrackName=propBinding.path,\nbindingsByRoot=this._bindingsByRootAndName,\nbindingByName=bindingsByRoot[rootUuid],\n\nlastInactiveBinding=bindings[bindings.length-1],\ncacheIndex=binding._cacheIndex;\n\nlastInactiveBinding._cacheIndex=cacheIndex;\nbindings[cacheIndex]=lastInactiveBinding;\nbindings.pop();\n\ndelete bindingByName[trackName];\n\nremove_empty_map:{\n\nfor(var _ in bindingByName){break remove_empty_map;}\n\ndelete bindingsByRoot[rootUuid];\n\n}\n\n},\n\n_lendBinding:function _lendBinding(binding){\n\nvar bindings=this._bindings,\nprevIndex=binding._cacheIndex,\n\nlastActiveIndex=this._nActiveBindings++,\n\nfirstInactiveBinding=bindings[lastActiveIndex];\n\nbinding._cacheIndex=lastActiveIndex;\nbindings[lastActiveIndex]=binding;\n\nfirstInactiveBinding._cacheIndex=prevIndex;\nbindings[prevIndex]=firstInactiveBinding;\n\n},\n\n_takeBackBinding:function _takeBackBinding(binding){\n\nvar bindings=this._bindings,\nprevIndex=binding._cacheIndex,\n\nfirstInactiveIndex=--this._nActiveBindings,\n\nlastActiveBinding=bindings[firstInactiveIndex];\n\nbinding._cacheIndex=firstInactiveIndex;\nbindings[firstInactiveIndex]=binding;\n\nlastActiveBinding._cacheIndex=prevIndex;\nbindings[prevIndex]=lastActiveBinding;\n\n},\n\n\n// Memory management of Interpolants for weight and time scale\n\n_lendControlInterpolant:function _lendControlInterpolant(){\n\nvar interpolants=this._controlInterpolants,\nlastActiveIndex=this._nActiveControlInterpolants++,\ninterpolant=interpolants[lastActiveIndex];\n\nif(interpolant===undefined){\n\ninterpolant=new LinearInterpolant(\nnew Float32Array(2),new Float32Array(2),\n1,this._controlInterpolantsResultBuffer);\n\ninterpolant.__cacheIndex=lastActiveIndex;\ninterpolants[lastActiveIndex]=interpolant;\n\n}\n\nreturn interpolant;\n\n},\n\n_takeBackControlInterpolant:function _takeBackControlInterpolant(interpolant){\n\nvar interpolants=this._controlInterpolants,\nprevIndex=interpolant.__cacheIndex,\n\nfirstInactiveIndex=--this._nActiveControlInterpolants,\n\nlastActiveInterpolant=interpolants[firstInactiveIndex];\n\ninterpolant.__cacheIndex=firstInactiveIndex;\ninterpolants[firstInactiveIndex]=interpolant;\n\nlastActiveInterpolant.__cacheIndex=prevIndex;\ninterpolants[prevIndex]=lastActiveInterpolant;\n\n},\n\n_controlInterpolantsResultBuffer:new Float32Array(1)});\n\n\n\nObject.assign(AnimationMixer.prototype,EventDispatcher.prototype);\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Uniform(value){\n\nif(typeof value==='string'){\n\nconsole.warn('THREE.Uniform: Type parameter is no longer needed.');\nvalue=arguments[1];\n\n}\n\nthis.value=value;\n\n}\n\nUniform.prototype.clone=function(){\n\nreturn new Uniform(this.value.clone===undefined?this.value:this.value.clone());\n\n};\n\n/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\nfunction InstancedBufferGeometry(){\n\nBufferGeometry.call(this);\n\nthis.type='InstancedBufferGeometry';\nthis.maxInstancedCount=undefined;\n\n}\n\nInstancedBufferGeometry.prototype=Object.create(BufferGeometry.prototype);\nInstancedBufferGeometry.prototype.constructor=InstancedBufferGeometry;\n\nInstancedBufferGeometry.prototype.isInstancedBufferGeometry=true;\n\nInstancedBufferGeometry.prototype.addGroup=function(start,count,materialIndex){\n\nthis.groups.push({\n\nstart:start,\ncount:count,\nmaterialIndex:materialIndex});\n\n\n\n};\n\nInstancedBufferGeometry.prototype.copy=function(source){\n\nvar index=source.index;\n\nif(index!==null){\n\nthis.setIndex(index.clone());\n\n}\n\nvar attributes=source.attributes;\n\nfor(var name in attributes){\n\nvar attribute=attributes[name];\nthis.addAttribute(name,attribute.clone());\n\n}\n\nvar groups=source.groups;\n\nfor(var i=0,l=groups.length;i<l;i++){\n\nvar group=groups[i];\nthis.addGroup(group.start,group.count,group.materialIndex);\n\n}\n\nreturn this;\n\n};\n\n/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\nfunction InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,normalized){\n\nthis.uuid=_Math.generateUUID();\n\nthis.data=interleavedBuffer;\nthis.itemSize=itemSize;\nthis.offset=offset;\n\nthis.normalized=normalized===true;\n\n}\n\n\nInterleavedBufferAttribute.prototype={\n\nconstructor:InterleavedBufferAttribute,\n\nisInterleavedBufferAttribute:true,\n\nget count(){\n\nreturn this.data.count;\n\n},\n\nget array(){\n\nreturn this.data.array;\n\n},\n\nsetX:function setX(index,x){\n\nthis.data.array[index*this.data.stride+this.offset]=x;\n\nreturn this;\n\n},\n\nsetY:function setY(index,y){\n\nthis.data.array[index*this.data.stride+this.offset+1]=y;\n\nreturn this;\n\n},\n\nsetZ:function setZ(index,z){\n\nthis.data.array[index*this.data.stride+this.offset+2]=z;\n\nreturn this;\n\n},\n\nsetW:function setW(index,w){\n\nthis.data.array[index*this.data.stride+this.offset+3]=w;\n\nreturn this;\n\n},\n\ngetX:function getX(index){\n\nreturn this.data.array[index*this.data.stride+this.offset];\n\n},\n\ngetY:function getY(index){\n\nreturn this.data.array[index*this.data.stride+this.offset+1];\n\n},\n\ngetZ:function getZ(index){\n\nreturn this.data.array[index*this.data.stride+this.offset+2];\n\n},\n\ngetW:function getW(index){\n\nreturn this.data.array[index*this.data.stride+this.offset+3];\n\n},\n\nsetXY:function setXY(index,x,y){\n\nindex=index*this.data.stride+this.offset;\n\nthis.data.array[index+0]=x;\nthis.data.array[index+1]=y;\n\nreturn this;\n\n},\n\nsetXYZ:function setXYZ(index,x,y,z){\n\nindex=index*this.data.stride+this.offset;\n\nthis.data.array[index+0]=x;\nthis.data.array[index+1]=y;\nthis.data.array[index+2]=z;\n\nreturn this;\n\n},\n\nsetXYZW:function setXYZW(index,x,y,z,w){\n\nindex=index*this.data.stride+this.offset;\n\nthis.data.array[index+0]=x;\nthis.data.array[index+1]=y;\nthis.data.array[index+2]=z;\nthis.data.array[index+3]=w;\n\nreturn this;\n\n}};\n\n\n\n/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\nfunction InterleavedBuffer(array,stride){\n\nthis.uuid=_Math.generateUUID();\n\nthis.array=array;\nthis.stride=stride;\nthis.count=array!==undefined?array.length/stride:0;\n\nthis.dynamic=false;\nthis.updateRange={offset:0,count:-1};\n\nthis.onUploadCallback=function(){};\n\nthis.version=0;\n\n}\n\nInterleavedBuffer.prototype={\n\nconstructor:InterleavedBuffer,\n\nisInterleavedBuffer:true,\n\nset needsUpdate(value){\n\nif(value===true)this.version++;\n\n},\n\nsetArray:function setArray(array){\n\nif(Array.isArray(array)){\n\nthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n\n}\n\nthis.count=array!==undefined?array.length/this.stride:0;\nthis.array=array;\n\n},\n\nsetDynamic:function setDynamic(value){\n\nthis.dynamic=value;\n\nreturn this;\n\n},\n\ncopy:function copy(source){\n\nthis.array=new source.array.constructor(source.array);\nthis.count=source.count;\nthis.stride=source.stride;\nthis.dynamic=source.dynamic;\n\nreturn this;\n\n},\n\ncopyAt:function copyAt(index1,attribute,index2){\n\nindex1*=this.stride;\nindex2*=attribute.stride;\n\nfor(var i=0,l=this.stride;i<l;i++){\n\nthis.array[index1+i]=attribute.array[index2+i];\n\n}\n\nreturn this;\n\n},\n\nset:function set(value,offset){\n\nif(offset===undefined)offset=0;\n\nthis.array.set(value,offset);\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\nonUpload:function onUpload(callback){\n\nthis.onUploadCallback=callback;\n\nreturn this;\n\n}};\n\n\n\n/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\nfunction InstancedInterleavedBuffer(array,stride,meshPerAttribute){\n\nInterleavedBuffer.call(this,array,stride);\n\nthis.meshPerAttribute=meshPerAttribute||1;\n\n}\n\nInstancedInterleavedBuffer.prototype=Object.create(InterleavedBuffer.prototype);\nInstancedInterleavedBuffer.prototype.constructor=InstancedInterleavedBuffer;\n\nInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer=true;\n\nInstancedInterleavedBuffer.prototype.copy=function(source){\n\nInterleavedBuffer.prototype.copy.call(this,source);\n\nthis.meshPerAttribute=source.meshPerAttribute;\n\nreturn this;\n\n};\n\n/**\n\t * @author benaadams / https://twitter.com/ben_a_adams\n\t */\n\nfunction InstancedBufferAttribute(array,itemSize,meshPerAttribute){\n\nBufferAttribute.call(this,array,itemSize);\n\nthis.meshPerAttribute=meshPerAttribute||1;\n\n}\n\nInstancedBufferAttribute.prototype=Object.create(BufferAttribute.prototype);\nInstancedBufferAttribute.prototype.constructor=InstancedBufferAttribute;\n\nInstancedBufferAttribute.prototype.isInstancedBufferAttribute=true;\n\nInstancedBufferAttribute.prototype.copy=function(source){\n\nBufferAttribute.prototype.copy.call(this,source);\n\nthis.meshPerAttribute=source.meshPerAttribute;\n\nreturn this;\n\n};\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author bhouston / http://clara.io/\n\t * @author stephomi / http://stephaneginier.com/\n\t */\n\nfunction Raycaster(origin,direction,near,far){\n\nthis.ray=new Ray(origin,direction);\n// direction is assumed to be normalized (for accurate distance calculations)\n\nthis.near=near||0;\nthis.far=far||Infinity;\n\nthis.params={\nMesh:{},\nLine:{},\nLOD:{},\nPoints:{threshold:1},\nSprite:{}};\n\n\nObject.defineProperties(this.params,{\nPointCloud:{\nget:function get(){\nconsole.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');\nreturn this.Points;\n}}});\n\n\n\n}\n\nfunction ascSort(a,b){\n\nreturn a.distance-b.distance;\n\n}\n\nfunction _intersectObject(object,raycaster,intersects,recursive){\n\nif(object.visible===false)return;\n\nobject.raycast(raycaster,intersects);\n\nif(recursive===true){\n\nvar children=object.children;\n\nfor(var i=0,l=children.length;i<l;i++){\n\n_intersectObject(children[i],raycaster,intersects,true);\n\n}\n\n}\n\n}\n\n//\n\nRaycaster.prototype={\n\nconstructor:Raycaster,\n\nlinePrecision:1,\n\nset:function set(origin,direction){\n\n// direction is assumed to be normalized (for accurate distance calculations)\n\nthis.ray.set(origin,direction);\n\n},\n\nsetFromCamera:function setFromCamera(coords,camera){\n\nif(camera&&camera.isPerspectiveCamera){\n\nthis.ray.origin.setFromMatrixPosition(camera.matrixWorld);\nthis.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();\n\n}else if(camera&&camera.isOrthographicCamera){\n\nthis.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera\nthis.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);\n\n}else{\n\nconsole.error('THREE.Raycaster: Unsupported camera type.');\n\n}\n\n},\n\nintersectObject:function intersectObject(object,recursive){\n\nvar intersects=[];\n\n_intersectObject(object,this,intersects,recursive);\n\nintersects.sort(ascSort);\n\nreturn intersects;\n\n},\n\nintersectObjects:function intersectObjects(objects,recursive){\n\nvar intersects=[];\n\nif(Array.isArray(objects)===false){\n\nconsole.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');\nreturn intersects;\n\n}\n\nfor(var i=0,l=objects.length;i<l;i++){\n\n_intersectObject(objects[i],this,intersects,recursive);\n\n}\n\nintersects.sort(ascSort);\n\nreturn intersects;\n\n}};\n\n\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction Clock(autoStart){\n\nthis.autoStart=autoStart!==undefined?autoStart:true;\n\nthis.startTime=0;\nthis.oldTime=0;\nthis.elapsedTime=0;\n\nthis.running=false;\n\n}\n\nClock.prototype={\n\nconstructor:Clock,\n\nstart:function start(){\n\nthis.startTime=(performance||Date).now();\n\nthis.oldTime=this.startTime;\nthis.elapsedTime=0;\nthis.running=true;\n\n},\n\nstop:function stop(){\n\nthis.getElapsedTime();\nthis.running=false;\n\n},\n\ngetElapsedTime:function getElapsedTime(){\n\nthis.getDelta();\nreturn this.elapsedTime;\n\n},\n\ngetDelta:function getDelta(){\n\nvar diff=0;\n\nif(this.autoStart&&!this.running){\n\nthis.start();\n\n}\n\nif(this.running){\n\nvar newTime=(performance||Date).now();\n\ndiff=(newTime-this.oldTime)/1000;\nthis.oldTime=newTime;\n\nthis.elapsedTime+=diff;\n\n}\n\nreturn diff;\n\n}};\n\n\n\n/**\n\t * @author bhouston / http://clara.io\n\t * @author WestLangley / http://github.com/WestLangley\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The poles (phi) are at the positive and negative y axis.\n\t * The equator starts at positive z.\n\t */\n\nfunction Spherical(radius,phi,theta){\n\nthis.radius=radius!==undefined?radius:1.0;\nthis.phi=phi!==undefined?phi:0;// up / down towards top and bottom pole\nthis.theta=theta!==undefined?theta:0;// around the equator of the sphere\n\nreturn this;\n\n}\n\nSpherical.prototype={\n\nconstructor:Spherical,\n\nset:function set(radius,phi,theta){\n\nthis.radius=radius;\nthis.phi=phi;\nthis.theta=theta;\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(other){\n\nthis.radius=other.radius;\nthis.phi=other.phi;\nthis.theta=other.theta;\n\nreturn this;\n\n},\n\n// restrict phi to be betwee EPS and PI-EPS\nmakeSafe:function makeSafe(){\n\nvar EPS=0.000001;\nthis.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));\n\nreturn this;\n\n},\n\nsetFromVector3:function setFromVector3(vec3){\n\nthis.radius=vec3.length();\n\nif(this.radius===0){\n\nthis.theta=0;\nthis.phi=0;\n\n}else{\n\nthis.theta=Math.atan2(vec3.x,vec3.z);// equator angle around y-up axis\nthis.phi=Math.acos(_Math.clamp(vec3.y/this.radius,-1,1));// polar angle\n\n}\n\nreturn this;\n\n}};\n\n\n\n/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n\t *\n\t */\n\nfunction Cylindrical(radius,theta,y){\n\nthis.radius=radius!==undefined?radius:1.0;// distance from the origin to a point in the x-z plane\nthis.theta=theta!==undefined?theta:0;// counterclockwise angle in the x-z plane measured in radians from the positive z-axis\nthis.y=y!==undefined?y:0;// height above the x-z plane\n\nreturn this;\n\n}\n\nCylindrical.prototype={\n\nconstructor:Cylindrical,\n\nset:function set(radius,theta,y){\n\nthis.radius=radius;\nthis.theta=theta;\nthis.y=y;\n\nreturn this;\n\n},\n\nclone:function clone(){\n\nreturn new this.constructor().copy(this);\n\n},\n\ncopy:function copy(other){\n\nthis.radius=other.radius;\nthis.theta=other.theta;\nthis.y=other.y;\n\nreturn this;\n\n},\n\nsetFromVector3:function setFromVector3(vec3){\n\nthis.radius=Math.sqrt(vec3.x*vec3.x+vec3.z*vec3.z);\nthis.theta=Math.atan2(vec3.x,vec3.z);\nthis.y=vec3.y;\n\nreturn this;\n\n}};\n\n\n\n/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\n\nfunction MorphBlendMesh(geometry,material){\n\nMesh.call(this,geometry,material);\n\nthis.animationsMap={};\nthis.animationsList=[];\n\n// prepare default animation\n// (all frames played together in 1 second)\n\nvar numFrames=this.geometry.morphTargets.length;\n\nvar name=\"__default\";\n\nvar startFrame=0;\nvar endFrame=numFrames-1;\n\nvar fps=numFrames/1;\n\nthis.createAnimation(name,startFrame,endFrame,fps);\nthis.setAnimationWeight(name,1);\n\n}\n\nMorphBlendMesh.prototype=Object.create(Mesh.prototype);\nMorphBlendMesh.prototype.constructor=MorphBlendMesh;\n\nMorphBlendMesh.prototype.createAnimation=function(name,start,end,fps){\n\nvar animation={\n\nstart:start,\nend:end,\n\nlength:end-start+1,\n\nfps:fps,\nduration:(end-start)/fps,\n\nlastFrame:0,\ncurrentFrame:0,\n\nactive:false,\n\ntime:0,\ndirection:1,\nweight:1,\n\ndirectionBackwards:false,\nmirroredLoop:false};\n\n\n\nthis.animationsMap[name]=animation;\nthis.animationsList.push(animation);\n\n};\n\nMorphBlendMesh.prototype.autoCreateAnimations=function(fps){\n\nvar pattern=/([a-z]+)_?(\\d+)/i;\n\nvar firstAnimation,frameRanges={};\n\nvar geometry=this.geometry;\n\nfor(var i=0,il=geometry.morphTargets.length;i<il;i++){\n\nvar morph=geometry.morphTargets[i];\nvar chunks=morph.name.match(pattern);\n\nif(chunks&&chunks.length>1){\n\nvar name=chunks[1];\n\nif(!frameRanges[name])frameRanges[name]={start:Infinity,end:-Infinity};\n\nvar range=frameRanges[name];\n\nif(i<range.start)range.start=i;\nif(i>range.end)range.end=i;\n\nif(!firstAnimation)firstAnimation=name;\n\n}\n\n}\n\nfor(var name in frameRanges){\n\nvar range=frameRanges[name];\nthis.createAnimation(name,range.start,range.end,fps);\n\n}\n\nthis.firstAnimation=firstAnimation;\n\n};\n\nMorphBlendMesh.prototype.setAnimationDirectionForward=function(name){\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nanimation.direction=1;\nanimation.directionBackwards=false;\n\n}\n\n};\n\nMorphBlendMesh.prototype.setAnimationDirectionBackward=function(name){\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nanimation.direction=-1;\nanimation.directionBackwards=true;\n\n}\n\n};\n\nMorphBlendMesh.prototype.setAnimationFPS=function(name,fps){\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nanimation.fps=fps;\nanimation.duration=(animation.end-animation.start)/animation.fps;\n\n}\n\n};\n\nMorphBlendMesh.prototype.setAnimationDuration=function(name,duration){\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nanimation.duration=duration;\nanimation.fps=(animation.end-animation.start)/animation.duration;\n\n}\n\n};\n\nMorphBlendMesh.prototype.setAnimationWeight=function(name,weight){\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nanimation.weight=weight;\n\n}\n\n};\n\nMorphBlendMesh.prototype.setAnimationTime=function(name,time){\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nanimation.time=time;\n\n}\n\n};\n\nMorphBlendMesh.prototype.getAnimationTime=function(name){\n\nvar time=0;\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\ntime=animation.time;\n\n}\n\nreturn time;\n\n};\n\nMorphBlendMesh.prototype.getAnimationDuration=function(name){\n\nvar duration=-1;\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nduration=animation.duration;\n\n}\n\nreturn duration;\n\n};\n\nMorphBlendMesh.prototype.playAnimation=function(name){\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nanimation.time=0;\nanimation.active=true;\n\n}else{\n\nconsole.warn(\"THREE.MorphBlendMesh: animation[\"+name+\"] undefined in .playAnimation()\");\n\n}\n\n};\n\nMorphBlendMesh.prototype.stopAnimation=function(name){\n\nvar animation=this.animationsMap[name];\n\nif(animation){\n\nanimation.active=false;\n\n}\n\n};\n\nMorphBlendMesh.prototype.update=function(delta){\n\nfor(var i=0,il=this.animationsList.length;i<il;i++){\n\nvar animation=this.animationsList[i];\n\nif(!animation.active)continue;\n\nvar frameTime=animation.duration/animation.length;\n\nanimation.time+=animation.direction*delta;\n\nif(animation.mirroredLoop){\n\nif(animation.time>animation.duration||animation.time<0){\n\nanimation.direction*=-1;\n\nif(animation.time>animation.duration){\n\nanimation.time=animation.duration;\nanimation.directionBackwards=true;\n\n}\n\nif(animation.time<0){\n\nanimation.time=0;\nanimation.directionBackwards=false;\n\n}\n\n}\n\n}else{\n\nanimation.time=animation.time%animation.duration;\n\nif(animation.time<0)animation.time+=animation.duration;\n\n}\n\nvar keyframe=animation.start+_Math.clamp(Math.floor(animation.time/frameTime),0,animation.length-1);\nvar weight=animation.weight;\n\nif(keyframe!==animation.currentFrame){\n\nthis.morphTargetInfluences[animation.lastFrame]=0;\nthis.morphTargetInfluences[animation.currentFrame]=1*weight;\n\nthis.morphTargetInfluences[keyframe]=0;\n\nanimation.lastFrame=animation.currentFrame;\nanimation.currentFrame=keyframe;\n\n}\n\nvar mix=animation.time%frameTime/frameTime;\n\nif(animation.directionBackwards)mix=1-mix;\n\nif(animation.currentFrame!==animation.lastFrame){\n\nthis.morphTargetInfluences[animation.currentFrame]=mix*weight;\nthis.morphTargetInfluences[animation.lastFrame]=(1-mix)*weight;\n\n}else{\n\nthis.morphTargetInfluences[animation.currentFrame]=weight;\n\n}\n\n}\n\n};\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nfunction ImmediateRenderObject(material){\n\nObject3D.call(this);\n\nthis.material=material;\nthis.render=function(renderCallback){};\n\n}\n\nImmediateRenderObject.prototype=Object.create(Object3D.prototype);\nImmediateRenderObject.prototype.constructor=ImmediateRenderObject;\n\nImmediateRenderObject.prototype.isImmediateRenderObject=true;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\nfunction VertexNormalsHelper(object,size,hex,linewidth){\n\nthis.object=object;\n\nthis.size=size!==undefined?size:1;\n\nvar color=hex!==undefined?hex:0xff0000;\n\nvar width=linewidth!==undefined?linewidth:1;\n\n//\n\nvar nNormals=0;\n\nvar objGeometry=this.object.geometry;\n\nif(objGeometry&&objGeometry.isGeometry){\n\nnNormals=objGeometry.faces.length*3;\n\n}else if(objGeometry&&objGeometry.isBufferGeometry){\n\nnNormals=objGeometry.attributes.normal.count;\n\n}\n\n//\n\nvar geometry=new BufferGeometry();\n\nvar positions=new Float32BufferAttribute(nNormals*2*3,3);\n\ngeometry.addAttribute('position',positions);\n\nLineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));\n\n//\n\nthis.matrixAutoUpdate=false;\n\nthis.update();\n\n}\n\nVertexNormalsHelper.prototype=Object.create(LineSegments.prototype);\nVertexNormalsHelper.prototype.constructor=VertexNormalsHelper;\n\nVertexNormalsHelper.prototype.update=function(){\n\nvar v1=new Vector3();\nvar v2=new Vector3();\nvar normalMatrix=new Matrix3();\n\nreturn function update(){\n\nvar keys=['a','b','c'];\n\nthis.object.updateMatrixWorld(true);\n\nnormalMatrix.getNormalMatrix(this.object.matrixWorld);\n\nvar matrixWorld=this.object.matrixWorld;\n\nvar position=this.geometry.attributes.position;\n\n//\n\nvar objGeometry=this.object.geometry;\n\nif(objGeometry&&objGeometry.isGeometry){\n\nvar vertices=objGeometry.vertices;\n\nvar faces=objGeometry.faces;\n\nvar idx=0;\n\nfor(var i=0,l=faces.length;i<l;i++){\n\nvar face=faces[i];\n\nfor(var j=0,jl=face.vertexNormals.length;j<jl;j++){\n\nvar vertex=vertices[face[keys[j]]];\n\nvar normal=face.vertexNormals[j];\n\nv1.copy(vertex).applyMatrix4(matrixWorld);\n\nv2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\n\nposition.setXYZ(idx,v1.x,v1.y,v1.z);\n\nidx=idx+1;\n\nposition.setXYZ(idx,v2.x,v2.y,v2.z);\n\nidx=idx+1;\n\n}\n\n}\n\n}else if(objGeometry&&objGeometry.isBufferGeometry){\n\nvar objPos=objGeometry.attributes.position;\n\nvar objNorm=objGeometry.attributes.normal;\n\nvar idx=0;\n\n// for simplicity, ignore index and drawcalls, and render every normal\n\nfor(var j=0,jl=objPos.count;j<jl;j++){\n\nv1.set(objPos.getX(j),objPos.getY(j),objPos.getZ(j)).applyMatrix4(matrixWorld);\n\nv2.set(objNorm.getX(j),objNorm.getY(j),objNorm.getZ(j));\n\nv2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\n\nposition.setXYZ(idx,v1.x,v1.y,v1.z);\n\nidx=idx+1;\n\nposition.setXYZ(idx,v2.x,v2.y,v2.z);\n\nidx=idx+1;\n\n}\n\n}\n\nposition.needsUpdate=true;\n\nreturn this;\n\n};\n\n}();\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\nfunction SpotLightHelper(light){\n\nObject3D.call(this);\n\nthis.light=light;\nthis.light.updateMatrixWorld();\n\nthis.matrix=light.matrixWorld;\nthis.matrixAutoUpdate=false;\n\nvar geometry=new BufferGeometry();\n\nvar positions=[\n0,0,0,0,0,1,\n0,0,0,1,0,1,\n0,0,0,-1,0,1,\n0,0,0,0,1,1,\n0,0,0,0,-1,1];\n\n\nfor(var i=0,j=1,l=32;i<l;i++,j++){\n\nvar p1=i/l*Math.PI*2;\nvar p2=j/l*Math.PI*2;\n\npositions.push(\nMath.cos(p1),Math.sin(p1),1,\nMath.cos(p2),Math.sin(p2),1);\n\n\n}\n\ngeometry.addAttribute('position',new Float32BufferAttribute(positions,3));\n\nvar material=new LineBasicMaterial({fog:false});\n\nthis.cone=new LineSegments(geometry,material);\nthis.add(this.cone);\n\nthis.update();\n\n}\n\nSpotLightHelper.prototype=Object.create(Object3D.prototype);\nSpotLightHelper.prototype.constructor=SpotLightHelper;\n\nSpotLightHelper.prototype.dispose=function(){\n\nthis.cone.geometry.dispose();\nthis.cone.material.dispose();\n\n};\n\nSpotLightHelper.prototype.update=function(){\n\nvar vector=new Vector3();\nvar vector2=new Vector3();\n\nreturn function update(){\n\nvar coneLength=this.light.distance?this.light.distance:1000;\nvar coneWidth=coneLength*Math.tan(this.light.angle);\n\nthis.cone.scale.set(coneWidth,coneWidth,coneLength);\n\nvector.setFromMatrixPosition(this.light.matrixWorld);\nvector2.setFromMatrixPosition(this.light.target.matrixWorld);\n\nthis.cone.lookAt(vector2.sub(vector));\n\nthis.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n\n};\n\n}();\n\n/**\n\t * @author Sean Griffin / http://twitter.com/sgrif\n\t * @author Michael Guerrero / http://realitymeltdown.com\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author ikerr / http://verold.com\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction SkeletonHelper(object){\n\nthis.bones=this.getBoneList(object);\n\nvar geometry=new BufferGeometry();\n\nvar vertices=[];\nvar colors=[];\n\nvar color1=new Color(0,0,1);\nvar color2=new Color(0,1,0);\n\nfor(var i=0;i<this.bones.length;i++){\n\nvar bone=this.bones[i];\n\nif(bone.parent&&bone.parent.isBone){\n\nvertices.push(0,0,0);\nvertices.push(0,0,0);\ncolors.push(color1.r,color1.g,color1.b);\ncolors.push(color2.r,color2.g,color2.b);\n\n}\n\n}\n\ngeometry.addAttribute('position',new Float32BufferAttribute(vertices,3));\ngeometry.addAttribute('color',new Float32BufferAttribute(colors,3));\n\nvar material=new LineBasicMaterial({vertexColors:VertexColors,depthTest:false,depthWrite:false,transparent:true});\n\nLineSegments.call(this,geometry,material);\n\nthis.root=object;\n\nthis.matrix=object.matrixWorld;\nthis.matrixAutoUpdate=false;\n\nthis.update();\n\n}\n\n\nSkeletonHelper.prototype=Object.create(LineSegments.prototype);\nSkeletonHelper.prototype.constructor=SkeletonHelper;\n\nSkeletonHelper.prototype.getBoneList=function(object){\n\nvar boneList=[];\n\nif(object&&object.isBone){\n\nboneList.push(object);\n\n}\n\nfor(var i=0;i<object.children.length;i++){\n\nboneList.push.apply(boneList,this.getBoneList(object.children[i]));\n\n}\n\nreturn boneList;\n\n};\n\nSkeletonHelper.prototype.update=function(){\n\nvar vector=new Vector3();\n\nvar boneMatrix=new Matrix4();\nvar matrixWorldInv=new Matrix4();\n\nreturn function update(){\n\nvar geometry=this.geometry;\nvar position=geometry.getAttribute('position');\n\nmatrixWorldInv.getInverse(this.root.matrixWorld);\n\nfor(var i=0,j=0;i<this.bones.length;i++){\n\nvar bone=this.bones[i];\n\nif(bone.parent&&bone.parent.isBone){\n\nboneMatrix.multiplyMatrices(matrixWorldInv,bone.matrixWorld);\nvector.setFromMatrixPosition(boneMatrix);\nposition.setXYZ(j,vector.x,vector.y,vector.z);\n\nboneMatrix.multiplyMatrices(matrixWorldInv,bone.parent.matrixWorld);\nvector.setFromMatrixPosition(boneMatrix);\nposition.setXYZ(j+1,vector.x,vector.y,vector.z);\n\nj+=2;\n\n}\n\n}\n\ngeometry.getAttribute('position').needsUpdate=true;\n\n};\n\n}();\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction PointLightHelper(light,sphereSize){\n\nthis.light=light;\nthis.light.updateMatrixWorld();\n\nvar geometry=new SphereBufferGeometry(sphereSize,4,2);\nvar material=new MeshBasicMaterial({wireframe:true,fog:false});\nmaterial.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n\nMesh.call(this,geometry,material);\n\nthis.matrix=this.light.matrixWorld;\nthis.matrixAutoUpdate=false;\n\n/*\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\t\tvar d = light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\n\t\tthis.add( this.lightDistance );\n\t\t*/\n\n}\n\nPointLightHelper.prototype=Object.create(Mesh.prototype);\nPointLightHelper.prototype.constructor=PointLightHelper;\n\nPointLightHelper.prototype.dispose=function(){\n\nthis.geometry.dispose();\nthis.material.dispose();\n\n};\n\nPointLightHelper.prototype.update=function(){\n\nthis.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n\n/*\n\t\tvar d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n};\n\n/**\n\t * @author abelnation / http://github.com/abelnation\n\t * @author Mugen87 / http://github.com/Mugen87\n\t */\n\nfunction RectAreaLightHelper(light){\n\nObject3D.call(this);\n\nthis.light=light;\nthis.light.updateMatrixWorld();\n\nvar materialFront=new MeshBasicMaterial({\ncolor:light.color,\nfog:false});\n\n\nvar materialBack=new MeshBasicMaterial({\ncolor:light.color,\nfog:false,\nwireframe:true});\n\n\nvar geometry=new BufferGeometry();\n\ngeometry.addAttribute('position',new BufferAttribute(new Float32Array(6*3),3));\n\n// shows the \"front\" of the light, e.g. where light comes from\n\nthis.add(new Mesh(geometry,materialFront));\n\n// shows the \"back\" of the light, which does not emit light\n\nthis.add(new Mesh(geometry,materialBack));\n\nthis.update();\n\n}\n\nRectAreaLightHelper.prototype=Object.create(Object3D.prototype);\nRectAreaLightHelper.prototype.constructor=RectAreaLightHelper;\n\nRectAreaLightHelper.prototype.dispose=function(){\n\nthis.children[0].geometry.dispose();\nthis.children[0].material.dispose();\nthis.children[1].geometry.dispose();\nthis.children[1].material.dispose();\n\n};\n\nRectAreaLightHelper.prototype.update=function(){\n\nvar vector1=new Vector3();\nvar vector2=new Vector3();\n\nreturn function update(){\n\nvar mesh1=this.children[0];\nvar mesh2=this.children[1];\n\nif(this.light.target){\n\nvector1.setFromMatrixPosition(this.light.matrixWorld);\nvector2.setFromMatrixPosition(this.light.target.matrixWorld);\n\nvar lookVec=vector2.clone().sub(vector1);\nmesh1.lookAt(lookVec);\nmesh2.lookAt(lookVec);\n\n}\n\n// update materials\n\nmesh1.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\nmesh2.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n\n// calculate new dimensions of the helper\n\nvar hx=this.light.width*0.5;\nvar hy=this.light.height*0.5;\n\n// because the buffer attribute is shared over both geometries, we only have to update once\n\nvar position=mesh1.geometry.getAttribute('position');\nvar array=position.array;\n\n// first face\n\narray[0]=hx;array[1]=-hy;array[2]=0;\narray[3]=hx;array[4]=hy;array[5]=0;\narray[6]=-hx;array[7]=hy;array[8]=0;\n\n// second face\n\narray[9]=-hx;array[10]=hy;array[11]=0;\narray[12]=-hx;array[13]=-hy;array[14]=0;\narray[15]=hx;array[16]=-hy;array[17]=0;\n\nposition.needsUpdate=true;\n\n};\n\n}();\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t */\n\nfunction HemisphereLightHelper(light,size){\n\nObject3D.call(this);\n\nthis.light=light;\nthis.light.updateMatrixWorld();\n\nthis.matrix=light.matrixWorld;\nthis.matrixAutoUpdate=false;\n\nvar geometry=new OctahedronBufferGeometry(size);\ngeometry.rotateY(Math.PI*0.5);\n\nvar material=new MeshBasicMaterial({vertexColors:VertexColors,wireframe:true});\n\nvar position=geometry.getAttribute('position');\nvar colors=new Float32Array(position.count*3);\n\ngeometry.addAttribute('color',new BufferAttribute(colors,3));\n\nthis.add(new Mesh(geometry,material));\n\nthis.update();\n\n}\n\nHemisphereLightHelper.prototype=Object.create(Object3D.prototype);\nHemisphereLightHelper.prototype.constructor=HemisphereLightHelper;\n\nHemisphereLightHelper.prototype.dispose=function(){\n\nthis.children[0].geometry.dispose();\nthis.children[0].material.dispose();\n\n};\n\nHemisphereLightHelper.prototype.update=function(){\n\nvar vector=new Vector3();\n\nvar color1=new Color();\nvar color2=new Color();\n\nreturn function update(){\n\nvar mesh=this.children[0];\n\nvar colors=mesh.geometry.getAttribute('color');\n\ncolor1.copy(this.light.color).multiplyScalar(this.light.intensity);\ncolor2.copy(this.light.groundColor).multiplyScalar(this.light.intensity);\n\nfor(var i=0,l=colors.count;i<l;i++){\n\nvar color=i<l/2?color1:color2;\n\ncolors.setXYZ(i,color.r,color.g,color.b);\n\n}\n\nmesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());\n\ncolors.needsUpdate=true;\n\n};\n\n}();\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction GridHelper(size,divisions,color1,color2){\n\nsize=size||10;\ndivisions=divisions||10;\ncolor1=new Color(color1!==undefined?color1:0x444444);\ncolor2=new Color(color2!==undefined?color2:0x888888);\n\nvar center=divisions/2;\nvar step=size/divisions;\nvar halfSize=size/2;\n\nvar vertices=[],colors=[];\n\nfor(var i=0,j=0,k=-halfSize;i<=divisions;i++,k+=step){\n\nvertices.push(-halfSize,0,k,halfSize,0,k);\nvertices.push(k,0,-halfSize,k,0,halfSize);\n\nvar color=i===center?color1:color2;\n\ncolor.toArray(colors,j);j+=3;\ncolor.toArray(colors,j);j+=3;\ncolor.toArray(colors,j);j+=3;\ncolor.toArray(colors,j);j+=3;\n\n}\n\nvar geometry=new BufferGeometry();\ngeometry.addAttribute('position',new Float32BufferAttribute(vertices,3));\ngeometry.addAttribute('color',new Float32BufferAttribute(colors,3));\n\nvar material=new LineBasicMaterial({vertexColors:VertexColors});\n\nLineSegments.call(this,geometry,material);\n\n}\n\nGridHelper.prototype=Object.create(LineSegments.prototype);\nGridHelper.prototype.constructor=GridHelper;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author Mugen87 / http://github.com/Mugen87\n\t * @author Hectate / http://www.github.com/Hectate\n\t */\n\nfunction PolarGridHelper(radius,radials,circles,divisions,color1,color2){\n\nradius=radius||10;\nradials=radials||16;\ncircles=circles||8;\ndivisions=divisions||64;\ncolor1=new Color(color1!==undefined?color1:0x444444);\ncolor2=new Color(color2!==undefined?color2:0x888888);\n\nvar vertices=[];\nvar colors=[];\n\nvar x,z;\nvar v,i,j,r,color;\n\n// create the radials\n\nfor(i=0;i<=radials;i++){\n\nv=i/radials*(Math.PI*2);\n\nx=Math.sin(v)*radius;\nz=Math.cos(v)*radius;\n\nvertices.push(0,0,0);\nvertices.push(x,0,z);\n\ncolor=i&1?color1:color2;\n\ncolors.push(color.r,color.g,color.b);\ncolors.push(color.r,color.g,color.b);\n\n}\n\n// create the circles\n\nfor(i=0;i<=circles;i++){\n\ncolor=i&1?color1:color2;\n\nr=radius-radius/circles*i;\n\nfor(j=0;j<divisions;j++){\n\n// first vertex\n\nv=j/divisions*(Math.PI*2);\n\nx=Math.sin(v)*r;\nz=Math.cos(v)*r;\n\nvertices.push(x,0,z);\ncolors.push(color.r,color.g,color.b);\n\n// second vertex\n\nv=(j+1)/divisions*(Math.PI*2);\n\nx=Math.sin(v)*r;\nz=Math.cos(v)*r;\n\nvertices.push(x,0,z);\ncolors.push(color.r,color.g,color.b);\n\n}\n\n}\n\nvar geometry=new BufferGeometry();\ngeometry.addAttribute('position',new Float32BufferAttribute(vertices,3));\ngeometry.addAttribute('color',new Float32BufferAttribute(colors,3));\n\nvar material=new LineBasicMaterial({vertexColors:VertexColors});\n\nLineSegments.call(this,geometry,material);\n\n}\n\nPolarGridHelper.prototype=Object.create(LineSegments.prototype);\nPolarGridHelper.prototype.constructor=PolarGridHelper;\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t*/\n\nfunction FaceNormalsHelper(object,size,hex,linewidth){\n\n// FaceNormalsHelper only supports THREE.Geometry\n\nthis.object=object;\n\nthis.size=size!==undefined?size:1;\n\nvar color=hex!==undefined?hex:0xffff00;\n\nvar width=linewidth!==undefined?linewidth:1;\n\n//\n\nvar nNormals=0;\n\nvar objGeometry=this.object.geometry;\n\nif(objGeometry&&objGeometry.isGeometry){\n\nnNormals=objGeometry.faces.length;\n\n}else{\n\nconsole.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');\n\n}\n\n//\n\nvar geometry=new BufferGeometry();\n\nvar positions=new Float32BufferAttribute(nNormals*2*3,3);\n\ngeometry.addAttribute('position',positions);\n\nLineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));\n\n//\n\nthis.matrixAutoUpdate=false;\nthis.update();\n\n}\n\nFaceNormalsHelper.prototype=Object.create(LineSegments.prototype);\nFaceNormalsHelper.prototype.constructor=FaceNormalsHelper;\n\nFaceNormalsHelper.prototype.update=function(){\n\nvar v1=new Vector3();\nvar v2=new Vector3();\nvar normalMatrix=new Matrix3();\n\nreturn function update(){\n\nthis.object.updateMatrixWorld(true);\n\nnormalMatrix.getNormalMatrix(this.object.matrixWorld);\n\nvar matrixWorld=this.object.matrixWorld;\n\nvar position=this.geometry.attributes.position;\n\n//\n\nvar objGeometry=this.object.geometry;\n\nvar vertices=objGeometry.vertices;\n\nvar faces=objGeometry.faces;\n\nvar idx=0;\n\nfor(var i=0,l=faces.length;i<l;i++){\n\nvar face=faces[i];\n\nvar normal=face.normal;\n\nv1.copy(vertices[face.a]).\nadd(vertices[face.b]).\nadd(vertices[face.c]).\ndivideScalar(3).\napplyMatrix4(matrixWorld);\n\nv2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);\n\nposition.setXYZ(idx,v1.x,v1.y,v1.z);\n\nidx=idx+1;\n\nposition.setXYZ(idx,v2.x,v2.y,v2.z);\n\nidx=idx+1;\n\n}\n\nposition.needsUpdate=true;\n\nreturn this;\n\n};\n\n}();\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author mrdoob / http://mrdoob.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t */\n\nfunction DirectionalLightHelper(light,size){\n\nObject3D.call(this);\n\nthis.light=light;\nthis.light.updateMatrixWorld();\n\nthis.matrix=light.matrixWorld;\nthis.matrixAutoUpdate=false;\n\nif(size===undefined)size=1;\n\nvar geometry=new BufferGeometry();\ngeometry.addAttribute('position',new Float32BufferAttribute([\n-size,size,0,\nsize,size,0,\nsize,-size,0,\n-size,-size,0,\n-size,size,0],\n3));\n\nvar material=new LineBasicMaterial({fog:false});\n\nthis.add(new Line(geometry,material));\n\ngeometry=new BufferGeometry();\ngeometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,0,1],3));\n\nthis.add(new Line(geometry,material));\n\nthis.update();\n\n}\n\nDirectionalLightHelper.prototype=Object.create(Object3D.prototype);\nDirectionalLightHelper.prototype.constructor=DirectionalLightHelper;\n\nDirectionalLightHelper.prototype.dispose=function(){\n\nvar lightPlane=this.children[0];\nvar targetLine=this.children[1];\n\nlightPlane.geometry.dispose();\nlightPlane.material.dispose();\ntargetLine.geometry.dispose();\ntargetLine.material.dispose();\n\n};\n\nDirectionalLightHelper.prototype.update=function(){\n\nvar v1=new Vector3();\nvar v2=new Vector3();\nvar v3=new Vector3();\n\nreturn function update(){\n\nv1.setFromMatrixPosition(this.light.matrixWorld);\nv2.setFromMatrixPosition(this.light.target.matrixWorld);\nv3.subVectors(v2,v1);\n\nvar lightPlane=this.children[0];\nvar targetLine=this.children[1];\n\nlightPlane.lookAt(v3);\nlightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);\n\ntargetLine.lookAt(v3);\ntargetLine.scale.z=v3.length();\n\n};\n\n}();\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author Mugen87 / https://github.com/Mugen87\n\t *\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\nfunction CameraHelper(camera){\n\nvar geometry=new BufferGeometry();\nvar material=new LineBasicMaterial({color:0xffffff,vertexColors:FaceColors});\n\nvar vertices=[];\nvar colors=[];\n\nvar pointMap={};\n\n// colors\n\nvar colorFrustum=new Color(0xffaa00);\nvar colorCone=new Color(0xff0000);\nvar colorUp=new Color(0x00aaff);\nvar colorTarget=new Color(0xffffff);\nvar colorCross=new Color(0x333333);\n\n// near\n\naddLine(\"n1\",\"n2\",colorFrustum);\naddLine(\"n2\",\"n4\",colorFrustum);\naddLine(\"n4\",\"n3\",colorFrustum);\naddLine(\"n3\",\"n1\",colorFrustum);\n\n// far\n\naddLine(\"f1\",\"f2\",colorFrustum);\naddLine(\"f2\",\"f4\",colorFrustum);\naddLine(\"f4\",\"f3\",colorFrustum);\naddLine(\"f3\",\"f1\",colorFrustum);\n\n// sides\n\naddLine(\"n1\",\"f1\",colorFrustum);\naddLine(\"n2\",\"f2\",colorFrustum);\naddLine(\"n3\",\"f3\",colorFrustum);\naddLine(\"n4\",\"f4\",colorFrustum);\n\n// cone\n\naddLine(\"p\",\"n1\",colorCone);\naddLine(\"p\",\"n2\",colorCone);\naddLine(\"p\",\"n3\",colorCone);\naddLine(\"p\",\"n4\",colorCone);\n\n// up\n\naddLine(\"u1\",\"u2\",colorUp);\naddLine(\"u2\",\"u3\",colorUp);\naddLine(\"u3\",\"u1\",colorUp);\n\n// target\n\naddLine(\"c\",\"t\",colorTarget);\naddLine(\"p\",\"c\",colorCross);\n\n// cross\n\naddLine(\"cn1\",\"cn2\",colorCross);\naddLine(\"cn3\",\"cn4\",colorCross);\n\naddLine(\"cf1\",\"cf2\",colorCross);\naddLine(\"cf3\",\"cf4\",colorCross);\n\nfunction addLine(a,b,color){\n\naddPoint(a,color);\naddPoint(b,color);\n\n}\n\nfunction addPoint(id,color){\n\nvertices.push(0,0,0);\ncolors.push(color.r,color.g,color.b);\n\nif(pointMap[id]===undefined){\n\npointMap[id]=[];\n\n}\n\npointMap[id].push(vertices.length/3-1);\n\n}\n\ngeometry.addAttribute('position',new Float32BufferAttribute(vertices,3));\ngeometry.addAttribute('color',new Float32BufferAttribute(colors,3));\n\nLineSegments.call(this,geometry,material);\n\nthis.camera=camera;\nif(this.camera.updateProjectionMatrix)this.camera.updateProjectionMatrix();\n\nthis.matrix=camera.matrixWorld;\nthis.matrixAutoUpdate=false;\n\nthis.pointMap=pointMap;\n\nthis.update();\n\n}\n\nCameraHelper.prototype=Object.create(LineSegments.prototype);\nCameraHelper.prototype.constructor=CameraHelper;\n\nCameraHelper.prototype.update=function(){\n\nvar geometry,pointMap;\n\nvar vector=new Vector3();\nvar camera=new Camera();\n\nfunction setPoint(point,x,y,z){\n\nvector.set(x,y,z).unproject(camera);\n\nvar points=pointMap[point];\n\nif(points!==undefined){\n\nvar position=geometry.getAttribute('position');\n\nfor(var i=0,l=points.length;i<l;i++){\n\nposition.setXYZ(points[i],vector.x,vector.y,vector.z);\n\n}\n\n}\n\n}\n\nreturn function update(){\n\ngeometry=this.geometry;\npointMap=this.pointMap;\n\nvar w=1,h=1;\n\n// we need just camera projection matrix\n// world matrix must be identity\n\ncamera.projectionMatrix.copy(this.camera.projectionMatrix);\n\n// center / target\n\nsetPoint(\"c\",0,0,-1);\nsetPoint(\"t\",0,0,1);\n\n// near\n\nsetPoint(\"n1\",-w,-h,-1);\nsetPoint(\"n2\",w,-h,-1);\nsetPoint(\"n3\",-w,h,-1);\nsetPoint(\"n4\",w,h,-1);\n\n// far\n\nsetPoint(\"f1\",-w,-h,1);\nsetPoint(\"f2\",w,-h,1);\nsetPoint(\"f3\",-w,h,1);\nsetPoint(\"f4\",w,h,1);\n\n// up\n\nsetPoint(\"u1\",w*0.7,h*1.1,-1);\nsetPoint(\"u2\",-w*0.7,h*1.1,-1);\nsetPoint(\"u3\",0,h*2,-1);\n\n// cross\n\nsetPoint(\"cf1\",-w,0,1);\nsetPoint(\"cf2\",w,0,1);\nsetPoint(\"cf3\",0,-h,1);\nsetPoint(\"cf4\",0,h,1);\n\nsetPoint(\"cn1\",-w,0,-1);\nsetPoint(\"cn2\",w,0,-1);\nsetPoint(\"cn3\",0,-h,-1);\nsetPoint(\"cn4\",0,h,-1);\n\ngeometry.getAttribute('position').needsUpdate=true;\n\n};\n\n}();\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction BoxHelper(object,color){\n\nif(color===undefined)color=0xffff00;\n\nvar indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);\nvar positions=new Float32Array(8*3);\n\nvar geometry=new BufferGeometry();\ngeometry.setIndex(new BufferAttribute(indices,1));\ngeometry.addAttribute('position',new BufferAttribute(positions,3));\n\nLineSegments.call(this,geometry,new LineBasicMaterial({color:color}));\n\nif(object!==undefined){\n\nthis.update(object);\n\n}\n\n}\n\nBoxHelper.prototype=Object.create(LineSegments.prototype);\nBoxHelper.prototype.constructor=BoxHelper;\n\nBoxHelper.prototype.update=function(){\n\nvar box=new Box3();\n\nreturn function update(object){\n\nif(object&&object.isBox3){\n\nbox.copy(object);\n\n}else{\n\nbox.setFromObject(object);\n\n}\n\nif(box.isEmpty())return;\n\nvar min=box.min;\nvar max=box.max;\n\n/*\n\t\t\t  5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\n\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\nvar position=this.geometry.attributes.position;\nvar array=position.array;\n\narray[0]=max.x;array[1]=max.y;array[2]=max.z;\narray[3]=min.x;array[4]=max.y;array[5]=max.z;\narray[6]=min.x;array[7]=min.y;array[8]=max.z;\narray[9]=max.x;array[10]=min.y;array[11]=max.z;\narray[12]=max.x;array[13]=max.y;array[14]=min.z;\narray[15]=min.x;array[16]=max.y;array[17]=min.z;\narray[18]=min.x;array[19]=min.y;array[20]=min.z;\narray[21]=max.x;array[22]=min.y;array[23]=min.z;\n\nposition.needsUpdate=true;\n\nthis.geometry.computeBoundingSphere();\n\n};\n\n}();\n\n/**\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author zz85 / http://github.com/zz85\n\t * @author bhouston / http://clara.io\n\t *\n\t * Creates an arrow for visualizing directions\n\t *\n\t * Parameters:\n\t *  dir - Vector3\n\t *  origin - Vector3\n\t *  length - Number\n\t *  color - color in hex value\n\t *  headLength - Number\n\t *  headWidth - Number\n\t */\n\nvar lineGeometry;\nvar coneGeometry;\n\nfunction ArrowHelper(dir,origin,length,color,headLength,headWidth){\n\n// dir is assumed to be normalized\n\nObject3D.call(this);\n\nif(color===undefined)color=0xffff00;\nif(length===undefined)length=1;\nif(headLength===undefined)headLength=0.2*length;\nif(headWidth===undefined)headWidth=0.2*headLength;\n\nif(lineGeometry===undefined){\n\nlineGeometry=new BufferGeometry();\nlineGeometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,1,0],3));\n\nconeGeometry=new CylinderBufferGeometry(0,0.5,1,5,1);\nconeGeometry.translate(0,-0.5,0);\n\n}\n\nthis.position.copy(origin);\n\nthis.line=new Line(lineGeometry,new LineBasicMaterial({color:color}));\nthis.line.matrixAutoUpdate=false;\nthis.add(this.line);\n\nthis.cone=new Mesh(coneGeometry,new MeshBasicMaterial({color:color}));\nthis.cone.matrixAutoUpdate=false;\nthis.add(this.cone);\n\nthis.setDirection(dir);\nthis.setLength(length,headLength,headWidth);\n\n}\n\nArrowHelper.prototype=Object.create(Object3D.prototype);\nArrowHelper.prototype.constructor=ArrowHelper;\n\nArrowHelper.prototype.setDirection=function(){\n\nvar axis=new Vector3();\nvar radians;\n\nreturn function setDirection(dir){\n\n// dir is assumed to be normalized\n\nif(dir.y>0.99999){\n\nthis.quaternion.set(0,0,0,1);\n\n}else if(dir.y<-0.99999){\n\nthis.quaternion.set(1,0,0,0);\n\n}else{\n\naxis.set(dir.z,0,-dir.x).normalize();\n\nradians=Math.acos(dir.y);\n\nthis.quaternion.setFromAxisAngle(axis,radians);\n\n}\n\n};\n\n}();\n\nArrowHelper.prototype.setLength=function(length,headLength,headWidth){\n\nif(headLength===undefined)headLength=0.2*length;\nif(headWidth===undefined)headWidth=0.2*headLength;\n\nthis.line.scale.set(1,Math.max(0,length-headLength),1);\nthis.line.updateMatrix();\n\nthis.cone.scale.set(headWidth,headLength,headWidth);\nthis.cone.position.y=length;\nthis.cone.updateMatrix();\n\n};\n\nArrowHelper.prototype.setColor=function(color){\n\nthis.line.material.color.copy(color);\nthis.cone.material.color.copy(color);\n\n};\n\n/**\n\t * @author sroucheray / http://sroucheray.org/\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction AxisHelper(size){\n\nsize=size||1;\n\nvar vertices=[\n0,0,0,size,0,0,\n0,0,0,0,size,0,\n0,0,0,0,0,size];\n\n\nvar colors=[\n1,0,0,1,0.6,0,\n0,1,0,0.6,1,0,\n0,0,1,0,0.6,1];\n\n\nvar geometry=new BufferGeometry();\ngeometry.addAttribute('position',new Float32BufferAttribute(vertices,3));\ngeometry.addAttribute('color',new Float32BufferAttribute(colors,3));\n\nvar material=new LineBasicMaterial({vertexColors:VertexColors});\n\nLineSegments.call(this,geometry,material);\n\n}\n\nAxisHelper.prototype=Object.create(LineSegments.prototype);\nAxisHelper.prototype.constructor=AxisHelper;\n\n/**\n\t * @author zz85 https://github.com/zz85\n\t *\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\n/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\nfunction CubicPoly(){\n\nvar c0=0,c1=0,c2=0,c3=0;\n\n/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *   p(0) = x0, p(1) = x1\n\t\t *  and\n\t\t *   p'(0) = t0, p'(1) = t1.\n\t\t */\nfunction init(x0,x1,t0,t1){\n\nc0=x0;\nc1=t0;\nc2=-3*x0+3*x1-2*t0-t1;\nc3=2*x0-2*x1+t0+t1;\n\n}\n\nreturn{\n\ninitCatmullRom:function initCatmullRom(x0,x1,x2,x3,tension){\n\ninit(x1,x2,tension*(x2-x0),tension*(x3-x1));\n\n},\n\ninitNonuniformCatmullRom:function initNonuniformCatmullRom(x0,x1,x2,x3,dt0,dt1,dt2){\n\n// compute tangents when parameterized in [t1,t2]\nvar t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;\nvar t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;\n\n// rescale tangents for parametrization in [0,1]\nt1*=dt1;\nt2*=dt1;\n\ninit(x1,x2,t1,t2);\n\n},\n\ncalc:function calc(t){\n\nvar t2=t*t;\nvar t3=t2*t;\nreturn c0+c1*t+c2*t2+c3*t3;\n\n}};\n\n\n\n}\n\n//\n\nvar tmp=new Vector3();\nvar px=new CubicPoly();\nvar py=new CubicPoly();\nvar pz=new CubicPoly();\n\nfunction CatmullRomCurve3(p/* array of Vector3 */){\n\nthis.points=p||[];\nthis.closed=false;\n\n}\n\nCatmullRomCurve3.prototype=Object.create(Curve.prototype);\nCatmullRomCurve3.prototype.constructor=CatmullRomCurve3;\n\nCatmullRomCurve3.prototype.getPoint=function(t){\n\nvar points=this.points;\nvar l=points.length;\n\nif(l<2)console.log('duh, you need at least 2 points');\n\nvar point=(l-(this.closed?0:1))*t;\nvar intPoint=Math.floor(point);\nvar weight=point-intPoint;\n\nif(this.closed){\n\nintPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/points.length)+1)*points.length;\n\n}else if(weight===0&&intPoint===l-1){\n\nintPoint=l-2;\nweight=1;\n\n}\n\nvar p0,p1,p2,p3;// 4 points\n\nif(this.closed||intPoint>0){\n\np0=points[(intPoint-1)%l];\n\n}else{\n\n// extrapolate first point\ntmp.subVectors(points[0],points[1]).add(points[0]);\np0=tmp;\n\n}\n\np1=points[intPoint%l];\np2=points[(intPoint+1)%l];\n\nif(this.closed||intPoint+2<l){\n\np3=points[(intPoint+2)%l];\n\n}else{\n\n// extrapolate last point\ntmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);\np3=tmp;\n\n}\n\nif(this.type===undefined||this.type==='centripetal'||this.type==='chordal'){\n\n// init Centripetal / Chordal Catmull-Rom\nvar pow=this.type==='chordal'?0.5:0.25;\nvar dt0=Math.pow(p0.distanceToSquared(p1),pow);\nvar dt1=Math.pow(p1.distanceToSquared(p2),pow);\nvar dt2=Math.pow(p2.distanceToSquared(p3),pow);\n\n// safety check for repeated points\nif(dt1<1e-4)dt1=1.0;\nif(dt0<1e-4)dt0=dt1;\nif(dt2<1e-4)dt2=dt1;\n\npx.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);\npy.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);\npz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);\n\n}else if(this.type==='catmullrom'){\n\nvar tension=this.tension!==undefined?this.tension:0.5;\npx.initCatmullRom(p0.x,p1.x,p2.x,p3.x,tension);\npy.initCatmullRom(p0.y,p1.y,p2.y,p3.y,tension);\npz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,tension);\n\n}\n\nreturn new Vector3(px.calc(weight),py.calc(weight),pz.calc(weight));\n\n};\n\nfunction CubicBezierCurve3(v0,v1,v2,v3){\n\nthis.v0=v0;\nthis.v1=v1;\nthis.v2=v2;\nthis.v3=v3;\n\n}\n\nCubicBezierCurve3.prototype=Object.create(Curve.prototype);\nCubicBezierCurve3.prototype.constructor=CubicBezierCurve3;\n\nCubicBezierCurve3.prototype.getPoint=function(t){\n\nvar v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;\n\nreturn new Vector3(\nCubicBezier(t,v0.x,v1.x,v2.x,v3.x),\nCubicBezier(t,v0.y,v1.y,v2.y,v3.y),\nCubicBezier(t,v0.z,v1.z,v2.z,v3.z));\n\n\n};\n\nfunction QuadraticBezierCurve3(v0,v1,v2){\n\nthis.v0=v0;\nthis.v1=v1;\nthis.v2=v2;\n\n}\n\nQuadraticBezierCurve3.prototype=Object.create(Curve.prototype);\nQuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3;\n\nQuadraticBezierCurve3.prototype.getPoint=function(t){\n\nvar v0=this.v0,v1=this.v1,v2=this.v2;\n\nreturn new Vector3(\nQuadraticBezier(t,v0.x,v1.x,v2.x),\nQuadraticBezier(t,v0.y,v1.y,v2.y),\nQuadraticBezier(t,v0.z,v1.z,v2.z));\n\n\n};\n\nfunction LineCurve3(v1,v2){\n\nthis.v1=v1;\nthis.v2=v2;\n\n}\n\nLineCurve3.prototype=Object.create(Curve.prototype);\nLineCurve3.prototype.constructor=LineCurve3;\n\nLineCurve3.prototype.getPoint=function(t){\n\nif(t===1){\n\nreturn this.v2.clone();\n\n}\n\nvar vector=new Vector3();\n\nvector.subVectors(this.v2,this.v1);// diff\nvector.multiplyScalar(t);\nvector.add(this.v1);\n\nreturn vector;\n\n};\n\nfunction ArcCurve(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){\n\nEllipseCurve.call(this,aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);\n\n}\n\nArcCurve.prototype=Object.create(EllipseCurve.prototype);\nArcCurve.prototype.constructor=ArcCurve;\n\n/**\n\t * @author alteredq / http://alteredqualia.com/\n\t */\n\nvar SceneUtils={\n\ncreateMultiMaterialObject:function createMultiMaterialObject(geometry,materials){\n\nvar group=new Group();\n\nfor(var i=0,l=materials.length;i<l;i++){\n\ngroup.add(new Mesh(geometry,materials[i]));\n\n}\n\nreturn group;\n\n},\n\ndetach:function detach(child,parent,scene){\n\nchild.applyMatrix(parent.matrixWorld);\nparent.remove(child);\nscene.add(child);\n\n},\n\nattach:function attach(child,scene,parent){\n\nvar matrixWorldInverse=new Matrix4();\nmatrixWorldInverse.getInverse(parent.matrixWorld);\nchild.applyMatrix(matrixWorldInverse);\n\nscene.remove(child);\nparent.add(child);\n\n}};\n\n\n\n/**\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\nfunction Face4(a,b,c,d,normal,color,materialIndex){\n\nconsole.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');\nreturn new Face3(a,b,c,normal,color,materialIndex);\n\n}\n\nvar LineStrip=0;\n\nvar LinePieces=1;\n\nfunction MeshFaceMaterial(materials){\n\nconsole.warn('THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.');\nreturn new MultiMaterial(materials);\n\n}\n\nfunction PointCloud(geometry,material){\n\nconsole.warn('THREE.PointCloud has been renamed to THREE.Points.');\nreturn new Points(geometry,material);\n\n}\n\nfunction Particle(material){\n\nconsole.warn('THREE.Particle has been renamed to THREE.Sprite.');\nreturn new Sprite(material);\n\n}\n\nfunction ParticleSystem(geometry,material){\n\nconsole.warn('THREE.ParticleSystem has been renamed to THREE.Points.');\nreturn new Points(geometry,material);\n\n}\n\nfunction PointCloudMaterial(parameters){\n\nconsole.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');\nreturn new PointsMaterial(parameters);\n\n}\n\nfunction ParticleBasicMaterial(parameters){\n\nconsole.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');\nreturn new PointsMaterial(parameters);\n\n}\n\nfunction ParticleSystemMaterial(parameters){\n\nconsole.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');\nreturn new PointsMaterial(parameters);\n\n}\n\nfunction Vertex(x,y,z){\n\nconsole.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');\nreturn new Vector3(x,y,z);\n\n}\n\n//\n\nfunction DynamicBufferAttribute(array,itemSize){\n\nconsole.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');\nreturn new BufferAttribute(array,itemSize).setDynamic(true);\n\n}\n\nfunction Int8Attribute(array,itemSize){\n\nconsole.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');\nreturn new Int8BufferAttribute(array,itemSize);\n\n}\n\nfunction Uint8Attribute(array,itemSize){\n\nconsole.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');\nreturn new Uint8BufferAttribute(array,itemSize);\n\n}\n\nfunction Uint8ClampedAttribute(array,itemSize){\n\nconsole.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');\nreturn new Uint8ClampedBufferAttribute(array,itemSize);\n\n}\n\nfunction Int16Attribute(array,itemSize){\n\nconsole.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');\nreturn new Int16BufferAttribute(array,itemSize);\n\n}\n\nfunction Uint16Attribute(array,itemSize){\n\nconsole.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');\nreturn new Uint16BufferAttribute(array,itemSize);\n\n}\n\nfunction Int32Attribute(array,itemSize){\n\nconsole.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');\nreturn new Int32BufferAttribute(array,itemSize);\n\n}\n\nfunction Uint32Attribute(array,itemSize){\n\nconsole.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');\nreturn new Uint32BufferAttribute(array,itemSize);\n\n}\n\nfunction Float32Attribute(array,itemSize){\n\nconsole.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');\nreturn new Float32BufferAttribute(array,itemSize);\n\n}\n\nfunction Float64Attribute(array,itemSize){\n\nconsole.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');\nreturn new Float64BufferAttribute(array,itemSize);\n\n}\n\n//\n\nCurve.create=function(construct,getPoint){\n\nconsole.log('THREE.Curve.create() has been deprecated');\n\nconstruct.prototype=Object.create(Curve.prototype);\nconstruct.prototype.constructor=construct;\nconstruct.prototype.getPoint=getPoint;\n\nreturn construct;\n\n};\n\n//\n\nfunction ClosedSplineCurve3(points){\n\nconsole.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');\n\nCatmullRomCurve3.call(this,points);\nthis.type='catmullrom';\nthis.closed=true;\n\n}\n\nClosedSplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype);\n\n//\n\nfunction SplineCurve3(points){\n\nconsole.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');\n\nCatmullRomCurve3.call(this,points);\nthis.type='catmullrom';\n\n}\n\nSplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype);\n\n//\n\nfunction Spline(points){\n\nconsole.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');\n\nCatmullRomCurve3.call(this,points);\nthis.type='catmullrom';\n\n}\n\nSpline.prototype=Object.create(CatmullRomCurve3.prototype);\n\nObject.assign(Spline.prototype,{\n\ninitFromArray:function initFromArray(a){\n\nconsole.error('THREE.Spline: .initFromArray() has been removed.');\n\n},\ngetControlPointsArray:function getControlPointsArray(optionalTarget){\n\nconsole.error('THREE.Spline: .getControlPointsArray() has been removed.');\n\n},\nreparametrizeByArcLength:function reparametrizeByArcLength(samplingCoef){\n\nconsole.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');\n\n}});\n\n\n\n//\nfunction BoundingBoxHelper(object,color){\n\nconsole.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');\nreturn new BoxHelper(object,color);\n\n}\n\nfunction EdgesHelper(object,hex){\n\nconsole.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');\nreturn new LineSegments(new EdgesGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));\n\n}\n\nGridHelper.prototype.setColors=function(){\n\nconsole.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');\n\n};\n\nfunction WireframeHelper(object,hex){\n\nconsole.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');\nreturn new LineSegments(new WireframeGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));\n\n}\n\n//\n\nfunction XHRLoader(manager){\n\nconsole.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');\nreturn new FileLoader(manager);\n\n}\n\nfunction BinaryTextureLoader(manager){\n\nconsole.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');\nreturn new DataTextureLoader(manager);\n\n}\n\n//\n\nObject.assign(Box2.prototype,{\n\ncenter:function center(optionalTarget){\n\nconsole.warn('THREE.Box2: .center() has been renamed to .getCenter().');\nreturn this.getCenter(optionalTarget);\n\n},\nempty:function empty(){\n\nconsole.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');\nreturn this.isEmpty();\n\n},\nisIntersectionBox:function isIntersectionBox(box){\n\nconsole.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');\nreturn this.intersectsBox(box);\n\n},\nsize:function size(optionalTarget){\n\nconsole.warn('THREE.Box2: .size() has been renamed to .getSize().');\nreturn this.getSize(optionalTarget);\n\n}});\n\n\nObject.assign(Box3.prototype,{\n\ncenter:function center(optionalTarget){\n\nconsole.warn('THREE.Box3: .center() has been renamed to .getCenter().');\nreturn this.getCenter(optionalTarget);\n\n},\nempty:function empty(){\n\nconsole.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');\nreturn this.isEmpty();\n\n},\nisIntersectionBox:function isIntersectionBox(box){\n\nconsole.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');\nreturn this.intersectsBox(box);\n\n},\nisIntersectionSphere:function isIntersectionSphere(sphere){\n\nconsole.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');\nreturn this.intersectsSphere(sphere);\n\n},\nsize:function size(optionalTarget){\n\nconsole.warn('THREE.Box3: .size() has been renamed to .getSize().');\nreturn this.getSize(optionalTarget);\n\n}});\n\n\nLine3.prototype.center=function(optionalTarget){\n\nconsole.warn('THREE.Line3: .center() has been renamed to .getCenter().');\nreturn this.getCenter(optionalTarget);\n\n};\n\n_Math.random16=function(){\n\nconsole.warn('THREE.Math.random16() has been deprecated. Use Math.random() instead.');\nreturn Math.random();\n\n};\n\nObject.assign(Matrix3.prototype,{\n\nflattenToArrayOffset:function flattenToArrayOffset(array,offset){\n\nconsole.warn(\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\");\nreturn this.toArray(array,offset);\n\n},\nmultiplyVector3:function multiplyVector3(vector){\n\nconsole.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\nreturn vector.applyMatrix3(this);\n\n},\nmultiplyVector3Array:function multiplyVector3Array(a){\n\nconsole.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');\nreturn this.applyToVector3Array(a);\n\n},\napplyToBuffer:function applyToBuffer(buffer,offset,length){\n\nconsole.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');\nreturn this.applyToBufferAttribute(buffer);\n\n},\napplyToVector3Array:function applyToVector3Array(array,offset,length){\n\nconsole.error('THREE.Matrix3: .applyToVector3Array() has been removed.');\n\n}});\n\n\n\nObject.assign(Matrix4.prototype,{\n\nextractPosition:function extractPosition(m){\n\nconsole.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\nreturn this.copyPosition(m);\n\n},\nflattenToArrayOffset:function flattenToArrayOffset(array,offset){\n\nconsole.warn(\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\");\nreturn this.toArray(array,offset);\n\n},\ngetPosition:function(){\n\nvar v1;\n\nreturn function getPosition(){\n\nif(v1===undefined)v1=new Vector3();\nconsole.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\nreturn v1.setFromMatrixColumn(this,3);\n\n};\n\n}(),\nsetRotationFromQuaternion:function setRotationFromQuaternion(q){\n\nconsole.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\nreturn this.makeRotationFromQuaternion(q);\n\n},\nmultiplyVector3:function multiplyVector3(vector){\n\nconsole.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');\nreturn vector.applyMatrix4(this);\n\n},\nmultiplyVector4:function multiplyVector4(vector){\n\nconsole.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\nreturn vector.applyMatrix4(this);\n\n},\nmultiplyVector3Array:function multiplyVector3Array(a){\n\nconsole.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');\nreturn this.applyToVector3Array(a);\n\n},\nrotateAxis:function rotateAxis(v){\n\nconsole.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\nv.transformDirection(this);\n\n},\ncrossVector:function crossVector(vector){\n\nconsole.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\nreturn vector.applyMatrix4(this);\n\n},\ntranslate:function translate(){\n\nconsole.error('THREE.Matrix4: .translate() has been removed.');\n\n},\nrotateX:function rotateX(){\n\nconsole.error('THREE.Matrix4: .rotateX() has been removed.');\n\n},\nrotateY:function rotateY(){\n\nconsole.error('THREE.Matrix4: .rotateY() has been removed.');\n\n},\nrotateZ:function rotateZ(){\n\nconsole.error('THREE.Matrix4: .rotateZ() has been removed.');\n\n},\nrotateByAxis:function rotateByAxis(){\n\nconsole.error('THREE.Matrix4: .rotateByAxis() has been removed.');\n\n},\napplyToBuffer:function applyToBuffer(buffer,offset,length){\n\nconsole.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');\nreturn this.applyToBufferAttribute(buffer);\n\n},\napplyToVector3Array:function applyToVector3Array(array,offset,length){\n\nconsole.error('THREE.Matrix4: .applyToVector3Array() has been removed.');\n\n},\nmakeFrustum:function makeFrustum(left,right,bottom,top,near,far){\n\nconsole.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');\nreturn this.makePerspective(left,right,top,bottom,near,far);\n\n}});\n\n\n\nPlane.prototype.isIntersectionLine=function(line){\n\nconsole.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');\nreturn this.intersectsLine(line);\n\n};\n\nQuaternion.prototype.multiplyVector3=function(vector){\n\nconsole.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\nreturn vector.applyQuaternion(this);\n\n};\n\nObject.assign(Ray.prototype,{\n\nisIntersectionBox:function isIntersectionBox(box){\n\nconsole.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');\nreturn this.intersectsBox(box);\n\n},\nisIntersectionPlane:function isIntersectionPlane(plane){\n\nconsole.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');\nreturn this.intersectsPlane(plane);\n\n},\nisIntersectionSphere:function isIntersectionSphere(sphere){\n\nconsole.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');\nreturn this.intersectsSphere(sphere);\n\n}});\n\n\n\nObject.assign(Shape.prototype,{\n\nextrude:function extrude(options){\n\nconsole.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');\nreturn new ExtrudeGeometry(this,options);\n\n},\nmakeGeometry:function makeGeometry(options){\n\nconsole.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');\nreturn new ShapeGeometry(this,options);\n\n}});\n\n\n\nObject.assign(Vector2.prototype,{\n\nfromAttribute:function fromAttribute(attribute,index,offset){\n\nconsole.error('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');\nreturn this.fromBufferAttribute(attribute,index,offset);\n\n}});\n\n\n\nObject.assign(Vector3.prototype,{\n\nsetEulerFromRotationMatrix:function setEulerFromRotationMatrix(){\n\nconsole.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\n\n},\nsetEulerFromQuaternion:function setEulerFromQuaternion(){\n\nconsole.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\n\n},\ngetPositionFromMatrix:function getPositionFromMatrix(m){\n\nconsole.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\nreturn this.setFromMatrixPosition(m);\n\n},\ngetScaleFromMatrix:function getScaleFromMatrix(m){\n\nconsole.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\nreturn this.setFromMatrixScale(m);\n\n},\ngetColumnFromMatrix:function getColumnFromMatrix(index,matrix){\n\nconsole.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\nreturn this.setFromMatrixColumn(matrix,index);\n\n},\napplyProjection:function applyProjection(m){\n\nconsole.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');\nreturn this.applyMatrix4(m);\n\n},\nfromAttribute:function fromAttribute(attribute,index,offset){\n\nconsole.error('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');\nreturn this.fromBufferAttribute(attribute,index,offset);\n\n}});\n\n\n\nObject.assign(Vector4.prototype,{\n\nfromAttribute:function fromAttribute(attribute,index,offset){\n\nconsole.error('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');\nreturn this.fromBufferAttribute(attribute,index,offset);\n\n}});\n\n\n\n//\n\nGeometry.prototype.computeTangents=function(){\n\nconsole.warn('THREE.Geometry: .computeTangents() has been removed.');\n\n};\n\nObject.assign(Object3D.prototype,{\n\ngetChildByName:function getChildByName(name){\n\nconsole.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');\nreturn this.getObjectByName(name);\n\n},\nrenderDepth:function renderDepth(){\n\nconsole.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');\n\n},\ntranslate:function translate(distance,axis){\n\nconsole.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');\nreturn this.translateOnAxis(axis,distance);\n\n}});\n\n\n\nObject.defineProperties(Object3D.prototype,{\n\neulerOrder:{\nget:function get(){\n\nconsole.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\nreturn this.rotation.order;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\nthis.rotation.order=value;\n\n}},\n\nuseQuaternion:{\nget:function get(){\n\nconsole.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n\n},\nset:function set(){\n\nconsole.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n\n}}});\n\n\n\n\nObject.defineProperties(LOD.prototype,{\n\nobjects:{\nget:function get(){\n\nconsole.warn('THREE.LOD: .objects has been renamed to .levels.');\nreturn this.levels;\n\n}}});\n\n\n\n\n//\n\nPerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){\n\nconsole.warn(\"THREE.PerspectiveCamera.setLens is deprecated. \"+\n\"Use .setFocalLength and .filmGauge for a photographic setup.\");\n\nif(filmGauge!==undefined)this.filmGauge=filmGauge;\nthis.setFocalLength(focalLength);\n\n};\n\n//\n\nObject.defineProperties(Light.prototype,{\nonlyShadow:{\nset:function set(){\n\nconsole.warn('THREE.Light: .onlyShadow has been removed.');\n\n}},\n\nshadowCameraFov:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');\nthis.shadow.camera.fov=value;\n\n}},\n\nshadowCameraLeft:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');\nthis.shadow.camera.left=value;\n\n}},\n\nshadowCameraRight:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');\nthis.shadow.camera.right=value;\n\n}},\n\nshadowCameraTop:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');\nthis.shadow.camera.top=value;\n\n}},\n\nshadowCameraBottom:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');\nthis.shadow.camera.bottom=value;\n\n}},\n\nshadowCameraNear:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');\nthis.shadow.camera.near=value;\n\n}},\n\nshadowCameraFar:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');\nthis.shadow.camera.far=value;\n\n}},\n\nshadowCameraVisible:{\nset:function set(){\n\nconsole.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');\n\n}},\n\nshadowBias:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowBias is now .shadow.bias.');\nthis.shadow.bias=value;\n\n}},\n\nshadowDarkness:{\nset:function set(){\n\nconsole.warn('THREE.Light: .shadowDarkness has been removed.');\n\n}},\n\nshadowMapWidth:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');\nthis.shadow.mapSize.width=value;\n\n}},\n\nshadowMapHeight:{\nset:function set(value){\n\nconsole.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');\nthis.shadow.mapSize.height=value;\n\n}}});\n\n\n\n//\n\nObject.defineProperties(BufferAttribute.prototype,{\n\nlength:{\nget:function get(){\n\nconsole.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');\nreturn this.array.length;\n\n}}});\n\n\n\n\nObject.assign(BufferGeometry.prototype,{\n\naddIndex:function addIndex(index){\n\nconsole.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');\nthis.setIndex(index);\n\n},\naddDrawCall:function addDrawCall(start,count,indexOffset){\n\nif(indexOffset!==undefined){\n\nconsole.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');\n\n}\nconsole.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');\nthis.addGroup(start,count);\n\n},\nclearDrawCalls:function clearDrawCalls(){\n\nconsole.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');\nthis.clearGroups();\n\n},\ncomputeTangents:function computeTangents(){\n\nconsole.warn('THREE.BufferGeometry: .computeTangents() has been removed.');\n\n},\ncomputeOffsets:function computeOffsets(){\n\nconsole.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');\n\n}});\n\n\n\nObject.defineProperties(BufferGeometry.prototype,{\n\ndrawcalls:{\nget:function get(){\n\nconsole.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');\nreturn this.groups;\n\n}},\n\noffsets:{\nget:function get(){\n\nconsole.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');\nreturn this.groups;\n\n}}});\n\n\n\n\n//\n\nObject.defineProperties(Uniform.prototype,{\n\ndynamic:{\nset:function set(){\n\nconsole.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');\n\n}},\n\nonUpdate:{\nvalue:function value(){\n\nconsole.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');\nreturn this;\n\n}}});\n\n\n\n\n//\n\nObject.defineProperties(Material.prototype,{\n\nwrapAround:{\nget:function get(){\n\nconsole.warn('THREE.'+this.type+': .wrapAround has been removed.');\n\n},\nset:function set(){\n\nconsole.warn('THREE.'+this.type+': .wrapAround has been removed.');\n\n}},\n\nwrapRGB:{\nget:function get(){\n\nconsole.warn('THREE.'+this.type+': .wrapRGB has been removed.');\nreturn new Color();\n\n}}});\n\n\n\n\nObject.defineProperties(MeshPhongMaterial.prototype,{\n\nmetal:{\nget:function get(){\n\nconsole.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');\nreturn false;\n\n},\nset:function set(){\n\nconsole.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');\n\n}}});\n\n\n\n\nObject.defineProperties(ShaderMaterial.prototype,{\n\nderivatives:{\nget:function get(){\n\nconsole.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\nreturn this.extensions.derivatives;\n\n},\nset:function set(value){\n\nconsole.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\nthis.extensions.derivatives=value;\n\n}}});\n\n\n\n\n//\n\nObject.assign(WebGLRenderer.prototype,{\n\nsupportsFloatTextures:function supportsFloatTextures(){\n\nconsole.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).');\nreturn this.extensions.get('OES_texture_float');\n\n},\nsupportsHalfFloatTextures:function supportsHalfFloatTextures(){\n\nconsole.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).');\nreturn this.extensions.get('OES_texture_half_float');\n\n},\nsupportsStandardDerivatives:function supportsStandardDerivatives(){\n\nconsole.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).');\nreturn this.extensions.get('OES_standard_derivatives');\n\n},\nsupportsCompressedTextureS3TC:function supportsCompressedTextureS3TC(){\n\nconsole.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).');\nreturn this.extensions.get('WEBGL_compressed_texture_s3tc');\n\n},\nsupportsCompressedTexturePVRTC:function supportsCompressedTexturePVRTC(){\n\nconsole.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).');\nreturn this.extensions.get('WEBGL_compressed_texture_pvrtc');\n\n},\nsupportsBlendMinMax:function supportsBlendMinMax(){\n\nconsole.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).');\nreturn this.extensions.get('EXT_blend_minmax');\n\n},\nsupportsVertexTextures:function supportsVertexTextures(){\n\nconsole.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');\nreturn this.capabilities.vertexTextures;\n\n},\nsupportsInstancedArrays:function supportsInstancedArrays(){\n\nconsole.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).');\nreturn this.extensions.get('ANGLE_instanced_arrays');\n\n},\nenableScissorTest:function enableScissorTest(boolean){\n\nconsole.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');\nthis.setScissorTest(boolean);\n\n},\ninitMaterial:function initMaterial(){\n\nconsole.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');\n\n},\naddPrePlugin:function addPrePlugin(){\n\nconsole.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');\n\n},\naddPostPlugin:function addPostPlugin(){\n\nconsole.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');\n\n},\nupdateShadowMap:function updateShadowMap(){\n\nconsole.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');\n\n}});\n\n\n\nObject.defineProperties(WebGLRenderer.prototype,{\n\nshadowMapEnabled:{\nget:function get(){\n\nreturn this.shadowMap.enabled;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');\nthis.shadowMap.enabled=value;\n\n}},\n\nshadowMapType:{\nget:function get(){\n\nreturn this.shadowMap.type;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');\nthis.shadowMap.type=value;\n\n}},\n\nshadowMapCullFace:{\nget:function get(){\n\nreturn this.shadowMap.cullFace;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');\nthis.shadowMap.cullFace=value;\n\n}}});\n\n\n\nObject.defineProperties(WebGLShadowMap.prototype,{\n\ncullFace:{\nget:function get(){\n\nreturn this.renderReverseSided?CullFaceFront:CullFaceBack;\n\n},\nset:function set(cullFace){\n\nvar value=cullFace!==CullFaceBack;\nconsole.warn(\"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \"+value+\".\");\nthis.renderReverseSided=value;\n\n}}});\n\n\n\n\n//\n\nObject.defineProperties(WebGLRenderTarget.prototype,{\n\nwrapS:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\nreturn this.texture.wrapS;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\nthis.texture.wrapS=value;\n\n}},\n\nwrapT:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\nreturn this.texture.wrapT;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\nthis.texture.wrapT=value;\n\n}},\n\nmagFilter:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\nreturn this.texture.magFilter;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\nthis.texture.magFilter=value;\n\n}},\n\nminFilter:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\nreturn this.texture.minFilter;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\nthis.texture.minFilter=value;\n\n}},\n\nanisotropy:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\nreturn this.texture.anisotropy;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\nthis.texture.anisotropy=value;\n\n}},\n\noffset:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\nreturn this.texture.offset;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\nthis.texture.offset=value;\n\n}},\n\nrepeat:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\nreturn this.texture.repeat;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\nthis.texture.repeat=value;\n\n}},\n\nformat:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\nreturn this.texture.format;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\nthis.texture.format=value;\n\n}},\n\ntype:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\nreturn this.texture.type;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\nthis.texture.type=value;\n\n}},\n\ngenerateMipmaps:{\nget:function get(){\n\nconsole.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\nreturn this.texture.generateMipmaps;\n\n},\nset:function set(value){\n\nconsole.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\nthis.texture.generateMipmaps=value;\n\n}}});\n\n\n\n\n//\n\nAudio.prototype.load=function(file){\n\nconsole.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');\nvar scope=this;\nvar audioLoader=new AudioLoader();\naudioLoader.load(file,function(buffer){\n\nscope.setBuffer(buffer);\n\n});\nreturn this;\n\n};\n\nAudioAnalyser.prototype.getData=function(){\n\nconsole.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');\nreturn this.getFrequencyData();\n\n};\n\n//\n\nvar GeometryUtils={\n\nmerge:function merge(geometry1,geometry2,materialIndexOffset){\n\nconsole.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');\nvar matrix;\n\nif(geometry2.isMesh){\n\ngeometry2.matrixAutoUpdate&&geometry2.updateMatrix();\n\nmatrix=geometry2.matrix;\ngeometry2=geometry2.geometry;\n\n}\n\ngeometry1.merge(geometry2,matrix,materialIndexOffset);\n\n},\n\ncenter:function center(geometry){\n\nconsole.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');\nreturn geometry.center();\n\n}};\n\n\n\nvar ImageUtils={\n\ncrossOrigin:undefined,\n\nloadTexture:function loadTexture(url,mapping,onLoad,onError){\n\nconsole.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');\n\nvar loader=new TextureLoader();\nloader.setCrossOrigin(this.crossOrigin);\n\nvar texture=loader.load(url,onLoad,undefined,onError);\n\nif(mapping)texture.mapping=mapping;\n\nreturn texture;\n\n},\n\nloadTextureCube:function loadTextureCube(urls,mapping,onLoad,onError){\n\nconsole.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');\n\nvar loader=new CubeTextureLoader();\nloader.setCrossOrigin(this.crossOrigin);\n\nvar texture=loader.load(urls,onLoad,undefined,onError);\n\nif(mapping)texture.mapping=mapping;\n\nreturn texture;\n\n},\n\nloadCompressedTexture:function loadCompressedTexture(){\n\nconsole.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');\n\n},\n\nloadCompressedTextureCube:function loadCompressedTextureCube(){\n\nconsole.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');\n\n}};\n\n\n\n//\n\nfunction Projector(){\n\nconsole.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');\n\nthis.projectVector=function(vector,camera){\n\nconsole.warn('THREE.Projector: .projectVector() is now vector.project().');\nvector.project(camera);\n\n};\n\nthis.unprojectVector=function(vector,camera){\n\nconsole.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');\nvector.unproject(camera);\n\n};\n\nthis.pickingRay=function(){\n\nconsole.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');\n\n};\n\n}\n\n//\n\nfunction CanvasRenderer(){\n\nconsole.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');\n\nthis.domElement=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');\nthis.clear=function(){};\nthis.render=function(){};\nthis.setClearColor=function(){};\nthis.setSize=function(){};\n\n}\n\nexports.WebGLRenderTargetCube=WebGLRenderTargetCube;\nexports.WebGLRenderTarget=WebGLRenderTarget;\nexports.WebGLRenderer=WebGLRenderer;\nexports.ShaderLib=ShaderLib;\nexports.UniformsLib=UniformsLib;\nexports.UniformsUtils=UniformsUtils;\nexports.ShaderChunk=ShaderChunk;\nexports.FogExp2=FogExp2;\nexports.Fog=Fog;\nexports.Scene=Scene;\nexports.LensFlare=LensFlare;\nexports.Sprite=Sprite;\nexports.LOD=LOD;\nexports.SkinnedMesh=SkinnedMesh;\nexports.Skeleton=Skeleton;\nexports.Bone=Bone;\nexports.Mesh=Mesh;\nexports.LineSegments=LineSegments;\nexports.Line=Line;\nexports.Points=Points;\nexports.Group=Group;\nexports.VideoTexture=VideoTexture;\nexports.DataTexture=DataTexture;\nexports.CompressedTexture=CompressedTexture;\nexports.CubeTexture=CubeTexture;\nexports.CanvasTexture=CanvasTexture;\nexports.DepthTexture=DepthTexture;\nexports.Texture=Texture;\nexports.CompressedTextureLoader=CompressedTextureLoader;\nexports.DataTextureLoader=DataTextureLoader;\nexports.CubeTextureLoader=CubeTextureLoader;\nexports.TextureLoader=TextureLoader;\nexports.ObjectLoader=ObjectLoader;\nexports.MaterialLoader=MaterialLoader;\nexports.BufferGeometryLoader=BufferGeometryLoader;\nexports.DefaultLoadingManager=DefaultLoadingManager;\nexports.LoadingManager=LoadingManager;\nexports.JSONLoader=JSONLoader;\nexports.ImageLoader=ImageLoader;\nexports.FontLoader=FontLoader;\nexports.FileLoader=FileLoader;\nexports.Loader=Loader;\nexports.Cache=Cache;\nexports.AudioLoader=AudioLoader;\nexports.SpotLightShadow=SpotLightShadow;\nexports.SpotLight=SpotLight;\nexports.PointLight=PointLight;\nexports.RectAreaLight=RectAreaLight;\nexports.HemisphereLight=HemisphereLight;\nexports.DirectionalLightShadow=DirectionalLightShadow;\nexports.DirectionalLight=DirectionalLight;\nexports.AmbientLight=AmbientLight;\nexports.LightShadow=LightShadow;\nexports.Light=Light;\nexports.StereoCamera=StereoCamera;\nexports.PerspectiveCamera=PerspectiveCamera;\nexports.OrthographicCamera=OrthographicCamera;\nexports.CubeCamera=CubeCamera;\nexports.Camera=Camera;\nexports.AudioListener=AudioListener;\nexports.PositionalAudio=PositionalAudio;\nexports.AudioContext=AudioContext;\nexports.AudioAnalyser=AudioAnalyser;\nexports.Audio=Audio;\nexports.VectorKeyframeTrack=VectorKeyframeTrack;\nexports.StringKeyframeTrack=StringKeyframeTrack;\nexports.QuaternionKeyframeTrack=QuaternionKeyframeTrack;\nexports.NumberKeyframeTrack=NumberKeyframeTrack;\nexports.ColorKeyframeTrack=ColorKeyframeTrack;\nexports.BooleanKeyframeTrack=BooleanKeyframeTrack;\nexports.PropertyMixer=PropertyMixer;\nexports.PropertyBinding=PropertyBinding;\nexports.KeyframeTrack=KeyframeTrack;\nexports.AnimationUtils=AnimationUtils;\nexports.AnimationObjectGroup=AnimationObjectGroup;\nexports.AnimationMixer=AnimationMixer;\nexports.AnimationClip=AnimationClip;\nexports.Uniform=Uniform;\nexports.InstancedBufferGeometry=InstancedBufferGeometry;\nexports.BufferGeometry=BufferGeometry;\nexports.GeometryIdCount=GeometryIdCount;\nexports.Geometry=Geometry;\nexports.InterleavedBufferAttribute=InterleavedBufferAttribute;\nexports.InstancedInterleavedBuffer=InstancedInterleavedBuffer;\nexports.InterleavedBuffer=InterleavedBuffer;\nexports.InstancedBufferAttribute=InstancedBufferAttribute;\nexports.Face3=Face3;\nexports.Object3D=Object3D;\nexports.Raycaster=Raycaster;\nexports.Layers=Layers;\nexports.EventDispatcher=EventDispatcher;\nexports.Clock=Clock;\nexports.QuaternionLinearInterpolant=QuaternionLinearInterpolant;\nexports.LinearInterpolant=LinearInterpolant;\nexports.DiscreteInterpolant=DiscreteInterpolant;\nexports.CubicInterpolant=CubicInterpolant;\nexports.Interpolant=Interpolant;\nexports.Triangle=Triangle;\nexports.Math=_Math;\nexports.Spherical=Spherical;\nexports.Cylindrical=Cylindrical;\nexports.Plane=Plane;\nexports.Frustum=Frustum;\nexports.Sphere=Sphere;\nexports.Ray=Ray;\nexports.Matrix4=Matrix4;\nexports.Matrix3=Matrix3;\nexports.Box3=Box3;\nexports.Box2=Box2;\nexports.Line3=Line3;\nexports.Euler=Euler;\nexports.Vector4=Vector4;\nexports.Vector3=Vector3;\nexports.Vector2=Vector2;\nexports.Quaternion=Quaternion;\nexports.Color=Color;\nexports.MorphBlendMesh=MorphBlendMesh;\nexports.ImmediateRenderObject=ImmediateRenderObject;\nexports.VertexNormalsHelper=VertexNormalsHelper;\nexports.SpotLightHelper=SpotLightHelper;\nexports.SkeletonHelper=SkeletonHelper;\nexports.PointLightHelper=PointLightHelper;\nexports.RectAreaLightHelper=RectAreaLightHelper;\nexports.HemisphereLightHelper=HemisphereLightHelper;\nexports.GridHelper=GridHelper;\nexports.PolarGridHelper=PolarGridHelper;\nexports.FaceNormalsHelper=FaceNormalsHelper;\nexports.DirectionalLightHelper=DirectionalLightHelper;\nexports.CameraHelper=CameraHelper;\nexports.BoxHelper=BoxHelper;\nexports.ArrowHelper=ArrowHelper;\nexports.AxisHelper=AxisHelper;\nexports.CatmullRomCurve3=CatmullRomCurve3;\nexports.CubicBezierCurve3=CubicBezierCurve3;\nexports.QuadraticBezierCurve3=QuadraticBezierCurve3;\nexports.LineCurve3=LineCurve3;\nexports.ArcCurve=ArcCurve;\nexports.EllipseCurve=EllipseCurve;\nexports.SplineCurve=SplineCurve;\nexports.CubicBezierCurve=CubicBezierCurve;\nexports.QuadraticBezierCurve=QuadraticBezierCurve;\nexports.LineCurve=LineCurve;\nexports.Shape=Shape;\nexports.Path=Path;\nexports.ShapePath=ShapePath;\nexports.Font=Font;\nexports.CurvePath=CurvePath;\nexports.Curve=Curve;\nexports.ShapeUtils=ShapeUtils;\nexports.SceneUtils=SceneUtils;\nexports.WireframeGeometry=WireframeGeometry;\nexports.ParametricGeometry=ParametricGeometry;\nexports.ParametricBufferGeometry=ParametricBufferGeometry;\nexports.TetrahedronGeometry=TetrahedronGeometry;\nexports.TetrahedronBufferGeometry=TetrahedronBufferGeometry;\nexports.OctahedronGeometry=OctahedronGeometry;\nexports.OctahedronBufferGeometry=OctahedronBufferGeometry;\nexports.IcosahedronGeometry=IcosahedronGeometry;\nexports.IcosahedronBufferGeometry=IcosahedronBufferGeometry;\nexports.DodecahedronGeometry=DodecahedronGeometry;\nexports.DodecahedronBufferGeometry=DodecahedronBufferGeometry;\nexports.PolyhedronGeometry=PolyhedronGeometry;\nexports.PolyhedronBufferGeometry=PolyhedronBufferGeometry;\nexports.TubeGeometry=TubeGeometry;\nexports.TubeBufferGeometry=TubeBufferGeometry;\nexports.TorusKnotGeometry=TorusKnotGeometry;\nexports.TorusKnotBufferGeometry=TorusKnotBufferGeometry;\nexports.TorusGeometry=TorusGeometry;\nexports.TorusBufferGeometry=TorusBufferGeometry;\nexports.TextGeometry=TextGeometry;\nexports.SphereGeometry=SphereGeometry;\nexports.SphereBufferGeometry=SphereBufferGeometry;\nexports.RingGeometry=RingGeometry;\nexports.RingBufferGeometry=RingBufferGeometry;\nexports.PlaneGeometry=PlaneGeometry;\nexports.PlaneBufferGeometry=PlaneBufferGeometry;\nexports.LatheGeometry=LatheGeometry;\nexports.LatheBufferGeometry=LatheBufferGeometry;\nexports.ShapeGeometry=ShapeGeometry;\nexports.ShapeBufferGeometry=ShapeBufferGeometry;\nexports.ExtrudeGeometry=ExtrudeGeometry;\nexports.EdgesGeometry=EdgesGeometry;\nexports.ConeGeometry=ConeGeometry;\nexports.ConeBufferGeometry=ConeBufferGeometry;\nexports.CylinderGeometry=CylinderGeometry;\nexports.CylinderBufferGeometry=CylinderBufferGeometry;\nexports.CircleGeometry=CircleGeometry;\nexports.CircleBufferGeometry=CircleBufferGeometry;\nexports.BoxGeometry=BoxGeometry;\nexports.BoxBufferGeometry=BoxBufferGeometry;\nexports.ShadowMaterial=ShadowMaterial;\nexports.SpriteMaterial=SpriteMaterial;\nexports.RawShaderMaterial=RawShaderMaterial;\nexports.ShaderMaterial=ShaderMaterial;\nexports.PointsMaterial=PointsMaterial;\nexports.MultiMaterial=MultiMaterial;\nexports.MeshPhysicalMaterial=MeshPhysicalMaterial;\nexports.MeshStandardMaterial=MeshStandardMaterial;\nexports.MeshPhongMaterial=MeshPhongMaterial;\nexports.MeshToonMaterial=MeshToonMaterial;\nexports.MeshNormalMaterial=MeshNormalMaterial;\nexports.MeshLambertMaterial=MeshLambertMaterial;\nexports.MeshDepthMaterial=MeshDepthMaterial;\nexports.MeshBasicMaterial=MeshBasicMaterial;\nexports.LineDashedMaterial=LineDashedMaterial;\nexports.LineBasicMaterial=LineBasicMaterial;\nexports.Material=Material;\nexports.Float64BufferAttribute=Float64BufferAttribute;\nexports.Float32BufferAttribute=Float32BufferAttribute;\nexports.Uint32BufferAttribute=Uint32BufferAttribute;\nexports.Int32BufferAttribute=Int32BufferAttribute;\nexports.Uint16BufferAttribute=Uint16BufferAttribute;\nexports.Int16BufferAttribute=Int16BufferAttribute;\nexports.Uint8ClampedBufferAttribute=Uint8ClampedBufferAttribute;\nexports.Uint8BufferAttribute=Uint8BufferAttribute;\nexports.Int8BufferAttribute=Int8BufferAttribute;\nexports.BufferAttribute=BufferAttribute;\nexports.REVISION=REVISION;\nexports.MOUSE=MOUSE;\nexports.CullFaceNone=CullFaceNone;\nexports.CullFaceBack=CullFaceBack;\nexports.CullFaceFront=CullFaceFront;\nexports.CullFaceFrontBack=CullFaceFrontBack;\nexports.FrontFaceDirectionCW=FrontFaceDirectionCW;\nexports.FrontFaceDirectionCCW=FrontFaceDirectionCCW;\nexports.BasicShadowMap=BasicShadowMap;\nexports.PCFShadowMap=PCFShadowMap;\nexports.PCFSoftShadowMap=PCFSoftShadowMap;\nexports.FrontSide=FrontSide;\nexports.BackSide=BackSide;\nexports.DoubleSide=DoubleSide;\nexports.FlatShading=FlatShading;\nexports.SmoothShading=SmoothShading;\nexports.NoColors=NoColors;\nexports.FaceColors=FaceColors;\nexports.VertexColors=VertexColors;\nexports.NoBlending=NoBlending;\nexports.NormalBlending=NormalBlending;\nexports.AdditiveBlending=AdditiveBlending;\nexports.SubtractiveBlending=SubtractiveBlending;\nexports.MultiplyBlending=MultiplyBlending;\nexports.CustomBlending=CustomBlending;\nexports.AddEquation=AddEquation;\nexports.SubtractEquation=SubtractEquation;\nexports.ReverseSubtractEquation=ReverseSubtractEquation;\nexports.MinEquation=MinEquation;\nexports.MaxEquation=MaxEquation;\nexports.ZeroFactor=ZeroFactor;\nexports.OneFactor=OneFactor;\nexports.SrcColorFactor=SrcColorFactor;\nexports.OneMinusSrcColorFactor=OneMinusSrcColorFactor;\nexports.SrcAlphaFactor=SrcAlphaFactor;\nexports.OneMinusSrcAlphaFactor=OneMinusSrcAlphaFactor;\nexports.DstAlphaFactor=DstAlphaFactor;\nexports.OneMinusDstAlphaFactor=OneMinusDstAlphaFactor;\nexports.DstColorFactor=DstColorFactor;\nexports.OneMinusDstColorFactor=OneMinusDstColorFactor;\nexports.SrcAlphaSaturateFactor=SrcAlphaSaturateFactor;\nexports.NeverDepth=NeverDepth;\nexports.AlwaysDepth=AlwaysDepth;\nexports.LessDepth=LessDepth;\nexports.LessEqualDepth=LessEqualDepth;\nexports.EqualDepth=EqualDepth;\nexports.GreaterEqualDepth=GreaterEqualDepth;\nexports.GreaterDepth=GreaterDepth;\nexports.NotEqualDepth=NotEqualDepth;\nexports.MultiplyOperation=MultiplyOperation;\nexports.MixOperation=MixOperation;\nexports.AddOperation=AddOperation;\nexports.NoToneMapping=NoToneMapping;\nexports.LinearToneMapping=LinearToneMapping;\nexports.ReinhardToneMapping=ReinhardToneMapping;\nexports.Uncharted2ToneMapping=Uncharted2ToneMapping;\nexports.CineonToneMapping=CineonToneMapping;\nexports.UVMapping=UVMapping;\nexports.CubeReflectionMapping=CubeReflectionMapping;\nexports.CubeRefractionMapping=CubeRefractionMapping;\nexports.EquirectangularReflectionMapping=EquirectangularReflectionMapping;\nexports.EquirectangularRefractionMapping=EquirectangularRefractionMapping;\nexports.SphericalReflectionMapping=SphericalReflectionMapping;\nexports.CubeUVReflectionMapping=CubeUVReflectionMapping;\nexports.CubeUVRefractionMapping=CubeUVRefractionMapping;\nexports.RepeatWrapping=RepeatWrapping;\nexports.ClampToEdgeWrapping=ClampToEdgeWrapping;\nexports.MirroredRepeatWrapping=MirroredRepeatWrapping;\nexports.NearestFilter=NearestFilter;\nexports.NearestMipMapNearestFilter=NearestMipMapNearestFilter;\nexports.NearestMipMapLinearFilter=NearestMipMapLinearFilter;\nexports.LinearFilter=LinearFilter;\nexports.LinearMipMapNearestFilter=LinearMipMapNearestFilter;\nexports.LinearMipMapLinearFilter=LinearMipMapLinearFilter;\nexports.UnsignedByteType=UnsignedByteType;\nexports.ByteType=ByteType;\nexports.ShortType=ShortType;\nexports.UnsignedShortType=UnsignedShortType;\nexports.IntType=IntType;\nexports.UnsignedIntType=UnsignedIntType;\nexports.FloatType=FloatType;\nexports.HalfFloatType=HalfFloatType;\nexports.UnsignedShort4444Type=UnsignedShort4444Type;\nexports.UnsignedShort5551Type=UnsignedShort5551Type;\nexports.UnsignedShort565Type=UnsignedShort565Type;\nexports.UnsignedInt248Type=UnsignedInt248Type;\nexports.AlphaFormat=AlphaFormat;\nexports.RGBFormat=RGBFormat;\nexports.RGBAFormat=RGBAFormat;\nexports.LuminanceFormat=LuminanceFormat;\nexports.LuminanceAlphaFormat=LuminanceAlphaFormat;\nexports.RGBEFormat=RGBEFormat;\nexports.DepthFormat=DepthFormat;\nexports.DepthStencilFormat=DepthStencilFormat;\nexports.RGB_S3TC_DXT1_Format=RGB_S3TC_DXT1_Format;\nexports.RGBA_S3TC_DXT1_Format=RGBA_S3TC_DXT1_Format;\nexports.RGBA_S3TC_DXT3_Format=RGBA_S3TC_DXT3_Format;\nexports.RGBA_S3TC_DXT5_Format=RGBA_S3TC_DXT5_Format;\nexports.RGB_PVRTC_4BPPV1_Format=RGB_PVRTC_4BPPV1_Format;\nexports.RGB_PVRTC_2BPPV1_Format=RGB_PVRTC_2BPPV1_Format;\nexports.RGBA_PVRTC_4BPPV1_Format=RGBA_PVRTC_4BPPV1_Format;\nexports.RGBA_PVRTC_2BPPV1_Format=RGBA_PVRTC_2BPPV1_Format;\nexports.RGB_ETC1_Format=RGB_ETC1_Format;\nexports.LoopOnce=LoopOnce;\nexports.LoopRepeat=LoopRepeat;\nexports.LoopPingPong=LoopPingPong;\nexports.InterpolateDiscrete=InterpolateDiscrete;\nexports.InterpolateLinear=InterpolateLinear;\nexports.InterpolateSmooth=InterpolateSmooth;\nexports.ZeroCurvatureEnding=ZeroCurvatureEnding;\nexports.ZeroSlopeEnding=ZeroSlopeEnding;\nexports.WrapAroundEnding=WrapAroundEnding;\nexports.TrianglesDrawMode=TrianglesDrawMode;\nexports.TriangleStripDrawMode=TriangleStripDrawMode;\nexports.TriangleFanDrawMode=TriangleFanDrawMode;\nexports.LinearEncoding=LinearEncoding;\nexports.sRGBEncoding=sRGBEncoding;\nexports.GammaEncoding=GammaEncoding;\nexports.RGBEEncoding=RGBEEncoding;\nexports.LogLuvEncoding=LogLuvEncoding;\nexports.RGBM7Encoding=RGBM7Encoding;\nexports.RGBM16Encoding=RGBM16Encoding;\nexports.RGBDEncoding=RGBDEncoding;\nexports.BasicDepthPacking=BasicDepthPacking;\nexports.RGBADepthPacking=RGBADepthPacking;\nexports.CubeGeometry=BoxGeometry;\nexports.Face4=Face4;\nexports.LineStrip=LineStrip;\nexports.LinePieces=LinePieces;\nexports.MeshFaceMaterial=MeshFaceMaterial;\nexports.PointCloud=PointCloud;\nexports.Particle=Particle;\nexports.ParticleSystem=ParticleSystem;\nexports.PointCloudMaterial=PointCloudMaterial;\nexports.ParticleBasicMaterial=ParticleBasicMaterial;\nexports.ParticleSystemMaterial=ParticleSystemMaterial;\nexports.Vertex=Vertex;\nexports.DynamicBufferAttribute=DynamicBufferAttribute;\nexports.Int8Attribute=Int8Attribute;\nexports.Uint8Attribute=Uint8Attribute;\nexports.Uint8ClampedAttribute=Uint8ClampedAttribute;\nexports.Int16Attribute=Int16Attribute;\nexports.Uint16Attribute=Uint16Attribute;\nexports.Int32Attribute=Int32Attribute;\nexports.Uint32Attribute=Uint32Attribute;\nexports.Float32Attribute=Float32Attribute;\nexports.Float64Attribute=Float64Attribute;\nexports.ClosedSplineCurve3=ClosedSplineCurve3;\nexports.SplineCurve3=SplineCurve3;\nexports.Spline=Spline;\nexports.BoundingBoxHelper=BoundingBoxHelper;\nexports.EdgesHelper=EdgesHelper;\nexports.WireframeHelper=WireframeHelper;\nexports.XHRLoader=XHRLoader;\nexports.BinaryTextureLoader=BinaryTextureLoader;\nexports.GeometryUtils=GeometryUtils;\nexports.ImageUtils=ImageUtils;\nexports.Projector=Projector;\nexports.CanvasRenderer=CanvasRenderer;\n\nObject.defineProperty(exports,'__esModule',{value:true});\n\n});\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/three/build/three.js\n// module id = 6\n// module chunks = 0\n//# sourceURL=webpack:///./~/three/build/three.js?");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("'use strict'; /**\n               * @author mrdoob / http://mrdoob.com/\n               */\nmodule.exports = function (THREE) {\n  THREE.OBJLoader = function (manager) {\n\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n    this.materials = null;\n\n    this.regexp = {\n      // v float float float\n      vertex_pattern: /^v\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n      // vn float float float\n      normal_pattern: /^vn\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n      // vt float float\n      uv_pattern: /^vt\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n      // f vertex vertex vertex\n      face_vertex: /^f\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)(?:\\s+(-?\\d+))?/,\n      // f vertex/uv vertex/uv vertex/uv\n      face_vertex_uv: /^f\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+))?/,\n      // f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n      face_vertex_uv_normal: /^f\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/,\n      // f vertex//normal vertex//normal vertex//normal\n      face_vertex_normal: /^f\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)(?:\\s+(-?\\d+)\\/\\/(-?\\d+))?/,\n      // o object_name | g group_name\n      object_pattern: /^[og]\\s*(.+)?/,\n      // s boolean\n      smoothing_pattern: /^s\\s+(\\d+|on|off)/,\n      // mtllib file_reference\n      material_library_pattern: /^mtllib /,\n      // usemtl material_name\n      material_use_pattern: /^usemtl / };\n\n\n  };\n\n  THREE.OBJLoader.prototype = {\n\n    constructor: THREE.OBJLoader,\n\n    load: function load(url, onLoad, onProgress, onError) {\n\n      var scope = this;\n\n      var loader = new THREE.FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.load(url, function (text) {\n\n        onLoad(scope.parse(text));\n\n      }, onProgress, onError);\n\n    },\n\n    setPath: function setPath(value) {\n\n      this.path = value;\n\n    },\n\n    setMaterials: function setMaterials(materials) {\n\n      this.materials = materials;\n\n    },\n\n    _createParserState: function _createParserState() {\n\n      var state = {\n        objects: [],\n        object: {},\n\n        vertices: [],\n        normals: [],\n        uvs: [],\n\n        materialLibraries: [],\n\n        startObject: function startObject(name, fromDeclaration) {\n\n          // If the current object (initial from reset) is not from a g/o declaration in the parsed\n          // file. We need to use it for the first parsed g/o to keep things in sync.\n          if (this.object && this.object.fromDeclaration === false) {\n\n            this.object.name = name;\n            this.object.fromDeclaration = fromDeclaration !== false;\n            return;\n\n          }\n\n          var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n          if (this.object && typeof this.object._finalize === 'function') {\n\n            this.object._finalize(true);\n\n          }\n\n          this.object = {\n            name: name || '',\n            fromDeclaration: fromDeclaration !== false,\n\n            geometry: {\n              vertices: [],\n              normals: [],\n              uvs: [] },\n\n            materials: [],\n            smooth: true,\n\n            startMaterial: function startMaterial(name, libraries) {\n\n              var previous = this._finalize(false);\n\n              // New usemtl declaration overwrites an inherited material, except if faces were declared\n              // after the material, then it must be preserved for proper MultiMaterial continuation.\n              if (previous && (previous.inherited || previous.groupCount <= 0)) {\n\n                this.materials.splice(previous.index, 1);\n\n              }\n\n              var material = {\n                index: this.materials.length,\n                name: name || '',\n                mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n                smooth: previous !== undefined ? previous.smooth : this.smooth,\n                groupStart: previous !== undefined ? previous.groupEnd : 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false,\n\n                clone: function clone(index) {\n                  var cloned = {\n                    index: typeof index === 'number' ? index : this.index,\n                    name: this.name,\n                    mtllib: this.mtllib,\n                    smooth: this.smooth,\n                    groupStart: 0,\n                    groupEnd: -1,\n                    groupCount: -1,\n                    inherited: false };\n\n                  cloned.clone = this.clone.bind(cloned);\n                  return cloned;\n                } };\n\n\n              this.materials.push(material);\n\n              return material;\n\n            },\n\n            currentMaterial: function currentMaterial() {\n\n              if (this.materials.length > 0) {\n                return this.materials[this.materials.length - 1];\n              }\n\n              return undefined;\n\n            },\n\n            _finalize: function _finalize(end) {\n\n              var lastMultiMaterial = this.currentMaterial();\n              if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n\n                lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n                lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n                lastMultiMaterial.inherited = false;\n\n              }\n\n              // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n              if (end && this.materials.length > 1) {\n\n                for (var mi = this.materials.length - 1; mi >= 0; mi--) {\n                  if (this.materials[mi].groupCount <= 0) {\n                    this.materials.splice(mi, 1);\n                  }\n                }\n\n              }\n\n              // Guarantee at least one empty material, this makes the creation later more straight forward.\n              if (end && this.materials.length === 0) {\n\n                this.materials.push({\n                  name: '',\n                  smooth: this.smooth });\n\n\n              }\n\n              return lastMultiMaterial;\n\n            } };\n\n\n          // Inherit previous objects material.\n          // Spec tells us that a declared material must be set to all objects until a new material is declared.\n          // If a usemtl declaration is encountered while this new object is being parsed, it will\n          // overwrite the inherited material. Exception being that there was already face declarations\n          // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n          if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\") {\n\n            var declared = previousMaterial.clone(0);\n            declared.inherited = true;\n            this.object.materials.push(declared);\n\n          }\n\n          this.objects.push(this.object);\n\n        },\n\n        finalize: function finalize() {\n\n          if (this.object && typeof this.object._finalize === 'function') {\n\n            this.object._finalize(true);\n\n          }\n\n        },\n\n        parseVertexIndex: function parseVertexIndex(value, len) {\n\n          var index = parseInt(value, 10);\n          return (index >= 0 ? index - 1 : index + len / 3) * 3;\n\n        },\n\n        parseNormalIndex: function parseNormalIndex(value, len) {\n\n          var index = parseInt(value, 10);\n          return (index >= 0 ? index - 1 : index + len / 3) * 3;\n\n        },\n\n        parseUVIndex: function parseUVIndex(value, len) {\n\n          var index = parseInt(value, 10);\n          return (index >= 0 ? index - 1 : index + len / 2) * 2;\n\n        },\n\n        addVertex: function addVertex(a, b, c) {\n\n          var src = this.vertices;\n          var dst = this.object.geometry.vertices;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n          dst.push(src[a + 2]);\n          dst.push(src[b + 0]);\n          dst.push(src[b + 1]);\n          dst.push(src[b + 2]);\n          dst.push(src[c + 0]);\n          dst.push(src[c + 1]);\n          dst.push(src[c + 2]);\n\n        },\n\n        addVertexLine: function addVertexLine(a) {\n\n          var src = this.vertices;\n          var dst = this.object.geometry.vertices;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n          dst.push(src[a + 2]);\n\n        },\n\n        addNormal: function addNormal(a, b, c) {\n\n          var src = this.normals;\n          var dst = this.object.geometry.normals;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n          dst.push(src[a + 2]);\n          dst.push(src[b + 0]);\n          dst.push(src[b + 1]);\n          dst.push(src[b + 2]);\n          dst.push(src[c + 0]);\n          dst.push(src[c + 1]);\n          dst.push(src[c + 2]);\n\n        },\n\n        addUV: function addUV(a, b, c) {\n\n          var src = this.uvs;\n          var dst = this.object.geometry.uvs;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n          dst.push(src[b + 0]);\n          dst.push(src[b + 1]);\n          dst.push(src[c + 0]);\n          dst.push(src[c + 1]);\n\n        },\n\n        addUVLine: function addUVLine(a) {\n\n          var src = this.uvs;\n          var dst = this.object.geometry.uvs;\n\n          dst.push(src[a + 0]);\n          dst.push(src[a + 1]);\n\n        },\n\n        addFace: function addFace(a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd) {\n\n          var vLen = this.vertices.length;\n\n          var ia = this.parseVertexIndex(a, vLen);\n          var ib = this.parseVertexIndex(b, vLen);\n          var ic = this.parseVertexIndex(c, vLen);\n          var id;\n\n          if (d === undefined) {\n\n            this.addVertex(ia, ib, ic);\n\n          } else {\n\n            id = this.parseVertexIndex(d, vLen);\n\n            this.addVertex(ia, ib, id);\n            this.addVertex(ib, ic, id);\n\n          }\n\n          if (ua !== undefined) {\n\n            var uvLen = this.uvs.length;\n\n            ia = this.parseUVIndex(ua, uvLen);\n            ib = this.parseUVIndex(ub, uvLen);\n            ic = this.parseUVIndex(uc, uvLen);\n\n            if (d === undefined) {\n\n              this.addUV(ia, ib, ic);\n\n            } else {\n\n              id = this.parseUVIndex(ud, uvLen);\n\n              this.addUV(ia, ib, id);\n              this.addUV(ib, ic, id);\n\n            }\n\n          }\n\n          if (na !== undefined) {\n\n            // Normals are many times the same. If so, skip function call and parseInt.\n            var nLen = this.normals.length;\n            ia = this.parseNormalIndex(na, nLen);\n\n            ib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n            ic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\n            if (d === undefined) {\n\n              this.addNormal(ia, ib, ic);\n\n            } else {\n\n              id = this.parseNormalIndex(nd, nLen);\n\n              this.addNormal(ia, ib, id);\n              this.addNormal(ib, ic, id);\n\n            }\n\n          }\n\n        },\n\n        addLineGeometry: function addLineGeometry(vertices, uvs) {\n\n          this.object.geometry.type = 'Line';\n\n          var vLen = this.vertices.length;\n          var uvLen = this.uvs.length;\n\n          for (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n            this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n\n          }\n\n          for (var uvi = 0, l = uvs.length; uvi < l; uvi++) {\n\n            this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n\n          }\n\n        } };\n\n\n\n      state.startObject('', false);\n\n      return state;\n\n    },\n\n    parse: function parse(text) {\n\n      console.time('OBJLoader');\n\n      var state = this._createParserState();\n\n      if (text.indexOf('\\r\\n') !== -1) {\n\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n\n      }\n\n      if (text.indexOf('\\\\\\n') !== -1) {\n\n        // join lines separated by a line continuation character (\\)\n        text = text.replace(/\\\\\\n/g, '');\n\n      }\n\n      var lines = text.split('\\n');\n      var line = '',lineFirstChar = '',lineSecondChar = '';\n      var lineLength = 0;\n      var result = [];\n\n      // Faster to just trim left side of the line. Use if available.\n      var trimLeft = typeof ''.trimLeft === 'function';\n\n      for (var i = 0, l = lines.length; i < l; i++) {\n\n        line = lines[i];\n\n        line = trimLeft ? line.trimLeft() : line.trim();\n\n        lineLength = line.length;\n\n        if (lineLength === 0) continue;\n\n        lineFirstChar = line.charAt(0);\n\n        // @todo invoke passed in handler if any\n        if (lineFirstChar === '#') continue;\n\n        if (lineFirstChar === 'v') {\n\n          lineSecondChar = line.charAt(1);\n\n          if (lineSecondChar === ' ' && (result = this.regexp.vertex_pattern.exec(line)) !== null) {\n\n            // 0                  1      2      3\n            // [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n            state.vertices.push(\n            parseFloat(result[1]),\n            parseFloat(result[2]),\n            parseFloat(result[3]));\n\n\n          } else if (lineSecondChar === 'n' && (result = this.regexp.normal_pattern.exec(line)) !== null) {\n\n            // 0                   1      2      3\n            // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n            state.normals.push(\n            parseFloat(result[1]),\n            parseFloat(result[2]),\n            parseFloat(result[3]));\n\n\n          } else if (lineSecondChar === 't' && (result = this.regexp.uv_pattern.exec(line)) !== null) {\n\n            // 0               1      2\n            // [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\n            state.uvs.push(\n            parseFloat(result[1]),\n            parseFloat(result[2]));\n\n\n          } else {\n\n            throw new Error(\"Unexpected vertex/normal/uv line: '\" + line + \"'\");\n\n          }\n\n        } else if (lineFirstChar === \"f\") {\n\n          if ((result = this.regexp.face_vertex_uv_normal.exec(line)) !== null) {\n\n            // f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n            // 0                        1    2    3    4    5    6    7    8    9   10         11         12\n            // [\"f 1/1/1 2/2/2 3/3/3\", \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"3\", \"3\", \"3\", undefined, undefined, undefined]\n\n            state.addFace(\n            result[1], result[4], result[7], result[10],\n            result[2], result[5], result[8], result[11],\n            result[3], result[6], result[9], result[12]);\n\n\n          } else if ((result = this.regexp.face_vertex_uv.exec(line)) !== null) {\n\n            // f vertex/uv vertex/uv vertex/uv\n            // 0                  1    2    3    4    5    6   7          8\n            // [\"f 1/1 2/2 3/3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\n            state.addFace(\n            result[1], result[3], result[5], result[7],\n            result[2], result[4], result[6], result[8]);\n\n\n          } else if ((result = this.regexp.face_vertex_normal.exec(line)) !== null) {\n\n            // f vertex//normal vertex//normal vertex//normal\n            // 0                     1    2    3    4    5    6   7          8\n            // [\"f 1//1 2//2 3//3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\n            state.addFace(\n            result[1], result[3], result[5], result[7],\n            undefined, undefined, undefined, undefined,\n            result[2], result[4], result[6], result[8]);\n\n\n          } else if ((result = this.regexp.face_vertex.exec(line)) !== null) {\n\n            // f vertex vertex vertex\n            // 0            1    2    3   4\n            // [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\n            state.addFace(\n            result[1], result[2], result[3], result[4]);\n\n\n          } else {\n\n            throw new Error(\"Unexpected face line: '\" + line + \"'\");\n\n          }\n\n        } else if (lineFirstChar === \"l\") {\n\n          var lineParts = line.substring(1).trim().split(\" \");\n          var lineVertices = [],lineUVs = [];\n\n          if (line.indexOf(\"/\") === -1) {\n\n            lineVertices = lineParts;\n\n          } else {\n\n            for (var li = 0, llen = lineParts.length; li < llen; li++) {\n\n              var parts = lineParts[li].split(\"/\");\n\n              if (parts[0] !== \"\") lineVertices.push(parts[0]);\n              if (parts[1] !== \"\") lineUVs.push(parts[1]);\n\n            }\n\n          }\n          state.addLineGeometry(lineVertices, lineUVs);\n\n        } else if ((result = this.regexp.object_pattern.exec(line)) !== null) {\n\n          // o object_name\n          // or\n          // g group_name\n\n          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n          // var name = result[ 0 ].substr( 1 ).trim();\n          var name = (\" \" + result[0].substr(1).trim()).substr(1);\n\n          state.startObject(name);\n\n        } else if (this.regexp.material_use_pattern.test(line)) {\n\n          // material\n\n          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n\n        } else if (this.regexp.material_library_pattern.test(line)) {\n\n          // mtl file\n\n          state.materialLibraries.push(line.substring(7).trim());\n\n        } else if ((result = this.regexp.smoothing_pattern.exec(line)) !== null) {\n\n          // smooth shading\n\n          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n          // but does not define a usemtl for each face set.\n          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n          // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n          // where explicit usemtl defines geometry groups.\n          // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n          var value = result[1].trim().toLowerCase();\n          state.object.smooth = value === '1' || value === 'on';\n\n          var material = state.object.currentMaterial();\n          if (material) {\n\n            material.smooth = state.object.smooth;\n\n          }\n\n        } else {\n\n          // Handle null terminated files without exception\n          if (line === '\\0') continue;\n\n          throw new Error(\"Unexpected line: '\" + line + \"'\");\n\n        }\n\n      }\n\n      state.finalize();\n\n      var container = new THREE.Group();\n      container.materialLibraries = [].concat(state.materialLibraries);\n\n      for (var i = 0, l = state.objects.length; i < l; i++) {\n\n        var object = state.objects[i];\n        var geometry = object.geometry;\n        var materials = object.materials;\n        var isLine = geometry.type === 'Line';\n\n        // Skip o/g line declarations that did not follow with any faces\n        if (geometry.vertices.length === 0) continue;\n\n        var buffergeometry = new THREE.BufferGeometry();\n\n        buffergeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(geometry.vertices), 3));\n\n        if (geometry.normals.length > 0) {\n\n          buffergeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(geometry.normals), 3));\n\n        } else {\n\n          buffergeometry.computeVertexNormals();\n\n        }\n\n        if (geometry.uvs.length > 0) {\n\n          buffergeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(geometry.uvs), 2));\n\n        }\n\n        // Create materials\n\n        var createdMaterials = [];\n\n        for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n          var sourceMaterial = materials[mi];\n          var material = undefined;\n\n          if (this.materials !== null) {\n\n            material = this.materials.create(sourceMaterial.name);\n\n            // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n            if (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n\n              var materialLine = new THREE.LineBasicMaterial();\n              materialLine.copy(material);\n              material = materialLine;\n\n            }\n\n          }\n\n          if (!material) {\n\n            material = !isLine ? new THREE.MeshPhongMaterial() : new THREE.LineBasicMaterial();\n            material.name = sourceMaterial.name;\n\n          }\n\n          material.shading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;\n\n          createdMaterials.push(material);\n\n        }\n\n        // Create mesh\n\n        var mesh;\n\n        if (createdMaterials.length > 1) {\n\n          for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n            var sourceMaterial = materials[mi];\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n\n          }\n\n          var multiMaterial = new THREE.MultiMaterial(createdMaterials);\n          mesh = !isLine ? new THREE.Mesh(buffergeometry, multiMaterial) : new THREE.LineSegments(buffergeometry, multiMaterial);\n\n        } else {\n\n          mesh = !isLine ? new THREE.Mesh(buffergeometry, createdMaterials[0]) : new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n        }\n\n        mesh.name = object.name;\n\n        container.add(mesh);\n\n      }\n\n      console.timeEnd('OBJLoader');\n\n      return container;\n\n    } };\n\n\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/utils/objloader.js\n// module id = 7\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/utils/objloader.js?");

/***/ },
/* 8 */
/***/ function(module, exports) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}} // Provides simple static functions that are used multiple times in the app\nvar Helpers = function () {function Helpers() {_classCallCheck(this, Helpers);}_createClass(Helpers, null, [{ key: 'throttle', value: function throttle(\n    fn, threshhold, scope) {\n      threshhold || (threshhold = 250);\n      var last = void 0,deferTimer = void 0;\n\n      return function () {\n        var context = scope || this;\n\n        var now = +new Date(),\n        args = arguments;\n\n        if (last && now < last + threshhold) {\n          clearTimeout(deferTimer);\n          deferTimer = setTimeout(function () {\n            last = now;\n            fn.apply(context, args);\n          }, threshhold);\n        } else\n        {\n          last = now;\n          fn.apply(context, args);\n        }\n      };\n    } }, { key: 'logProgress', value: function logProgress()\n\n    {\n      return function (xhr) {\n        if (xhr.lengthComputable) {\n          var percentComplete = xhr.loaded / xhr.total * 100;\n\n          console.log(Math.round(percentComplete, 2) + '% downloaded');\n        }\n      };\n    } }, { key: 'logError', value: function logError()\n\n    {\n      return function (xhr) {\n        console.error(xhr);\n      };\n    } }, { key: 'handleColorChange', value: function handleColorChange(\n\n    color) {\n      return function (value) {\n        if (typeof value === 'string') {\n          value = value.replace('#', '0x');\n        }\n\n        color.setHex(value);\n      };\n    } }, { key: 'update', value: function update(\n\n    mesh) {\n      this.needsUpdate(mesh.material, mesh.geometry);\n    } }, { key: 'needsUpdate', value: function needsUpdate(\n\n    material, geometry) {\n      return function () {\n        material.shading = +material.shading; //Ensure number\n        material.vertexColors = +material.vertexColors; //Ensure number\n        material.side = +material.side; //Ensure number\n        material.needsUpdate = true;\n        geometry.verticesNeedUpdate = true;\n        geometry.normalsNeedUpdate = true;\n        geometry.colorsNeedUpdate = true;\n      };\n    } }, { key: 'updateTexture', value: function updateTexture(\n\n    material, materialKey, textures) {\n      return function (key) {\n        material[materialKey] = textures[key];\n        material.needsUpdate = true;\n      };\n    } }, { key: 'toRadians', value: function toRadians(\n\n    angle) {\n      return angle * (Math.PI / 180);\n    } }, { key: 'mapRange', value: function mapRange(\n\n    value, low1, high1, low2, high2) {\n      return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n    } }]);return Helpers;}();exports.default = Helpers;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/utils/helpers.js\n// module id = 8\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/utils/helpers.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Main webGL renderer class\nvar Renderer = function () {\n  function Renderer(scene, container) {var _this = this;_classCallCheck(this, Renderer);\n    // Properties\n    this.scene = scene;\n    this.container = container;\n\n    // Create WebGL renderer and set its antialias\n    this.threeRenderer = new THREE.WebGLRenderer({ antialias: true });\n\n    // Set clear color to fog to enable fog or to hex color for no fog\n    this.threeRenderer.setClearColor(0xf0f0f0);\n    this.threeRenderer.setPixelRatio(window.devicePixelRatio); // For retina\n\n    this.threeRenderer.autoClear = false;\n\n    // Appends canvas\n    container.appendChild(this.threeRenderer.domElement);\n\n    // Shadow map options\n    this.threeRenderer.shadowMap.enabled = true;\n    // this.threeRenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n    // Get anisotropy for textures\n    _config2.default.maxAnisotropy = this.threeRenderer.getMaxAnisotropy();\n\n    // Initial size update set to canvas container\n    this.updateSize();\n\n    // Listeners\n    document.addEventListener('DOMContentLoaded', function () {return _this.updateSize();}, false);\n    window.addEventListener('resize', function () {return _this.updateSize();}, false);\n  }_createClass(Renderer, [{ key: 'updateSize', value: function updateSize()\n\n    {\n      this.threeRenderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n    } }, { key: 'render', value: function render(\n\n    scene, camera) {\n      // Renders scene to canvas target\n      this.threeRenderer.clear();\n      this.threeRenderer.setViewport(0, 0, window.innerWidth, window.innerHeight);\n      this.threeRenderer.render(scene, camera);\n    } }]);return Renderer;}();exports.default = Renderer;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/components/renderer.js\n// module id = 9\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/components/renderer.js?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Class that creates and updates the main camera\nvar Camera = function () {\n  function Camera(renderer) {var _this = this;_classCallCheck(this, Camera);\n    var width = renderer.domElement.width;\n    var height = renderer.domElement.height;\n\n    // Create and position a Perspective Camera\n    this.threeCamera = new THREE.PerspectiveCamera(_config2.default.camera.fov, width / height, _config2.default.camera.near, _config2.default.camera.far);\n    this.threeCamera.position.set(_config2.default.camera.posX, _config2.default.camera.posY, _config2.default.camera.posZ);\n\n    // Initial sizing\n    this.updateSize(renderer);\n\n    // Listeners\n    window.addEventListener('resize', function () {return _this.updateSize(renderer);}, false);\n  }_createClass(Camera, [{ key: 'updateSize', value: function updateSize(\n\n    renderer) {\n      // Multiply by dpr in case it is retina device\n      this.threeCamera.aspect = renderer.domElement.width / renderer.domElement.height;\n\n      // Always call updateProjectionMatrix on camera change\n      this.threeCamera.updateProjectionMatrix();\n    } }]);return Camera;}();exports.default = Camera;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/components/camera.js\n// module id = 10\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/components/camera.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Sets up and places all lights in scene\nvar Light = function () {\n  function Light(scene) {_classCallCheck(this, Light);\n    this.scene = scene;\n\n    this.init();\n  }_createClass(Light, [{ key: 'init', value: function init()\n\n    {\n      // Ambient\n      this.ambientLight = new THREE.AmbientLight(_config2.default.ambientLight.color);\n      this.ambientLight.visible = _config2.default.ambientLight.enabled;\n\n      // Point light\n      this.pointLight = new THREE.PointLight(_config2.default.pointLight.color, _config2.default.pointLight.intensity, _config2.default.pointLight.distance);\n      this.pointLight.position.set(_config2.default.pointLight.x, _config2.default.pointLight.y, _config2.default.pointLight.z);\n      this.pointLight.visible = _config2.default.pointLight.enabled;\n\n      // Directional light\n      this.directionalLight = new THREE.DirectionalLight(_config2.default.directionalLight.color, _config2.default.directionalLight.intensity);\n      this.directionalLight.position.set(_config2.default.directionalLight.x, _config2.default.directionalLight.y, _config2.default.directionalLight.z);\n      this.directionalLight.position.multiplyScalar(_config2.default.directionalLight.multiplyScalar);\n      this.directionalLight.visible = _config2.default.directionalLight.enabled;\n      this.directionalLight.color.setHSL(_config2.default.directionalLight.hue, _config2.default.directionalLight.saturation, _config2.default.directionalLight.lightness);\n\n      // Shadow map\n      this.directionalLight.castShadow = _config2.default.shadow.enabled;\n      this.directionalLight.shadow.bias = _config2.default.shadow.bias;\n      this.directionalLight.shadow.camera.near = _config2.default.shadow.near;\n      this.directionalLight.shadow.camera.far = _config2.default.shadow.far;\n      this.directionalLight.shadow.camera.left = _config2.default.shadow.left;\n      this.directionalLight.shadow.camera.right = _config2.default.shadow.right;\n      this.directionalLight.shadow.camera.top = _config2.default.shadow.top;\n      this.directionalLight.shadow.camera.bottom = _config2.default.shadow.bottom;\n      this.directionalLight.shadow.mapSize.width = _config2.default.shadow.mapWidth;\n      this.directionalLight.shadow.mapSize.height = _config2.default.shadow.mapHeight;\n\n      // Shadow camera helper\n      this.directionalLightHelper = new THREE.CameraHelper(this.directionalLight.shadow.camera);\n      this.directionalLightHelper.visible = _config2.default.shadow.helperEnabled;\n\n      // Hemisphere light\n      this.hemiLight = new THREE.HemisphereLight(_config2.default.hemiLight.color, _config2.default.hemiLight.groundColor, _config2.default.hemiLight.intensity);\n      this.hemiLight.position.set(_config2.default.hemiLight.x, _config2.default.hemiLight.y, _config2.default.hemiLight.z);\n      this.hemiLight.visible = _config2.default.hemiLight.enabled;\n    } }, { key: 'place', value: function place(\n\n    lightName) {\n      switch (lightName) {\n        case 'ambient':\n          this.scene.add(this.ambientLight);\n          break;\n\n        case 'directional':\n          this.scene.add(this.directionalLight);\n          this.scene.add(this.directionalLightHelper);\n          break;\n\n        case 'point':\n          this.scene.add(this.pointLight);\n          break;\n\n        case 'hemi':\n          this.scene.add(this.hemiLight);\n          break;}\n\n    } }]);return Light;}();exports.default = Light;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/components/light.js\n// module id = 11\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/components/light.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n\nvar _orbitControls = __webpack_require__(13);var _orbitControls2 = _interopRequireDefault(_orbitControls);\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Controls based on orbit controls\nvar Controls = function () {\n  function Controls(camera, container) {_classCallCheck(this, Controls);\n    // Orbit controls first needs to pass in THREE to constructor\n    var orbitControls = new _orbitControls2.default(THREE);\n    this.threeControls = new orbitControls(camera, container);\n\n    // Controls are only in enabled via 'c' keypress\n    this.threeControls.enabled = true;\n\n    this.threeControls.mouseButtons = {\n      ORBIT: THREE.MOUSE.LEFT,\n      PAN: THREE.MOUSE.RIGHT,\n      ZOOM: THREE.MOUSE.MIDDLE };\n\n\n    this.init();\n  }_createClass(Controls, [{ key: 'disableZoom', value: function disableZoom()\n\n    {\n      this.threeControls.enableZoom = false;\n    } }, { key: 'enableZoom', value: function enableZoom()\n    {\n      this.threeControls.enableZoom = true;\n    } }, { key: 'disablePan', value: function disablePan()\n\n    {\n      this.threeControls.enablePan = false;\n    } }, { key: 'enablePan', value: function enablePan()\n    {\n      this.threeControls.enablePan = true;\n    } }, { key: 'disable', value: function disable()\n\n    {\n      this.threeControls.enabled = false;\n    } }, { key: 'enable', value: function enable()\n    {\n      this.threeControls.enabled = true;\n    } }, { key: 'init', value: function init()\n\n    {\n      this.threeControls.target.set(_config2.default.controls.target.x, _config2.default.controls.target.y, _config2.default.controls.target.z);\n      this.threeControls.autoRotate = _config2.default.controls.autoRotate;\n      this.threeControls.autoRotateSpeed = _config2.default.controls.autoRotateSpeed;\n      this.threeControls.rotateSpeed = _config2.default.controls.rotateSpeed;\n      this.threeControls.zoomSpeed = _config2.default.controls.zoomSpeed;\n      this.threeControls.minDistance = _config2.default.controls.minDistance;\n      this.threeControls.maxDistance = _config2.default.controls.maxDistance;\n      this.threeControls.minPolarAngle = _config2.default.controls.minPolarAngle;\n      this.threeControls.maxPolarAngle = _config2.default.controls.maxPolarAngle;\n      this.threeControls.enableDamping = _config2.default.controls.enableDamping;\n      this.threeControls.enableZoom = _config2.default.controls.enableZoom;\n      this.threeControls.dampingFactor = _config2.default.controls.dampingFactor;\n    } }]);return Controls;}();exports.default = Controls;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/components/controls.js\n// module id = 12\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/components/controls.js?");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("'use strict';module.exports = function (THREE) {\n  var MOUSE = THREE.MOUSE;\n  if (!MOUSE)\n  MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\n\n  /**\n                                             * @author qiao / https://github.com/qiao\n                                             * @author mrdoob / http://mrdoob.com\n                                             * @author alteredq / http://alteredqualia.com/\n                                             * @author WestLangley / http://github.com/WestLangley\n                                             * @author erich666 / http://erichaines.com\n                                             */\n  /*global THREE, console */\n\n  function OrbitConstraint(object) {\n\n    this.object = object;\n\n    // \"target\" sets the location of focus, where the object orbits around\n    // and where it pans with respect to.\n    this.target = new THREE.Vector3();\n\n    // Limits to how far you can dolly in and out ( PerspectiveCamera only )\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n\n    // Limits to how far you can zoom in and out ( OrthographicCamera only )\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n\n    // How far you can orbit vertically, upper and lower limits.\n    // Range is 0 to Math.PI radians.\n    this.minPolarAngle = 0; // radians\n    this.maxPolarAngle = Math.PI; // radians\n\n    // How far you can orbit horizontally, upper and lower limits.\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n    this.minAzimuthAngle = -Infinity; // radians\n    this.maxAzimuthAngle = Infinity; // radians\n\n    // Set to true to enable damping (inertia)\n    // If damping is enabled, you must call controls.update() in your animation loop\n    this.enableDamping = false;\n    this.dampingFactor = 0.25;\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var EPS = 0.000001;\n\n    // Current position in spherical coordinate system.\n    var theta;\n    var phi;\n\n    // Pending changes\n    var phiDelta = 0;\n    var thetaDelta = 0;\n    var scale = 1;\n    var panOffset = new THREE.Vector3();\n    var zoomChanged = false;\n\n    // API\n\n    this.getPolarAngle = function () {\n\n      return phi;\n\n    };\n\n    this.getAzimuthalAngle = function () {\n\n      return theta;\n\n    };\n\n    this.rotateLeft = function (angle) {\n\n      thetaDelta -= angle;\n\n    };\n\n    this.rotateUp = function (angle) {\n\n      phiDelta -= angle;\n\n    };\n\n    // pass in distance in world space to move left\n    this.panLeft = function () {\n\n      var v = new THREE.Vector3();\n\n      return function panLeft(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get X column of matrix\n        v.set(te[0], te[1], te[2]);\n        v.multiplyScalar(-distance);\n\n        panOffset.add(v);\n\n      };\n\n    }();\n\n    // pass in distance in world space to move up\n    this.panUp = function () {\n\n      var v = new THREE.Vector3();\n\n      return function panUp(distance) {\n\n        var te = this.object.matrix.elements;\n\n        // get Y column of matrix\n        v.set(te[4], te[5], te[6]);\n        v.multiplyScalar(distance);\n\n        panOffset.add(v);\n\n      };\n\n    }();\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    this.pan = function (deltaX, deltaY, screenWidth, screenHeight) {\n\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n\n        // perspective\n        var position = scope.object.position;\n        var offset = position.clone().sub(scope.target);\n        var targetDistance = offset.length();\n\n        // half of the fov is center to top of screen\n        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n\n        // we actually don't use screenWidth, since perspective camera is fixed to screen height\n        scope.panLeft(2 * deltaX * targetDistance / screenHeight);\n        scope.panUp(2 * deltaY * targetDistance / screenHeight);\n\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n\n        // orthographic\n        scope.panLeft(deltaX * (scope.object.right - scope.object.left) / screenWidth);\n        scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / screenHeight);\n\n      } else {\n\n        // camera neither orthographic or perspective\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\n      }\n\n    };\n\n    this.dollyIn = function (dollyScale) {\n\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n\n        scale /= dollyScale;\n\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n\n        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n\n      } else {\n\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\n      }\n\n    };\n\n    this.dollyOut = function (dollyScale) {\n\n      if (scope.object instanceof THREE.PerspectiveCamera) {\n\n        scale *= dollyScale;\n\n      } else if (scope.object instanceof THREE.OrthographicCamera) {\n\n        scope.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));\n        scope.object.updateProjectionMatrix();\n        zoomChanged = true;\n\n      } else {\n\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\n      }\n\n    };\n\n    this.update = function () {\n\n      var offset = new THREE.Vector3();\n\n      // so camera.up is the orbit axis\n      var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n      var quatInverse = quat.clone().inverse();\n\n      var lastPosition = new THREE.Vector3();\n      var lastQuaternion = new THREE.Quaternion();\n\n      return function () {\n\n        var position = this.object.position;\n\n        offset.copy(position).sub(this.target);\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat);\n\n        // angle from z-axis around y-axis\n\n        theta = Math.atan2(offset.x, offset.z);\n\n        // angle from y-axis\n\n        phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);\n\n        theta += thetaDelta;\n        phi += phiDelta;\n\n        // restrict theta to be between desired limits\n        theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));\n\n        // restrict phi to be between desired limits\n        phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));\n\n        // restrict phi to be betwee EPS and PI-EPS\n        phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));\n\n        var radius = offset.length() * scale;\n\n        // restrict radius to be between desired limits\n        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));\n\n        // move target to panned location\n        this.target.add(panOffset);\n\n        offset.x = radius * Math.sin(phi) * Math.sin(theta);\n        offset.y = radius * Math.cos(phi);\n        offset.z = radius * Math.sin(phi) * Math.cos(theta);\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse);\n\n        position.copy(this.target).add(offset);\n\n        this.object.lookAt(this.target);\n\n        if (this.enableDamping === true) {\n\n          thetaDelta *= 1 - this.dampingFactor;\n          phiDelta *= 1 - this.dampingFactor;\n\n        } else {\n\n          thetaDelta = 0;\n          phiDelta = 0;\n\n        }\n\n        scale = 1;\n        panOffset.set(0, 0, 0);\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (zoomChanged ||\n        lastPosition.distanceToSquared(this.object.position) > EPS ||\n        8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {\n\n          lastPosition.copy(this.object.position);\n          lastQuaternion.copy(this.object.quaternion);\n          zoomChanged = false;\n\n          return true;\n\n        }\n\n        return false;\n\n      };\n\n    }();\n\n  };\n\n\n  // This set of controls performs orbiting, dollying (zooming), and panning. It maintains\n  // the \"up\" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is\n  // supported.\n  //\n  //    Orbit - left mouse / touch: one finger move\n  //    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n  //    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n  function OrbitControls(object, domElement) {\n\n    var constraint = new OrbitConstraint(object);\n\n    this.domElement = domElement !== undefined ? domElement : document;\n\n    // API\n\n    Object.defineProperty(this, 'constraint', {\n\n      get: function get() {\n\n        return constraint;\n\n      } });\n\n\n\n    this.getPolarAngle = function () {\n\n      return constraint.getPolarAngle();\n\n    };\n\n    this.getAzimuthalAngle = function () {\n\n      return constraint.getAzimuthalAngle();\n\n    };\n\n    // Set to false to disable this control\n    this.enabled = true;\n\n    // center is old, deprecated; use \"target\" instead\n    this.center = this.target;\n\n    // This option actually enables dollying in and out; left as \"zoom\" for\n    // backwards compatibility.\n    // Set to false to disable zooming\n    this.enableZoom = true;\n    this.zoomSpeed = 1.0;\n\n    // Set to false to disable rotating\n    this.enableRotate = true;\n    this.rotateSpeed = 1.0;\n\n    // Set to false to disable panning\n    this.enablePan = true;\n    this.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n    // Set to true to automatically rotate around the target\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n    // Set to false to disable use of the keys\n    this.enableKeys = true;\n\n    // The four arrow keys\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n    // Mouse buttons\n    this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n    ////////////\n    // internals\n\n    var scope = this;\n\n    var rotateStart = new THREE.Vector2();\n    var rotateEnd = new THREE.Vector2();\n    var rotateDelta = new THREE.Vector2();\n\n    var panStart = new THREE.Vector2();\n    var panEnd = new THREE.Vector2();\n    var panDelta = new THREE.Vector2();\n\n    var dollyStart = new THREE.Vector2();\n    var dollyEnd = new THREE.Vector2();\n    var dollyDelta = new THREE.Vector2();\n\n    var STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\n\n    var state = STATE.NONE;\n\n    // for reset\n\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n\n    // events\n\n    var changeEvent = { type: 'change' };\n    var startEvent = { type: 'start' };\n    var endEvent = { type: 'end' };\n\n    // pass in x,y of change desired in pixel space,\n    // right and down are positive\n    function pan(deltaX, deltaY) {\n\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      constraint.pan(deltaX, deltaY, element.clientWidth, element.clientHeight);\n\n    }\n\n    this.update = function () {\n\n      if (this.autoRotate && state === STATE.NONE) {\n\n        constraint.rotateLeft(getAutoRotationAngle());\n\n      }\n\n      if (constraint.update() === true) {\n\n        this.dispatchEvent(changeEvent);\n\n      }\n\n    };\n\n    this.reset = function () {\n\n      state = STATE.NONE;\n\n      this.target.copy(this.target0);\n      this.object.position.copy(this.position0);\n      this.object.zoom = this.zoom0;\n\n      this.object.updateProjectionMatrix();\n      this.dispatchEvent(changeEvent);\n\n      this.update();\n\n    };\n\n    function getAutoRotationAngle() {\n\n      return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n    }\n\n    function getZoomScale() {\n\n      return Math.pow(0.95, scope.zoomSpeed);\n\n    }\n\n    function onMouseDown(event) {\n\n      if (scope.enabled === false) return;\n\n      event.preventDefault();\n\n      if (event.button === scope.mouseButtons.ORBIT) {\n\n        if (scope.enableRotate === false) return;\n\n        state = STATE.ROTATE;\n\n        rotateStart.set(event.clientX, event.clientY);\n\n      } else if (event.button === scope.mouseButtons.ZOOM) {\n\n        if (scope.enableZoom === false) return;\n\n        state = STATE.DOLLY;\n\n        dollyStart.set(event.clientX, event.clientY);\n\n      } else if (event.button === scope.mouseButtons.PAN) {\n\n        if (scope.enablePan === false) return;\n\n        state = STATE.PAN;\n\n        panStart.set(event.clientX, event.clientY);\n\n      }\n\n      if (state !== STATE.NONE) {\n\n        document.addEventListener('mousemove', onMouseMove, false);\n        document.addEventListener('mouseup', onMouseUp, false);\n        scope.dispatchEvent(startEvent);\n\n      }\n\n    }\n\n    function onMouseMove(event) {\n\n      if (scope.enabled === false) return;\n\n      event.preventDefault();\n\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      if (state === STATE.ROTATE) {\n\n        if (scope.enableRotate === false) return;\n\n        rotateEnd.set(event.clientX, event.clientY);\n        rotateDelta.subVectors(rotateEnd, rotateStart);\n\n        // rotating across whole screen goes 360 degrees around\n        constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\n        constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n        rotateStart.copy(rotateEnd);\n\n      } else if (state === STATE.DOLLY) {\n\n        if (scope.enableZoom === false) return;\n\n        dollyEnd.set(event.clientX, event.clientY);\n        dollyDelta.subVectors(dollyEnd, dollyStart);\n\n        if (dollyDelta.y > 0) {\n\n          constraint.dollyIn(getZoomScale());\n\n        } else if (dollyDelta.y < 0) {\n\n          constraint.dollyOut(getZoomScale());\n\n        }\n\n        dollyStart.copy(dollyEnd);\n\n      } else if (state === STATE.PAN) {\n\n        if (scope.enablePan === false) return;\n\n        panEnd.set(event.clientX, event.clientY);\n        panDelta.subVectors(panEnd, panStart);\n\n        pan(panDelta.x, panDelta.y);\n\n        panStart.copy(panEnd);\n\n      }\n\n      if (state !== STATE.NONE) scope.update();\n\n    }\n\n    function onMouseUp() /* event */{\n\n      if (scope.enabled === false) return;\n\n      document.removeEventListener('mousemove', onMouseMove, false);\n      document.removeEventListener('mouseup', onMouseUp, false);\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n\n    }\n\n    function onMouseWheel(event) {\n\n      if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE) return;\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      var delta = 0;\n\n      if (event.wheelDelta !== undefined) {\n\n        // WebKit / Opera / Explorer 9\n\n        delta = event.wheelDelta;\n\n      } else if (event.detail !== undefined) {\n\n        // Firefox\n\n        delta = -event.detail;\n\n      }\n\n      if (delta > 0) {\n\n        constraint.dollyOut(getZoomScale());\n\n      } else if (delta < 0) {\n\n        constraint.dollyIn(getZoomScale());\n\n      }\n\n      scope.update();\n      scope.dispatchEvent(startEvent);\n      scope.dispatchEvent(endEvent);\n\n    }\n\n    function onKeyDown(event) {\n\n      if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n      switch (event.keyCode) {\n\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed);\n          scope.update();\n          break;\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed);\n          scope.update();\n          break;\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0);\n          scope.update();\n          break;\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0);\n          scope.update();\n          break;}\n\n\n\n    }\n\n    function touchstart(event) {\n\n      if (scope.enabled === false) return;\n\n      switch (event.touches.length) {\n\n        case 1: // one-fingered touch: rotate\n\n          if (scope.enableRotate === false) return;\n\n          state = STATE.TOUCH_ROTATE;\n\n          rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n          break;\n\n        case 2: // two-fingered touch: dolly\n\n          if (scope.enableZoom === false) return;\n\n          state = STATE.TOUCH_DOLLY;\n\n          var dx = event.touches[0].pageX - event.touches[1].pageX;\n          var dy = event.touches[0].pageY - event.touches[1].pageY;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          dollyStart.set(0, distance);\n          break;\n\n        case 3: // three-fingered touch: pan\n\n          if (scope.enablePan === false) return;\n\n          state = STATE.TOUCH_PAN;\n\n          panStart.set(event.touches[0].pageX, event.touches[0].pageY);\n          break;\n\n        default:\n\n          state = STATE.NONE;}\n\n\n\n      if (state !== STATE.NONE) scope.dispatchEvent(startEvent);\n\n    }\n\n    function touchmove(event) {\n\n      if (scope.enabled === false) return;\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n      switch (event.touches.length) {\n\n        case 1: // one-fingered touch: rotate\n\n          if (scope.enableRotate === false) return;\n          if (state !== STATE.TOUCH_ROTATE) return;\n\n          rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          rotateDelta.subVectors(rotateEnd, rotateStart);\n\n          // rotating across whole screen goes 360 degrees around\n          constraint.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);\n          // rotating up and down along whole screen attempts to go 360, but limited to 180\n          constraint.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);\n\n          rotateStart.copy(rotateEnd);\n\n          scope.update();\n          break;\n\n        case 2: // two-fingered touch: dolly\n\n          if (scope.enableZoom === false) return;\n          if (state !== STATE.TOUCH_DOLLY) return;\n\n          var dx = event.touches[0].pageX - event.touches[1].pageX;\n          var dy = event.touches[0].pageY - event.touches[1].pageY;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n\n          dollyEnd.set(0, distance);\n          dollyDelta.subVectors(dollyEnd, dollyStart);\n\n          if (dollyDelta.y > 0) {\n\n            constraint.dollyOut(getZoomScale());\n\n          } else if (dollyDelta.y < 0) {\n\n            constraint.dollyIn(getZoomScale());\n\n          }\n\n          dollyStart.copy(dollyEnd);\n\n          scope.update();\n          break;\n\n        case 3: // three-fingered touch: pan\n\n          if (scope.enablePan === false) return;\n          if (state !== STATE.TOUCH_PAN) return;\n\n          panEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n          panDelta.subVectors(panEnd, panStart);\n\n          pan(panDelta.x, panDelta.y);\n\n          panStart.copy(panEnd);\n\n          scope.update();\n          break;\n\n        default:\n\n          state = STATE.NONE;}\n\n\n\n    }\n\n    function touchend() /* event */{\n\n      if (scope.enabled === false) return;\n\n      scope.dispatchEvent(endEvent);\n      state = STATE.NONE;\n\n    }\n\n    function contextmenu(event) {\n\n      event.preventDefault();\n\n    }\n\n    this.dispose = function () {\n\n      this.domElement.removeEventListener('contextmenu', contextmenu, false);\n      this.domElement.removeEventListener('mousedown', onMouseDown, false);\n      this.domElement.removeEventListener('mousewheel', onMouseWheel, false);\n      this.domElement.removeEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n      this.domElement.removeEventListener('touchstart', touchstart, false);\n      this.domElement.removeEventListener('touchend', touchend, false);\n      this.domElement.removeEventListener('touchmove', touchmove, false);\n\n      document.removeEventListener('mousemove', onMouseMove, false);\n      document.removeEventListener('mouseup', onMouseUp, false);\n\n      window.removeEventListener('keydown', onKeyDown, false);\n\n    };\n\n    this.domElement.addEventListener('contextmenu', contextmenu, false);\n\n    this.domElement.addEventListener('mousedown', onMouseDown, false);\n    this.domElement.addEventListener('mousewheel', onMouseWheel, false);\n    this.domElement.addEventListener('MozMousePixelScroll', onMouseWheel, false); // firefox\n\n    this.domElement.addEventListener('touchstart', touchstart, false);\n    this.domElement.addEventListener('touchend', touchend, false);\n    this.domElement.addEventListener('touchmove', touchmove, false);\n\n    window.addEventListener('keydown', onKeyDown, false);\n\n    // force an update at start\n    this.update();\n\n  };\n\n  OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\n  OrbitControls.prototype.constructor = OrbitControls;\n\n  Object.defineProperties(OrbitControls.prototype, {\n\n    object: {\n\n      get: function get() {\n\n        return this.constraint.object;\n\n      } },\n\n\n\n    target: {\n\n      get: function get() {\n\n        return this.constraint.target;\n\n      },\n\n      set: function set(value) {\n\n        console.warn('THREE.OrbitControls: target is now immutable. Use target.set() instead.');\n        this.constraint.target.copy(value);\n\n      } },\n\n\n\n    minDistance: {\n\n      get: function get() {\n\n        return this.constraint.minDistance;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.minDistance = value;\n\n      } },\n\n\n\n    maxDistance: {\n\n      get: function get() {\n\n        return this.constraint.maxDistance;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.maxDistance = value;\n\n      } },\n\n\n\n    minZoom: {\n\n      get: function get() {\n\n        return this.constraint.minZoom;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.minZoom = value;\n\n      } },\n\n\n\n    maxZoom: {\n\n      get: function get() {\n\n        return this.constraint.maxZoom;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.maxZoom = value;\n\n      } },\n\n\n\n    minPolarAngle: {\n\n      get: function get() {\n\n        return this.constraint.minPolarAngle;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.minPolarAngle = value;\n\n      } },\n\n\n\n    maxPolarAngle: {\n\n      get: function get() {\n\n        return this.constraint.maxPolarAngle;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.maxPolarAngle = value;\n\n      } },\n\n\n\n    minAzimuthAngle: {\n\n      get: function get() {\n\n        return this.constraint.minAzimuthAngle;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.minAzimuthAngle = value;\n\n      } },\n\n\n\n    maxAzimuthAngle: {\n\n      get: function get() {\n\n        return this.constraint.maxAzimuthAngle;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.maxAzimuthAngle = value;\n\n      } },\n\n\n\n    enableDamping: {\n\n      get: function get() {\n\n        return this.constraint.enableDamping;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.enableDamping = value;\n\n      } },\n\n\n\n    dampingFactor: {\n\n      get: function get() {\n\n        return this.constraint.dampingFactor;\n\n      },\n\n      set: function set(value) {\n\n        this.constraint.dampingFactor = value;\n\n      } },\n\n\n\n    // backward compatibility\n\n    noZoom: {\n\n      get: function get() {\n\n        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n        return !this.enableZoom;\n\n      },\n\n      set: function set(value) {\n\n        console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n        this.enableZoom = !value;\n\n      } },\n\n\n\n    noRotate: {\n\n      get: function get() {\n\n        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n        return !this.enableRotate;\n\n      },\n\n      set: function set(value) {\n\n        console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n        this.enableRotate = !value;\n\n      } },\n\n\n\n    noPan: {\n\n      get: function get() {\n\n        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n        return !this.enablePan;\n\n      },\n\n      set: function set(value) {\n\n        console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n        this.enablePan = !value;\n\n      } },\n\n\n\n    noKeys: {\n\n      get: function get() {\n\n        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n        return !this.enableKeys;\n\n      },\n\n      set: function set(value) {\n\n        console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n        this.enableKeys = !value;\n\n      } },\n\n\n\n    staticMoving: {\n\n      get: function get() {\n\n        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n        return !this.constraint.enableDamping;\n\n      },\n\n      set: function set(value) {\n\n        console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n        this.constraint.enableDamping = !value;\n\n      } },\n\n\n\n    dynamicDampingFactor: {\n\n      get: function get() {\n\n        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n        return this.constraint.dampingFactor;\n\n      },\n\n      set: function set(value) {\n\n        console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n        this.constraint.dampingFactor = value;\n\n      } } });\n\n\n\n\n\n  return OrbitControls;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/utils/orbitControls.js\n// module id = 13\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/utils/orbitControls.js?");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\nvar _soundobject = __webpack_require__(15);var _soundobject2 = _interopRequireDefault(_soundobject);\nvar _soundtrajectory = __webpack_require__(17);var _soundtrajectory2 = _interopRequireDefault(_soundtrajectory);\nvar _soundzone = __webpack_require__(18);var _soundzone2 = _interopRequireDefault(_soundzone);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}var\n\nPathDrawer = function () {\n  function PathDrawer(scene) {_classCallCheck(this, PathDrawer);\n    this.parentObject = null;\n    this.scene = scene;\n    this.points = [];\n    this.lines = [];\n    this.lastPoint = new THREE.Vector3();\n    this.isDrawing = false,\n\n    this.material = {\n      trajectory: new THREE.LineBasicMaterial({\n        linewidth: 2,\n        color: 0x999999 }),\n\n      zone: new THREE.LineBasicMaterial({\n        color: 0xff1169 }) };\n\n\n  }_createClass(PathDrawer, [{ key: 'beginAt', value: function beginAt(\n\n    point, trajectoryContainerObject) {\n      this.isDrawing = true;\n      this.parentObject = trajectoryContainerObject || null;\n      this.lastPoint = point;\n      this.points = [point];\n    } }, { key: 'addPoint', value: function addPoint(\n\n    point) {\n      if (this.isDrawing) {// redundant check? just to be safe for now\n        var material = this.parentObject ?\n        this.material.trajectory :\n        this.material.zone;\n        var geometry = new THREE.Geometry();\n        geometry.vertices.push(this.lastPoint, point);\n\n        var line = new THREE.Line(geometry, material);\n\n        this.lastPoint = point;\n        this.points.push(point);\n        this.lines.push(line);\n        this.scene.add(line);\n      }\n    } }, { key: 'createObject', value: function createObject(\n\n    main) {var loader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.isDrawing || loader) {\n        this.isDrawing = false;\n        var points = simplify(this.points, 10, true);\n        var object = void 0;\n        if (this.parentObject) {\n          if (points.length >= 2) {\n            object = new _soundtrajectory2.default(main, points);\n            if (main.isUserStudyLoading) object.turnInvisible();\n            object.points = points;\n            this.parentObject.trajectory = object;\n            object.parentSoundObject = this.parentObject;\n            main.soundTrajectories.push(object);\n          }\n        } else\n        {\n          if (points.length >= 3) {\n            object = new _soundzone2.default(main, points);\n            if (main.isUserStudyLoading) object.turnInvisible();\n            main.soundZones.push(object);\n          } else {\n            object = new _soundobject2.default(main);\n            if (main.isUserStudyLoading) object.turnInvisible();\n            main.soundObjects.push(object);\n          }\n        }\n\n        this.clear();\n\n        if (object) {\n          object.addToScene(this.scene);\n        }\n        return object;\n      } else\n      {\n        console.log('called createObject when not drawing');\n      }\n    } }, { key: 'clear', value: function clear()\n\n    {var _this = this;\n      this.parentObject = null;\n      this.lines.forEach(function (line) {\n        _this.scene.remove(line);\n      });\n      this.lines = [];\n      this.points = [];\n    } }]);return PathDrawer;}();exports.default = PathDrawer;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/components/pathdrawer.js\n// module id = 14\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/components/pathdrawer.js?");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n__webpack_require__(16);\n\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);\nvar _helpers = __webpack_require__(8);var _helpers2 = _interopRequireDefault(_helpers);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}var\n\nSoundObject = function () {\n  function SoundObject(main) {_classCallCheck(this, SoundObject);\n    this.type = 'SoundObject';\n    this.posX = 0;\n    this.posY = 0;\n    this.posZ = 0;\n    this.radius = _config2.default.soundObject.defaultRadius;\n    this.cones = [];\n    this.audio = main.audio;\n    this.gui = main.gui;\n\n    this.trajectory = null;\n    this.trajectoryClock = _config2.default.soundObject.defaultTrajectoryClock;\n    this.movementSpeed = _config2.default.soundObject.defaultMovementSpeed;\n    this.movementDirection = _config2.default.soundObject.defaultMovementDirection;\n    this.movementIncrement = null;\n\n    this.containerObject = new THREE.Object3D();\n\n    var sphereGeometry = new THREE.SphereBufferGeometry(this.radius, 100, 100);\n    var sphereMaterial = new THREE.MeshBasicMaterial({\n      color: 0xFFFFFF,\n      opacity: 0.8,\n      transparent: true,\n      premultipliedAlpha: true });\n\n    this.omniSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\n    this.omniSphere.name = 'omniSphere';\n    this.omniSphere.castShadow = true;\n\n    var raycastSphereGeometry = new THREE.SphereBufferGeometry(150, 100, 100);\n    var raycastSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, visible: false });\n    this.raycastSphere = new THREE.Mesh(raycastSphereGeometry, raycastSphereMaterial);\n    this.raycastSphere.name = 'sphere';\n    this.raycastSphere.position.copy(main.mouse);\n    main.scene.add(this.raycastSphere);\n\n    this.axisHelper = new THREE.AxisHelper(100);\n    this.axisHelper.position.copy(main.mouse);\n    main.scene.add(this.axisHelper);\n\n    var lineMaterial = new THREE.LineDashedMaterial({\n      color: 0x888888,\n      dashSize: 30,\n      gapSize: 30 });\n\n    var lineGeometry = new THREE.Geometry();\n\n    lineGeometry.vertices.push(\n    new THREE.Vector3(0, 0, -300),\n    new THREE.Vector3(0, 0, 300));\n\n\n    lineGeometry.computeLineDistances();\n    this.altitudeHelper = new THREE.Line(lineGeometry, lineMaterial);\n    this.altitudeHelper.rotation.x = Math.PI / 2;\n    main.scene.add(this.altitudeHelper);\n    this.altitudeHelper.position.copy(main.mouse);\n\n    this.containerObject.add(this.omniSphere);\n    this.containerObject.position.copy(main.mouse);\n    main.scene.add(this.containerObject);\n  }_createClass(SoundObject, [{ key: 'createCone', value: function createCone(\n\n    sound) {var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      sound.volume.gain.value = 1;\n      sound.spread = 0.5;\n\n      var coneWidth = sound.spread * 90;\n      var coneHeight = sound.volume.gain.value * 50 + 50;\n\n      var coneGeo = new THREE.CylinderGeometry(coneWidth, 0, coneHeight, 100, 1, true);\n      var randGreen = color !== null ? color : Math.random();\n      var randBlue = color !== null ? color : Math.random();\n      //const coneColor = new THREE.Color(0.5, randGreen, randBlue);\n      var coneColor = new THREE.Color();\n      coneColor.setHSL(randGreen, randBlue, 0.8);\n      var coneMaterial = new THREE.MeshBasicMaterial({\n        color: coneColor,\n        opacity: 0.8,\n        transparent: true });\n\n\n      coneGeo.translate(0, coneHeight / 2, 0);\n      coneGeo.rotateX(Math.PI / 2);\n      coneMaterial.side = THREE.DoubleSide;\n\n      var cone = new THREE.Mesh(coneGeo, coneMaterial);\n\n      cone.randGreen = randGreen;\n      cone.sound = sound;\n      cone.sound.panner.coneInnerAngle = Math.atan(coneWidth / coneHeight) * (180 / Math.PI);\n      cone.sound.panner.coneOuterAngle = cone.sound.panner.coneInnerAngle * 3;\n      cone.sound.panner.coneOuterGain = 0.05;\n      // cone.sound.volume.gain.value = Helpers.mapRange(coneHeight, 100, 150, 0.5, 2);\n\n      cone.name = 'cone';\n      cone.baseColor = coneColor;\n      cone.hoverColor = function () {\n        var c = this.baseColor.clone();\n        c.offsetHSL(0, -0.05, 0.1);\n        return c;\n      };\n\n      sound.scriptNode.onaudioprocess = function () {\n        var array = new Uint8Array(sound.analyser.frequencyBinCount);\n        sound.analyser.getByteFrequencyData(array);\n        var values = 0;\n        var length = array.length;\n        for (var i = 0; i < length; i++) {values += array[i];}\n        var average = values / length;\n        cone.material.opacity = _helpers2.default.mapRange(average, 50, 100, 0.65, 0.95);\n      };\n\n      cone.long = cone.lat = 0;\n\n      this.cones.push(cone);\n      this.containerObject.add(cone);\n      this.setAudioPosition(cone);\n      return cone;\n    } }, { key: 'setAudioPosition', value: function setAudioPosition(\n\n    object) {\n      var o = new THREE.Vector3();\n      object.updateMatrixWorld();\n      o.setFromMatrixPosition(object.matrixWorld);\n      object.sound.panner.setPosition(o.x, o.y, o.z);\n\n      if (object.name == 'cone') {\n        var p = new THREE.Vector3();\n        var q = new THREE.Vector3();\n        var m = object.matrixWorld;\n\n        var mx = m.elements[12];\n        var my = m.elements[13];\n        var mz = m.elements[14];\n\n        var vec = new THREE.Vector3(0, 0, 1);\n\n        m.elements[12] = m.elements[13] = m.elements[14] = 0;\n\n        vec.applyMatrix4(m);\n        vec.normalize();\n        object.sound.panner.setOrientation(vec.x, vec.y, vec.z);\n\n        m.elements[12] = mx;\n        m.elements[13] = my;\n        m.elements[14] = mz;\n      }\n    } }, { key: 'loadSound', value: function loadSound(\n\n    soundFileName, audio, mute, object) {\n      var context = audio.context;\n      var mainMixer = context.createGain();\n\n      var promise = new Promise(function (resolve, reject) {\n\n        fetch(soundFileName).\n        then(function (response) {return response.arrayBuffer();}).\n        then(function (buffer) {return context.decodeAudioData(buffer, function (decodedData) {\n            if (object && object.type === \"SoundObject\") {\n              /* attach omnidirectional sound */\n              object = object.omniSphere;\n            }\n\n            if (object && object.sound) {\n              object.sound.source.stop();\n              object.sound.source.disconnect(object.sound.scriptNode);\n              object.sound.scriptNode.disconnect(context.destination);\n            }\n\n            var sound = {};\n            sound.mainMixer = mainMixer;\n\n            sound.analyser = context.createAnalyser();\n            sound.analyser.smoothingTimeConstant = 0.5;\n            sound.analyser.fftSize = 1024;\n\n            sound.scriptNode = context.createScriptProcessor(2048, 1, 1);\n            sound.scriptNode.connect(context.destination);\n\n            sound.source = context.createBufferSource();\n            sound.source.loop = true;\n            sound.source.connect(sound.scriptNode);\n\n            sound.panner = context.createPanner();\n            sound.panner.panningModel = 'HRTF';\n            sound.panner.distanceModel = 'inverse';\n            sound.panner.refDistance = 100;\n            //sound.panner.rolloffFactor = 5;\n\n            sound.volume = context.createGain();\n            sound.source.connect(sound.volume);\n            sound.volume.connect(sound.analyser);\n            sound.volume.connect(sound.panner);\n            sound.panner.connect(mainMixer);\n            mainMixer.connect(audio.destination);\n            mainMixer.gain.value = mute ? 0 : 1;\n\n            sound.source.buffer = decodedData;\n            sound.source.start(context.currentTime + 0.020);\n            resolve(sound);\n\n            if (object && object.name == 'omniSphere') {\n              sound.scriptNode.onaudioprocess = function () {\n                var array = new Uint8Array(sound.analyser.frequencyBinCount);\n                sound.analyser.getByteFrequencyData(array);\n                var values = 0;\n                var length = array.length;\n                for (var i = 0; i < length; i++) {values += array[i];}\n                var average = values / length;\n                object.material.opacity = _helpers2.default.mapRange(average, 50, 100, 0.65, 0.95);\n              };\n            }\n          });});\n      });\n\n      promise.\n      catch(function (err) {\n        alert('could not load file');\n        console.log(err);\n      });\n\n      return promise;\n    } }, { key: 'isUnderMouse', value: function isUnderMouse(\n\n    ray) {\n      return ray.intersectObject(this.containerObject, true).length > 0;\n    } }, { key: 'select', value: function select(\n\n    main) {\n      this.nonScaledMouseOffsetY = main.nonScaledMouse.y;\n    } }, { key: 'move', value: function move(\n\n    main) {\n      var pointer = void 0;\n\n      if (main.perspectiveView) {\n        var posY = _helpers2.default.mapRange(\n        main.nonScaledMouse.y - this.nonScaledMouseOffsetY,\n        -0.5,\n        0.5,\n        -200,\n        200);\n\n\n        pointer = this.containerObject.position;\n        if (pointer.y > -200 || pointer.y < 200) pointer.y += posY;\n\n        // clamp\n        pointer.y = Math.max(Math.min(pointer.y, 300), -300);\n\n        this.nonScaledMouseOffsetY = main.nonScaledMouse.y;\n      } else {\n        pointer = main.mouse;\n        pointer.y = this.containerObject.position.y;\n      }\n\n      if (this.trajectory) this.trajectory.move(pointer, main.nonScaledMouse, main.perspectiveView);\n\n      this.setPosition(pointer);\n    } }, { key: 'setPosition', value: function setPosition(\n\n    position) {\n      this.containerObject.position.copy(position);\n      this.axisHelper.position.copy(position);\n      this.altitudeHelper.position.copy(position);\n      this.altitudeHelper.position.y = 0;\n      this.raycastSphere.position.copy(position);\n\n      if (this.cones[0]) {\n        for (var i in this.cones) {\n          this.setAudioPosition(this.cones[i]);\n        }\n      }\n\n      if (this.omniSphere.sound) {\n        this.setAudioPosition(this.omniSphere);\n      }\n    } }, { key: 'addToScene', value: function addToScene(\n\n    scene) {\n      scene.add(this.containerObject);\n    } }, { key: 'setActive', value: function setActive(\n\n    main) {\n      if (this.trajectory) {\n        this.trajectory.setActive();\n        this.trajectory.setMouseOffset(main.nonScaledMouse, main.mouse);\n      }\n    } }, { key: 'setInactive', value: function setInactive()\n\n    {\n      if (this.trajectory) {\n        this.trajectory.setInactive();\n      }\n    } }, { key: 'changeRadius', value: function changeRadius()\n\n    {\n      if (this.omniSphere.sound && this.omniSphere.sound.volume) {\n        var r = 0.5 + 0.5 * this.omniSphere.sound.volume.gain.value;\n        this.omniSphere.scale.x = this.omniSphere.scale.y = this.omniSphere.scale.z = r;\n      } else\n      {\n        this.omniSphere.scale.x = this.omniSphere.scale.y = this.omniSphere.scale.z = 1;\n      }\n    } }, { key: 'changeLength', value: function changeLength(\n\n    cone) {\n      var r = cone.sound.spread * 90;\n      var l = cone.sound.volume.gain.value * 50 + 50;\n      cone.sound.panner.coneInnerAngle = Math.atan(r / l) * (180 / Math.PI);\n      cone.sound.panner.coneOuterAngle = cone.sound.panner.coneInnerAngle * 1.5;\n\n      cone.geometry.dynamic = true;\n\n      var circVertices = cone.geometry.vertices.slice(0, -1);\n      var origin = cone.geometry.vertices[cone.geometry.vertices.length - 1];\n\n      circVertices.forEach(function (vertex) {\n        var v = new THREE.Vector3().subVectors(vertex, origin).normalize();\n        vertex.copy(origin.clone().addScaledVector(v, l));\n      });\n\n      cone.geometry.verticesNeedUpdate = true;\n    } }, { key: 'changeWidth', value: function changeWidth(\n\n    cone) {\n      var r = cone.sound.spread * 90;\n      var l = cone.sound.volume.gain.value * 50 + 50;\n      cone.sound.panner.coneInnerAngle = Math.atan(r / l) * (180 / Math.PI);\n      cone.sound.panner.coneOuterAngle = cone.sound.panner.coneInnerAngle * 3;\n\n      cone.geometry.dynamic = true;\n\n      var circVertices = cone.geometry.vertices.slice(0, -1);\n      var center = new THREE.Vector3();\n      center.lerpVectors(circVertices[0], circVertices[Math.round(circVertices.length / 2)], 0.5);\n\n      circVertices.forEach(function (vertex) {\n        var v = new THREE.Vector3().subVectors(vertex, center).normalize();\n        vertex.copy(center.clone().addScaledVector(v, r));\n      });\n\n      cone.geometry.verticesNeedUpdate = true;\n    } }, { key: 'pointCone', value: function pointCone(\n\n    cone, point) {\n      var coneRotation = new THREE.Vector3();\n      coneRotation.subVectors(point, this.containerObject.position);\n      cone.lookAt(coneRotation);\n      this.setAudioPosition(cone);\n\n      var longlat = function (vector3) {\n        // taken from https://gist.github.com/nicoptere/2f2571db4b454bb18cd9\n        vector3.normalize();\n\n        //longitude = angle of the vector around the Y axis\n        //-( ) : negate to flip the longitude (3d space specific )\n        //- PI / 2 to face the Z axis\n        var lng = -Math.atan2(-vector3.z, -vector3.x) - Math.PI / 2;\n\n        //to bind between -PI / PI\n        if (lng < -Math.PI) lng += Math.PI * 2;\n\n        //latitude : angle between the vector & the vector projected on the XZ plane on a unit sphere\n\n        //project on the XZ plane\n        var p = new THREE.Vector3(vector3.x, 0, vector3.z);\n        //project on the unit sphere\n        p.normalize();\n\n        //compute the angle ( both vectors are normalized, no division by the sum of lengths )\n        var lat = Math.acos(p.dot(vector3));\n\n        //invert if Y is negative to ensure the latitude is between -PI/2 & PI / 2\n        if (vector3.y < 0) lat *= -1;\n\n        return [lng, lat];\n\n      }(coneRotation);\n      cone.long = longlat[0];\n      cone.lat = longlat[1];\n    }\n\n    // Needs to be refactored - also lives in guiwindow\n  }, { key: 'pointConeMagic', value: function pointConeMagic(cone, lat, long) {\n      // adapted from https://gist.github.com/nicoptere/2f2571db4b454bb18cd9\n      var v = function lonLatToVector3(lng, lat)\n      {\n        //flips the Y axis\n        lat = Math.PI / 2 - lat;\n\n        //distribute to sphere\n        return new THREE.Vector3(\n        Math.sin(lat) * Math.sin(lng),\n        Math.cos(lat),\n        Math.sin(lat) * Math.cos(lng));\n\n\n      }(long, lat);\n      if (v.x === 0) {v.x = 0.0001;}\n      var point = this.containerObject.position.clone().add(v);\n      this.pointCone(cone, point);\n\n    } }, { key: 'applySoundToCone', value: function applySoundToCone(\n\n    cone, sound) {\n\n      sound.scriptNode.onaudioprocess = function () {\n        var array = new Uint8Array(sound.analyser.frequencyBinCount);\n        sound.analyser.getByteFrequencyData(array);\n        var values = 0;\n        var length = array.length;\n        for (var i = 0; i < length; i++) {values += array[i];}\n        var average = values / length;\n        cone.material.opacity = _helpers2.default.mapRange(average, 50, 100, 0.65, 0.95);\n      };\n\n      sound.spread = cone.sound.spread;\n      sound.panner.refDistance = cone.sound.panner.refDistance;\n      sound.panner.distanceModel = cone.sound.panner.distanceModel;\n      sound.panner.coneInnerAngle = cone.sound.panner.coneInnerAngle;\n      sound.panner.coneOuterAngle = cone.sound.panner.coneOuterAngle;\n      sound.panner.coneOuterGain = cone.sound.panner.coneOuterGain;\n      sound.volume.gain.value = cone.sound.volume.gain.value;\n      cone.sound = sound;\n    } }, { key: 'removeCone', value: function removeCone(\n\n    cone) {\n      cone.sound.source.stop();\n      cone.sound.source.disconnect(cone.sound.scriptNode);\n      cone.sound.scriptNode.disconnect(this.audio.context.destination);\n      cone.sound = null;\n      var i = this.cones.indexOf(cone);\n      this.cones.splice(i, 1);\n      this.containerObject.remove(cone);\n    } }, { key: 'removeFromScene', value: function removeFromScene(\n\n    scene) {\n      scene.remove(this.containerObject, true);\n      scene.remove(this.altitudeHelper, true);\n      scene.remove(this.axisHelper, true);\n      scene.remove(this.trajectory, true);\n\n      for (var i in this.cones) {\n        this.cones[i].sound.source.stop();\n      }\n\n      if (this.omniSphere.sound && this.omniSphere.sound.source) {\n        this.omniSphere.sound.source.stop();\n      }\n    } }, { key: 'pause', value: function pause()\n\n    {\n      this.isPaused = true;\n    } }, { key: 'unpause', value: function unpause()\n    {\n      this.isPaused = false;\n    } }, { key: 'mute', value: function mute(\n\n    main) {\n      this.isMuted = true;\n      this.checkMuteState(main);\n    } }, { key: 'unmute', value: function unmute(\n    main) {\n      this.isMuted = false;\n      this.checkMuteState(main);\n    } }, { key: 'turnVisible', value: function turnVisible()\n\n    {\n      this.containerObject.visible = true;\n      this.axisHelper.visible = true;\n      this.altitudeHelper.visible = true;\n    } }, { key: 'turnInvisible', value: function turnInvisible()\n\n    {\n      this.containerObject.visible = false;\n      this.axisHelper.visible = false;\n      this.altitudeHelper.visible = false;\n    } }, { key: 'checkMuteState', value: function checkMuteState(\n\n    main) {\n      if (main.isMuted || this.isMuted) {\n        this.cones.forEach(function (cone) {return cone.sound.mainMixer.gain.value = 0;});\n        if (this.omniSphere.sound && this.omniSphere.sound.mainMixer) {\n          this.omniSphere.sound.mainMixer.gain.value = 0;\n        }\n      } else\n      {\n        this.cones.forEach(function (cone) {return cone.sound.mainMixer.gain.value = 1;});\n        if (this.omniSphere.sound && this.omniSphere.sound.mainMixer) {\n          this.omniSphere.sound.mainMixer.gain.value = 1;\n        }\n      }\n    } }, { key: 'followTrajectory', value: function followTrajectory(\n\n    mute) {\n      if (this.trajectory && !this.isPaused && !this.isMuted && !mute) {\n        this.trajectoryClock -= this.movementDirection * this.movementIncrement;\n\n        if (this.trajectoryClock >= 1) {\n          if (this.trajectory.spline.closed) {\n            this.trajectoryClock = 0;\n          } else {\n            this.movementDirection = -this.movementDirection;\n            this.trajectoryClock = 1;\n          }\n        }\n\n        if (this.trajectoryClock < 0) {\n          if (this.trajectory.spline.closed) {\n            this.trajectoryClock = 1;\n          } else {\n            this.movementDirection = -this.movementDirection;\n            this.trajectoryClock = 0;\n          }\n        }\n\n        var pointOnTrajectory = this.trajectory.spline.getPointAt(this.trajectoryClock);\n        this.containerObject.position.copy(pointOnTrajectory);\n        this.raycastSphere.position.copy(pointOnTrajectory);\n        this.altitudeHelper.position.copy(pointOnTrajectory);\n        this.axisHelper.position.copy(pointOnTrajectory);\n        this.altitudeHelper.position.y = 0;\n\n        if (this.cones[0]) {\n          for (var i in this.cones) {\n            this.setAudioPosition(this.cones[i]);\n          }\n        }\n        if (this.omniSphere.sound) {\n          this.setAudioPosition(this.omniSphere);\n        }\n      }\n    } }, { key: 'calculateMovementSpeed', value: function calculateMovementSpeed()\n\n    {\n      if (this.trajectory) {\n        this.movementIncrement = this.movementSpeed / this.trajectory.spline.getLength(10);\n      }\n    } }, { key: 'toJSON', value: function toJSON()\n\n    {\n      return JSON.stringify({\n        filename: this.omniSphere.sound && this.omniSphere.sound && this.omniSphere.sound.name || null,\n        volume: this.omniSphere && this.omniSphere.sound && this.omniSphere.sound.volume.gain.value || null,\n        position: this.containerObject.position,\n        movementSpeed: this.movementSpeed,\n        trajectory: this.trajectory && this.trajectory.points || null,\n        cones: this.cones.map(function (c) {\n          console.log(c);\n          return {\n            filename: c.filename,\n            position: {\n              lat: c.lat,\n              long: c.long },\n\n            volume: c.sound.volume.gain.value,\n            spread: c.sound.spread,\n            color: c.randGreen };\n\n        }) });\n\n    } }, { key: 'fromJSON', value: function fromJSON(\n\n    json) {var _this = this;\n      var object = JSON.parse(json);\n      this.containerObject.position.copy(object.position);\n      this.altitudeHelper.position.copy(object.position);\n      this.raycastSphere.position.copy(object.position);\n      this.axisHelper.position.copy(object.position);\n\n      if (object.filename && object.volume) {\n        this.loadSound('assets/sounds/' + object.filename, this.audio, false, this).then(function (sound) {\n          _this.omniSphere.sound = sound;\n          _this.omniSphere.sound.name = object.filename;\n          _this.omniSphere.sound.volume.gain.value = object.volume;\n          _this.setAudioPosition(_this.omniSphere);\n        });\n      }\n\n      object.cones.forEach(function (c) {\n        var cone = void 0;\n        _this.loadSound('assets/sounds/' + c.filename, _this.audio, false).then(function (sound) {\n          cone = _this.createCone(sound, c.color);\n          cone.filename = c.filename;\n          cone.sound.volume.gain.value = c.volume;\n          cone.sound.spread = c.spread;\n          _this.changeLength(cone);\n          _this.changeWidth(cone);\n          _this.gui.addCone(cone);\n          _this.pointConeMagic(cone, c.position.lat, c.position.long);\n        });\n      });\n\n      this.movementSpeed = object.movementSpeed;\n    } }]);return SoundObject;}();exports.default = SoundObject;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/components/soundobject.js\n// module id = 15\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/components/soundobject.js?");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("'use strict';(function (self) {\n  'use strict';\n\n  if (self.fetch) {\n    return;\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && function () {\n      try {\n        new Blob();\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self };\n\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'];\n\n\n    var isDataView = function isDataView(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj);\n    };\n\n    var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n    };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name');\n    }\n    return name.toLowerCase();\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value;\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function next() {\n        var value = items.shift();\n        return { done: value === undefined, value: value };\n      } };\n\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function () {\n        return iterator;\n      };\n    }\n\n    return iterator;\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function (value, name) {\n        this.append(name, value);\n      }, this);\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function (name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function (name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ',' + value : value;\n  };\n\n  Headers.prototype['delete'] = function (name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function (name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null;\n  };\n\n  Headers.prototype.has = function (name) {\n    return this.map.hasOwnProperty(normalizeName(name));\n  };\n\n  Headers.prototype.set = function (name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function (callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function () {\n    var items = [];\n    this.forEach(function (value, name) {items.push(name);});\n    return iteratorFor(items);\n  };\n\n  Headers.prototype.values = function () {\n    var items = [];\n    this.forEach(function (value) {items.push(value);});\n    return iteratorFor(items);\n  };\n\n  Headers.prototype.entries = function () {\n    var items = [];\n    this.forEach(function (value, name) {items.push([name, value]);});\n    return iteratorFor(items);\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'));\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function (resolve, reject) {\n      reader.onload = function () {\n        resolve(reader.result);\n      };\n      reader.onerror = function () {\n        reject(reader.error);\n      };\n    });\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise;\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise;\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('');\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0);\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer;\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function (body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        throw new Error('unsupported BodyInit type');\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function () {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected;\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob);\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob');\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]));\n        }\n      };\n\n      this.arrayBuffer = function () {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer);\n        }\n      };\n    }\n\n    this.text = function () {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected;\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob);\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text');\n      } else {\n        return Promise.resolve(this._bodyText);\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function () {\n        return this.text().then(decode);\n      };\n    }\n\n    this.json = function () {\n      return this.text().then(JSON.parse);\n    };\n\n    return this;\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method;\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (typeof input === 'string') {\n      this.url = input;\n    } else {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read');\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests');\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function () {\n    return new Request(this, { body: this._bodyInit });\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body.trim().split('&').forEach(function (bytes) {\n      if (bytes) {\n        var split = bytes.split('=');\n        var name = split.shift().replace(/\\+/g, ' ');\n        var value = split.join('=').replace(/\\+/g, ' ');\n        form.append(decodeURIComponent(name), decodeURIComponent(value));\n      }\n    });\n    return form;\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    rawHeaders.split('\\r\\n').forEach(function (line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers;\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = 'status' in options ? options.status : 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function () {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url });\n\n  };\n\n  Response.error = function () {\n    var response = new Response(null, { status: 0, statusText: '' });\n    response.type = 'error';\n    return response;\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function (url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code');\n    }\n\n    return new Response(null, { status: status, headers: { location: url } });\n  };\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function (input, init) {\n    return new Promise(function (resolve, reject) {\n      var request = new Request(input, init);\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function () {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '') };\n\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function () {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function () {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function (value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    });\n  };\n  self.fetch.polyfill = true;\n})(typeof self !== 'undefined' ? self : undefined);\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 16\n// module chunks = 0\n//# sourceURL=webpack:///./~/whatwg-fetch/fetch.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n\nvar _helpers = __webpack_require__(8);var _helpers2 = _interopRequireDefault(_helpers);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}var\n\nSoundTrajectory = function () {\n  function SoundTrajectory(main, points) {_classCallCheck(this, SoundTrajectory);\n    this.type = 'SoundTrajectory';\n    this.splinePoints = points;\n    this.isActive = true;\n    this.pointObjects;\n    this.spline;\n    this.parentSoundObject;\n    this.selectedPoint;\n    this.mouseOffsetX = 0;\n    this.mouseOffsetY = 0;\n    this.nonScaledMouseOffsetY = 0;\n\n    this.cursor = new THREE.Mesh(\n    new THREE.SphereGeometry(15),\n    new THREE.MeshBasicMaterial({\n      color: 0xff1169,\n      transparent: true,\n      opacity: 0.5 }));\n\n\n    this.cursor.visible = false;\n    main.scene.add(this.cursor);\n\n    /**\n                                  * First call to renderPath happens in update trajectory function. From there\n                                  * on the function recursively calls itself at the end of each draw.\n                                  */\n    this.renderPath();\n  }\n\n  /**\n     * A recursive function that draws all the THREE geometries, including\n     *\n     * visual and collider spheres as control points on the trajectory spline\n     * (grouped as points in the pointsObjects array),\n     *\n     * the CatmullRom spline that is created from splinePoints, which is populated\n     * under addPoint function below, and repopulated whenever a trajectory is\n     * moved or a control point is removed from the spline,\n     *\n     * and the line geometry which is assigned as a mesh for the said spline for it\n     * to be drawn on screen.\n     */_createClass(SoundTrajectory, [{ key: 'renderPath', value: function renderPath()\n    {\n      var points = this.splinePoints;\n\n      this.pointObjects = function () {\n        var sphere = new THREE.SphereGeometry(10);\n        var sphereMat = new THREE.MeshBasicMaterial({ color: 0x999999 });\n\n        var collider = new THREE.SphereGeometry(20);\n        var colliderMat = new THREE.MeshBasicMaterial({\n          color: 0x999999,\n          transparent: true,\n          opacity: 0,\n          depthWrite: false });\n\n        var colliderMesh = new THREE.Mesh(collider, colliderMat);\n\n        var pointObjects = [];\n\n        points.forEach(function (point) {\n          var sphereMesh = new THREE.Mesh(sphere, sphereMat.clone());\n          var group = new THREE.Object3D();\n\n          group.add(sphereMesh, colliderMesh.clone());\n          group.position.x = point.x;\n          group.position.y = point.y;\n          group.position.z = point.z;\n\n          pointObjects.push(group);\n        });\n\n        return pointObjects;\n      }();\n\n      this.spline = new THREE.CatmullRomCurve3(this.splinePoints);\n      this.spline.type = 'centripetal';\n\n      /*\n                                         * This measures the distance between the start and end points of a trajectory\n                                         * and if the distance is small enough it turnes the spline into a closed curve.\n                                         * This is checked in each frame so that the user can interactively determine\n                                         * if a trajectory is closed (looping) or open (back-and-forth).\n                                         */\n      var begEndDistance = this.splinePoints[0].distanceTo(this.splinePoints[this.splinePoints.length - 1]);\n\n      if (begEndDistance < 40) {\n        this.spline.closed = true;\n      } else {\n        this.spline.closed = false;\n      }\n\n      var geometry = new THREE.Geometry();\n\n      geometry.vertices = this.spline.getPoints(200);\n\n      var material = new THREE.LineBasicMaterial({\n        color: 0x999999,\n        linewidth: 2,\n        opacity: 0.4 });\n\n\n      this.spline.mesh = new THREE.Line(geometry, material);\n    }\n\n    /**\n       * Creates a global object array that includes both the pointObjects (i.e. vectors\n       * for both visible and collider spheres) and the spline mesh which is used to\n       * draw the line that makes up the spline.\n       */ }, { key: 'removeFromScene',\n\n\n\n\n    /**\n                                        * Removes each object in the object array (that pertain to a single\n                                        * trajectory) from the scene.\n                                        */value: function removeFromScene(\n    scene, isUpdating) {\n      this.objects.forEach(function (obj) {\n        scene.remove(obj, true);\n      });\n      if (!isUpdating) {\n        scene.remove(this.cursor, true);\n      }\n    }\n\n    /**\n       * Adds each object in the object array (that pertain to a single\n       * trajectory) to the scene.\n       */ }, { key: 'addToScene', value: function addToScene(\n    scene) {\n      this.objects.forEach(function (obj) {\n        scene.add(obj);\n      });\n\n    }\n\n    /**\n       * Returns true if a particular object is under the mouse (called from\n       * index.html)\n       */ }, { key: 'isUnderMouse', value: function isUnderMouse(\n    raycaster) {\n      if (this.isActive) {\n        return raycaster.intersectObjects(this.objects, true).length > 0;\n      }\n    }\n\n    /**\n       * Determines if it is a control point or the curve itself that's under the\n       * mouse. Returns the collided object.\n       */ }, { key: 'objectUnderMouse', value: function objectUnderMouse(\n    raycaster) {\n      var intersects = raycaster.intersectObjects(this.objects, true);\n\n      if (intersects.length > 0) {\n        if (intersects[0].object.type === 'Line') {\n          return intersects[Math.floor(intersects.length / 2)];\n        }\n\n        return intersects[0];\n      }\n\n      return null;\n    } }, { key: 'hideCursor', value: function hideCursor()\n\n    {\n      this.cursor.visible = false;\n    } }, { key: 'showCursor', value: function showCursor(\n    object, point) {\n      this.cursor.visible = true;\n      if (object === this.spline.mesh) {\n        this.cursor.position.copy(point);\n      } else\n      {\n        this.cursor.position.copy(object.parent.position);\n      }\n    }\n\n    /* Keeps record of the mouse offset after the initial click. */ }, { key: 'setMouseOffset', value: function setMouseOffset(\n    nonScaledMouse, point) {\n      this.mouseOffsetX = point.x;\n      this.mouseOffsetY = point.z;\n      this.nonScaledMouseOffsetY = nonScaledMouse.y;\n    }\n\n    /* Moves a single control point on the spline or the entire trajectory. */ }, { key: 'move', value: function move(\n    mouse, nonScaledMouse, perspectiveView) {var _this = this;\n      this.hideCursor();\n      if (this.selectedPoint) {\n        var i = this.pointObjects.indexOf(this.selectedPoint);\n\n        if (i > -1) {\n          /**\n                      * If the camera is in perspective view, the control points can only be\n                      * moved in the Y-axis (height).\n                      */\n          if (perspectiveView) {\n            var dy = nonScaledMouse.y - this.nonScaledMouseOffsetY;\n            dy = _helpers2.default.mapRange(dy, -0.5, 0.5, -200, 200);\n            this.splinePoints[i].y = Math.min(Math.max(this.splinePoints[i].y + dy, -300), 300);\n            this.nonScaledMouseOffsetY = nonScaledMouse.y;\n          } else {\n            /* Otherwise the mouse position vector is copied to the control point. */\n            var pointer = mouse.clone();\n            pointer.y = this.splinePoints[i].y;\n            this.splinePoints[i].copy(pointer);\n          }\n\n          this.updateTrajectory();\n          this.selectPoint(this.pointObjects[i]);\n        }\n      } else {\n        /**\n               * This moves the entire shape when the parent sound object is moved around.\n               * The same XZ versus Y dimension principles apply depending which view mode\n               * the camera is in.\n               */\n        if (perspectiveView) {(function () {\n            var posY = _helpers2.default.mapRange(\n            nonScaledMouse.y - _this.nonScaledMouseOffsetY,\n            -0.5,\n            0.5,\n            -200,\n            200);\n\n\n            _this.splinePoints.forEach(function (pt) {\n              pt.y = Math.min(Math.max(-300, pt.y + posY), 300);\n            });\n\n            _this.nonScaledMouseOffsetY = nonScaledMouse.y;})();\n        } else {(function () {\n            /**\n                               * Mouse movement differentials based on initial click position stored\n                               * in setMouseOffset() is calculated here.\n                               */\n            var dx = mouse.x - _this.mouseOffsetX;\n            var dy = mouse.z - _this.mouseOffsetY;\n            _this.mouseOffsetX = mouse.x;\n            _this.mouseOffsetY = mouse.z;\n\n            /**\n                                           * Maps mouse position differentials to the splinePoints, which are in\n                                           * return used in the render path function to update the trajectories in\n                                           * each frame.\n                                           */\n            _this.splinePoints.forEach(function (pt) {\n              pt.x += dx;\n              pt.z += dy;\n            });})();\n        }\n\n        this.updateTrajectory();\n      }\n    } }, { key: 'setActive', value: function setActive()\n\n    {\n      this.isActive = true;\n\n      this.pointObjects.forEach(function (obj) {\n        obj.children[0].material.color.setHex(0x999999);\n      });\n\n      this.spline.mesh.material.color.setHex(0x999999);\n    } }, { key: 'setInactive', value: function setInactive()\n\n    {\n      this.hideCursor();\n      this.deselectPoint();\n      this.isActive = false;\n\n      this.pointObjects.forEach(function (obj) {\n        obj.children[0].material.color.setHex(0xcccccc);\n      });\n\n      this.spline.mesh.material.color.setHex(0xcccccc);\n    } }, { key: 'select', value: function select(\n\n    intersect, main) {\n      if (!intersect) return;\n\n      var obj = intersect.object;\n\n      if (obj.type === 'Line') {\n        this.addPoint(intersect.point);\n      } else {\n        this.selectPoint(obj.parent);\n        this.setMouseOffset(main.nonScaledMouse, intersect.point);\n      }\n    } }, { key: 'selectPoint', value: function selectPoint(\n\n    obj) {\n      this.deselectPoint();\n      this.selectedPoint = obj;\n      obj.children[0].material.color.set(0xff0077);\n    } }, { key: 'deselectPoint', value: function deselectPoint()\n\n    {\n      if (this.selectedPoint) {\n        this.selectedPoint.children[0].material.color.set(0x999999);\n        this.selectedPoint = null;\n      }\n    }\n\n    /**\n       * Adds new points to an existing trajectory. Updates the splinePoints array\n       * and calls the updateTrajectory function as a result.\n       */ }, { key: 'addPoint', value: function addPoint(\n    position) {\n      var minDistance = Number.MAX_VALUE;\n      var minPoint = 1;\n      var prevDistToSplinePoint = -1;\n      var closestSplinePoint = 0;\n\n      for (var t = 0; t < 1; t += 1 / 200.0) {\n        var pt = this.spline.getPoint(t);\n\n        var distToSplinePoint = this.splinePoints[closestSplinePoint].distanceToSquared(pt);\n        if (distToSplinePoint > prevDistToSplinePoint) {\n          closestSplinePoint += 1;\n\n          if (closestSplinePoint >= this.splinePoints.length) {\n            closestSplinePoint = 0;\n          }\n        }\n\n        prevDistToSplinePoint = this.splinePoints[closestSplinePoint].distanceToSquared(pt);\n\n        var distToPoint = pt.distanceToSquared(position);\n        if (distToPoint < minDistance) {\n          minDistance = distToPoint;\n          minPoint = closestSplinePoint;\n        }\n      }\n\n      this.splinePoints.splice(minPoint, 0, position);\n      this.updateTrajectory();\n      this.selectPoint(this.pointObjects[minPoint]);\n    }\n\n    /* Removes points from the splinePoints array. */ }, { key: 'removePoint', value: function removePoint()\n    {\n      var i = this.pointObjects.indexOf(this.selectedPoint);\n      this.splinePoints.splice(i, 1);\n      this.deselectPoint();\n      this.updateTrajectory();\n    } }, { key: 'turnVisible', value: function turnVisible()\n\n    {\n      this.spline.mesh.visible = true;\n      this.pointObjects.forEach(function (point) {\n        point.visible = true;\n      });\n    } }, { key: 'turnInvisible', value: function turnInvisible()\n\n    {\n      this.spline.mesh.visible = false;\n      this.pointObjects.forEach(function (point) {\n        point.visible = false;\n      });\n    }\n\n    /**\n       * Updates trajectory by calling renderPath. First called inside addPoint()\n       * and this initates the renderPath() recursion.\n       */ }, { key: 'updateTrajectory', value: function updateTrajectory()\n    {\n      var scene = this.spline.mesh.parent;\n      this.removeFromScene(scene, true);\n      this.renderPath();\n      this.addToScene(scene);\n    } }, { key: 'objects', get: function get() {return [].concat(this.pointObjects, this.spline.mesh);} }]);return SoundTrajectory;}();exports.default = SoundTrajectory;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/components/soundtrajectory.js\n// module id = 17\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/components/soundtrajectory.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n__webpack_require__(16);\nvar _helpers = __webpack_require__(8);var _helpers2 = _interopRequireDefault(_helpers);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}var\n\nSoundZone = function () {\n  function SoundZone(main, points) {_classCallCheck(this, SoundZone);\n    this.type = 'SoundZone';\n    this.isActive = true;\n    this.audio = main.audio;\n\n    this.mouse = main.mouse;\n    this.scene = main.scene;\n\n    this.points = points;\n    this.splinePoints = points;\n    this.pointObjects;\n    this.spline;\n    this.shape;\n    this.sound;\n    this.loaded = false;\n    this.isPlaying = false;\n    this.selectedPoint;\n    this.mouseOffsetX = 0, this.mouseOffsetY = 0;\n    this.volume = 1;\n\n    this.containerObject = new THREE.Group();\n    this.cursor = new THREE.Mesh(\n    new THREE.SphereGeometry(15),\n    new THREE.MeshBasicMaterial({\n      color: 0xff1169,\n      transparent: true,\n      opacity: 0.5 }));\n\n\n    this.cursor.visible = false;\n    this.containerObject.add(this.cursor);\n\n    this.isInitialized = false;\n\n    this.renderPath();\n  }_createClass(SoundZone, [{ key: 'underUser', value: function underUser(\n\n    audio) {\n      if (this.sound && !this.isPlaying && this.loaded) {\n\n        this.sound.source = audio.context.createBufferSource();\n        this.sound.source.buffer = this.sound.buffer;\n        this.sound.source.loop = true;\n        this.sound.source.volume = audio.context.createGain();\n        this.sound.source.volume.gain.value = this.volume;\n        this.sound.source.connect(this.sound.source.volume);\n        this.sound.source.volume.connect(this.sound.volume);\n\n        this.sound.source.start(audio.context.currentTime);\n\n        this.sound.volume.gain.setTargetAtTime(1.0, audio.context.currentTime + 0.1, 0.1);\n        this.isPlaying = true;\n      }\n    } }, { key: 'notUnderUser', value: function notUnderUser(\n\n    audio) {\n      if (this.sound && this.isPlaying && this.loaded) {\n        this.sound.volume.gain.setTargetAtTime(0.0, audio.context.currentTime, 0.02);\n        this.sound.source.stop(audio.context.currentTime + 0.1);\n        this.isPlaying = false;\n      }\n    }\n\n    // remove sound file\n  }, { key: 'clear', value: function clear() {\n      // stop audio stream if currently playing\n      if (this.isPlaying) {\n        this.sound.source.stop();\n      }\n      this.isPlaying = false;\n      this.loaded = false;\n      this.mainMixer = null;\n      this.sound = {};\n    } }, { key: 'loadSound', value: function loadSound(\n\n    soundFileName, audio, mute) {var _this = this;\n      var context = audio.context;\n      this.filename = soundFileName;\n\n      var promise = fetch(soundFileName).\n      then(function (response) {return response.arrayBuffer();}).\n      then(function (buffer) {return context.decodeAudioData(buffer, function (decodedData) {\n          _this.clear();\n          _this.sound.name = soundFileName;\n          _this.sound.source = context.createBufferSource();\n          _this.mainMixer = context.createGain();\n          _this.sound.volume = context.createGain();\n          _this.sound.source.volume = context.createGain();\n          _this.sound.source.connect(_this.sound.source.volume);\n          _this.sound.source.volume.connect(_this.sound.volume);\n          _this.sound.volume.connect(_this.mainMixer);\n          _this.mainMixer.connect(audio.destination);\n          _this.mainMixer.gain.value = mute ? 0 : 1;\n          _this.sound.volume.gain.value = 0.0;\n          _this.sound.buffer = decodedData;\n          _this.loaded = true;\n        });});\n\n      promise.\n      catch(function (err) {\n        alert('could not load file');\n        console.log(err);\n      });\n\n      return promise;\n    } }, { key: 'renderPath', value: function renderPath(\n\n    args) {var _this2 = this;\n      // splinePoints control the curve of the path\n      var points = this.splinePoints;\n\n      // setup\n      var sphere = new THREE.SphereGeometry(10);\n      var sphereMat = new THREE.MeshBasicMaterial({ color: 0xff1169 });\n\n      var collider = new THREE.SphereGeometry(15);\n      var colliderMat = new THREE.MeshBasicMaterial({\n        color: 0xff1169,\n        transparent: true,\n        opacity: 0,\n        depthWrite: false });\n\n\n      var colliderMesh = new THREE.Mesh(collider, colliderMat);\n\n      if (!this.isInitialized) {\n        this.pointObjects = [];\n        // place a meshgroup at each point in array\n        points.forEach(function (point) {\n          var sphereMesh = new THREE.Mesh(sphere, sphereMat.clone());\n          var group = new THREE.Object3D();\n\n          group.add(sphereMesh, colliderMesh.clone());\n          group.position.copy(point);\n\n          _this2.pointObjects.push(group);\n        });\n        this.splinePoints = this.pointObjects.map(function (pt) {return pt.position;});\n      } else\n      if (args) {\n        if (args.updateType === \"delete\") {\n          var splicedPoint = this.pointObjects.splice(args.index, 1);\n          this.containerObject.remove(splicedPoint[0], true);\n        } else\n        if (args.updateType === \"add\") {\n          var insertedPoint = new THREE.Object3D();\n          insertedPoint.add(\n          new THREE.Mesh(sphere, sphereMat.clone()),\n          colliderMesh.clone());\n\n          insertedPoint.position.copy(this.splinePoints[args.index]);\n          this.pointObjects.splice(args.index, 0, insertedPoint);\n          this.containerObject.add(insertedPoint);\n        }\n        this.splinePoints = this.pointObjects.map(function (pt) {return pt.position;});\n      }\n\n      this.spline = new THREE.CatmullRomCurve3(this.splinePoints);\n      this.spline.type = 'centripetal';\n      this.spline.closed = true;\n\n      var geometry = new THREE.Geometry();\n      geometry.vertices = this.spline.getPoints(200);\n      var material = new THREE.LineBasicMaterial({\n        color: 0xff1169,\n        linewidth: 1,\n        transparent: true,\n        opacity: 0.4 });\n\n\n      this.spline.mesh = new THREE.Line(geometry, material);\n\n      // fill the path\n      var rotatedPoints = this.spline.getPoints(200);\n      rotatedPoints.forEach(function (vertex) {\n        vertex.y = vertex.z;\n        vertex.z = 0.0;\n      });\n      var shapeFill = new THREE.Shape();\n      shapeFill.fromPoints(rotatedPoints);\n      var shapeGeometry = new THREE.ShapeGeometry(shapeFill);\n      shapeGeometry.rotateX(Math.PI / 2);\n      material = new THREE.MeshLambertMaterial({\n        color: 0xff1169,\n        transparent: true,\n        opacity: _helpers2.default.mapRange(this.volume, 0, 2, 0.05, 0.35),\n        side: THREE.BackSide,\n        premultipliedAlpha: true });\n\n\n      this.shape = new THREE.Mesh(shapeGeometry, material);\n    } }, { key: 'addToScene', value: function addToScene()\n\n\n\n\n\n    {var _this3 = this;\n      if (!this.isInitialized) {\n        this.isInitialized = true;\n\n        var box = new THREE.Box3().setFromObject(this.shape);\n        box.getCenter(this.containerObject.position);\n        this.scene.add(this.containerObject);\n        this.objects.forEach(function (obj) {\n          obj.translateX(-_this3.containerObject.position.x);\n          obj.translateZ(-_this3.containerObject.position.z);\n          _this3.containerObject.add(obj);\n        });\n      } else\n      {\n        this.containerObject.add(this.shape);\n        this.containerObject.add(this.spline.mesh);\n      }\n    } }, { key: 'removeFromScene', value: function removeFromScene(\n\n    scene) {\n      this.scene.remove(this.containerObject, true);\n    }\n\n    // raycast to this soundzone\n  }, { key: 'isUnderMouse', value: function isUnderMouse(raycaster) {\n      if (this.isActive) {\n        return raycaster.intersectObjects(this.objects).length > 0;\n      }\n\n      return raycaster.intersectObject(this.shape).length > 0;\n    } }, { key: 'objectUnderMouse', value: function objectUnderMouse(\n\n    raycaster) {\n      var intersects = raycaster.intersectObjects(this.objects, true);\n\n      if (intersects.length > 0) {\n        if (intersects[0].object.type === 'Line' || intersects[0].object === this.shape) {\n          return intersects[Math.floor(intersects.length / 2)];\n        }\n\n        return intersects[0];\n      }\n\n      return null;\n    } }, { key: 'hideCursor', value: function hideCursor()\n\n    {\n      this.cursor.visible = false;\n    } }, { key: 'showCursor', value: function showCursor(\n    object, point) {\n      if (object !== this.shape) {\n        this.cursor.visible = true;\n        if (object === this.spline.mesh) {\n          var minv = new THREE.Matrix4().getInverse(this.containerObject.matrix);\n          this.cursor.position.copy(point.applyMatrix4(minv));\n        } else\n        {\n          this.cursor.position.copy(object.parent.position);\n        }\n      } else\n      {\n        this.hideCursor();\n      }\n    } }, { key: 'setMouseOffset', value: function setMouseOffset(\n\n    point) {\n      this.mouseOffsetX = point.x;\n      this.mouseOffsetY = point.z;\n    } }, { key: 'updateZone', value: function updateZone(\n\n    args) {\n      var scene = this.spline.mesh.parent;\n      this.containerObject.remove(this.spline.mesh, true);\n      this.containerObject.remove(this.shape, true);\n      this.renderPath(args);\n      this.addToScene(scene);\n    } }, { key: 'move', value: function move(\n\n    main) {\n      // if (!main.perspectiveView) {\n      var dx = main.mouse.x - this.mouseOffsetX;\n      var dy = main.mouse.z - this.mouseOffsetY;\n      this.mouseOffsetX = main.mouse.x;\n      this.mouseOffsetY = main.mouse.z;\n      this.hideCursor();\n\n      if (this.selectedPoint) {\n        // move selected point\n        var minv = new THREE.Matrix4().getInverse(this.containerObject.matrix);\n        this.selectedPoint.position.copy(main.mouse.applyMatrix4(minv));\n        this.updateZone();\n      } else {\n        // move entire shape\n\n        this.containerObject.position.x += dx;\n        this.containerObject.position.z += dy;\n      }\n      // }\n    } }, { key: 'setActive', value: function setActive(\n\n    main) {\n      this.setMouseOffset(main.mouse);\n      this.isActive = true;\n      this.pointObjects.forEach(function (obj) {return obj.visible = true;});\n      this.spline.mesh.visible = true;\n    } }, { key: 'setInactive', value: function setInactive()\n\n    {\n      this.hideCursor();\n      this.deselectPoint();\n      this.isActive = false;\n      this.pointObjects.forEach(function (obj) {return obj.visible = false;});\n      this.spline.mesh.visible = false;\n    } }, { key: 'select', value: function select(\n\n    intersect) {\n      if (!intersect) return;\n\n      // obj can be the curve, a spline point, or the shape mesh\n      var obj = intersect.object;\n\n      if (obj.type === 'Line') {\n        // add a point to the line\n        this.addPoint(intersect.point);\n      } else if (obj.parent.type === 'Object3D') {\n        // select an existing point on line\n        this.selectPoint(obj.parent);\n      } else {\n        this.deselectPoint();\n        this.setMouseOffset(intersect.point);\n      }\n    } }, { key: 'removePoint', value: function removePoint()\n\n    {\n      // find point in array\n      var i = this.pointObjects.indexOf(this.selectedPoint);\n      this.splinePoints.splice(i, 1);\n      this.deselectPoint();\n      this.updateZone({ index: i, updateType: \"delete\" });\n    } }, { key: 'addPoint', value: function addPoint(\n\n    point) {\n      var minv = new THREE.Matrix4().getInverse(this.containerObject.matrix);\n      var position = point.applyMatrix4(minv);\n\n      var closestSplinePoint = 0;\n      var prevDistToSplinePoint = -1;\n      var minDistance = Number.MAX_VALUE;\n      var minPoint = 1;\n\n      // search for point on spline\n      for (var t = 0; t < 1; t += 1 / 200.0) {\n        var pt = this.spline.getPoint(t);\n\n        var distToSplinePoint = this.splinePoints[closestSplinePoint].distanceToSquared(pt);\n        if (distToSplinePoint > prevDistToSplinePoint) {\n          closestSplinePoint += 1;\n\n          if (closestSplinePoint >= this.splinePoints.length) {\n            closestSplinePoint = 0;\n          }\n        }\n        prevDistToSplinePoint = this.splinePoints[closestSplinePoint].distanceToSquared(pt);\n        var distToPoint = pt.distanceToSquared(position);\n        if (distToPoint < minDistance) {\n          minDistance = distToPoint;\n          minPoint = closestSplinePoint;\n        }\n      }\n\n      this.splinePoints.splice(minPoint, 0, position);\n      this.updateZone({ index: minPoint, updateType: \"add\" });\n      this.selectPoint(this.pointObjects[minPoint]);\n    } }, { key: 'selectPoint', value: function selectPoint(\n\n    obj) {\n      this.deselectPoint();\n      this.selectedPoint = obj;\n      obj.children[0].material.color.set('blue');\n    } }, { key: 'deselectPoint', value: function deselectPoint()\n\n    {\n      if (this.selectedPoint) {\n        this.selectedPoint.children[0].material.color.set('red');\n        this.selectedPoint = null;\n      }\n    } }, { key: 'mute', value: function mute(\n\n    main) {\n      this.isMuted = true;\n      this.checkMuteState(main);\n    } }, { key: 'unmute', value: function unmute(\n    main) {\n      this.isMuted = false;\n      this.checkMuteState(main);\n    } }, { key: 'turnVisible', value: function turnVisible()\n\n    {\n\n    } }, { key: 'turnInvisible', value: function turnInvisible()\n\n    {\n      this.shape.material.visible = false;\n      this.pointObjects.forEach(function (point) {\n        point.children[0].visible = false;\n      });\n      this.spline.mesh.material.visible = false;\n    } }, { key: 'checkMuteState', value: function checkMuteState(\n\n    main) {\n      if (this.mainMixer) {\n        if (main.isMuted || this.isMuted) {\n          this.mainMixer.gain.value = 0;\n        } else\n        {\n          this.mainMixer.gain.value = 1;\n        }\n      }\n    } }, { key: 'toJSON', value: function toJSON()\n\n    {\n      var object = {\n        position: this.containerObject.position,\n        points: this.splinePoints,\n        filename: this.filename,\n        volume: this.volume };\n\n      return JSON.stringify(object);\n    } }, { key: 'fromJSON', value: function fromJSON(\n\n    json) {var _this4 = this;\n      var object = JSON.parse(json);\n      this.containerObject.position.copy(object.position);\n\n      if (object.filename) {\n        this.loadSound(object.filename, this.audio, false).\n        then(function () {\n          if (_this4.sound && _this4.sound.source) {\n            var volume = Math.max(Math.min(object.volume, 2), 0.0);\n            console.log(volume);\n            _this4.shape.material.opacity = _helpers2.default.mapRange(volume, 0, 2, 0.05, 0.35);\n            _this4.volume = volume;\n            _this4.sound.source.volume.gain.value = volume;\n          }\n        });\n      }\n    } }, { key: 'objects', get: function get() {return [].concat(this.pointObjects, this.spline.mesh, this.shape);} }]);return SoundZone;}();exports.default = SoundZone;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/components/soundzone.js\n// module id = 18\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/components/soundzone.js?");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n\nvar _material = __webpack_require__(20);var _material2 = _interopRequireDefault(_material);\n\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _toConsumableArray(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {arr2[i] = arr[i];}return arr2;} else {return Array.from(arr);}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// This helper class can be used to create and then place geometry in the scene\nvar Geometry = function () {\n  function Geometry(scene) {_classCallCheck(this, Geometry);\n    this.scene = scene;\n    this.geo = null;\n  }_createClass(Geometry, [{ key: 'make', value: function make(\n\n    type) {var _this = this;\n      if (type == 'plane') {\n        return function (width, height) {var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n          _this.geo = new THREE.PlaneGeometry(width, height, widthSegments, heightSegments);\n        };\n      }\n\n      if (type == 'sphere') {\n        return function (radius) {var widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;var heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n          _this.geo = new THREE.SphereGeometry(radius, widthSegments, heightSegments);\n        };\n      }\n    } }, { key: 'place', value: function place(\n\n    position, rotation) {var _mesh$position, _mesh$rotation;\n      var material = new _material2.default(0xffffff).standard;\n      var mesh = new THREE.Mesh(this.geo, material);\n\n      // Use ES6 spread to set position and rotation from passed in array\n      (_mesh$position = mesh.position).set.apply(_mesh$position, _toConsumableArray(position));\n      (_mesh$rotation = mesh.rotation).set.apply(_mesh$rotation, _toConsumableArray(rotation));\n\n      if (_config2.default.shadow.enabled) {\n        mesh.receiveShadow = true;\n      }\n\n      this.scene.add(mesh);\n    } }]);return Geometry;}();exports.default = Geometry;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/helpers/geometry.js\n// module id = 19\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/helpers/geometry.js?");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Use this class as a helper to set up some default materials\nvar Material =\nfunction Material(color) {_classCallCheck(this, Material);\n  this.basic = new THREE.MeshBasicMaterial({\n    color: color,\n    side: THREE.DoubleSide });\n\n\n  this.standard = new THREE.MeshStandardMaterial({\n    color: color,\n    side: THREE.DoubleSide,\n    visible: false });\n\n\n  this.wire = new THREE.MeshBasicMaterial({ wireframe: false });\n};exports.default = Material;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/helpers/material.js\n// module id = 20\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/helpers/material.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\n\nvar _material = __webpack_require__(20);var _material2 = _interopRequireDefault(_material);\nvar _meshHelper = __webpack_require__(22);var _meshHelper2 = _interopRequireDefault(_meshHelper);\nvar _helpers = __webpack_require__(8);var _helpers2 = _interopRequireDefault(_helpers);\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Loads in a single object from the config file\nvar Model = function () {\n  function Model(scene, loader) {_classCallCheck(this, Model);\n    this.scene = scene;\n\n    // Manager is passed in to loader to determine when loading done in main\n    this.loader = loader;\n    this.obj = null;\n  }_createClass(Model, [{ key: 'load', value: function load()\n\n    {var _this = this;\n      // Load model with ObjectLoader\n      this.loader.load(_config2.default.model.path, function (obj) {\n        obj.traverse(function (child) {\n          if (child instanceof THREE.Mesh) {\n            // Create material for mesh and set its map to texture by name from preloaded textures\n            var material = new _material2.default(0x44aaff).basic;\n            child.material = material;\n            material.transparent = true;\n            material.opacity = 0.8;\n\n            // Set to cast and receive shadow if enabled\n            if (_config2.default.shadow.enabled) {\n              child.receiveShadow = true;\n              child.castShadow = true;\n            }\n          }\n        });\n\n        // Set prop to obj\n        _this.obj = obj;\n\n        obj.name = 'dummyHead';\n\n        obj.position.y = 1; // necessary for raycasting onto the zone shape\n        obj.rotation.y += Math.PI;\n        obj.scale.multiplyScalar(_config2.default.model.scale);\n\n        _this.scene.add(obj);\n      });\n    } }]);return Model;}();exports.default = Model;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/model/model.js\n// module id = 21\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/model/model.js?");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Simple mesh helper that shows edges, wireframes, and face and vertex normals\nvar MeshHelper =\nfunction MeshHelper(scene, mesh) {_classCallCheck(this, MeshHelper);\n  var wireframe = new THREE.WireframeGeometry(mesh.geometry);\n  var wireLine = new THREE.LineSegments(wireframe);\n  wireLine.material.depthTest = false;\n  wireLine.material.opacity = 0.25;\n  wireLine.material.transparent = true;\n  mesh.add(wireLine);\n\n  var edges = new THREE.EdgesGeometry(mesh.geometry);\n  var edgesLine = new THREE.LineSegments(edges);\n  edgesLine.material.depthTest = false;\n  edgesLine.material.opacity = 0.25;\n  edgesLine.material.transparent = true;\n  mesh.add(edgesLine);\n\n  scene.add(new THREE.BoxHelper(mesh));\n  scene.add(new THREE.FaceNormalsHelper(mesh, 2));\n  scene.add(new THREE.VertexNormalsHelper(mesh, 2));\n};exports.default = MeshHelper;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/helpers/meshHelper.js\n// module id = 22\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/helpers/meshHelper.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _three = __webpack_require__(6);var THREE = _interopRequireWildcard(_three);\nvar _keyboard = __webpack_require__(24);var _keyboard2 = _interopRequireDefault(_keyboard);\nvar _config = __webpack_require__(2);var _config2 = _interopRequireDefault(_config);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _interopRequireWildcard(obj) {if (obj && obj.__esModule) {return obj;} else {var newObj = {};if (obj != null) {for (var key in obj) {if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];}}newObj.default = obj;return newObj;}}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}\n\n// Manages all input interactions\nvar Interaction = function () {\n  function Interaction(main, renderer, scene, camera, controls) {var _this = this;_classCallCheck(this, Interaction);\n    // Properties\n    this.renderer = renderer;\n    this.scene = scene;\n    this.camera = camera;\n    this.controls = controls;\n\n    this.timeout = null;\n\n    // Instantiate keyboard helper\n    this.keyboard = new _keyboard2.default();\n\n    // Listeners\n    // Mouse events\n    this.renderer.domElement.addEventListener('mousemove', function (event) {return _this.onMouseMove(main, event);}, false);\n    this.renderer.domElement.addEventListener('mouseleave', function (event) {return _this.onMouseUp(main, event, false);}, false);\n    this.renderer.domElement.addEventListener('mouseover', function (event) {return _this.onMouseOver(event);}, false);\n    this.renderer.domElement.addEventListener('mouseup', function (event) {return _this.onMouseUp(main, event, true);}, false);\n    this.renderer.domElement.addEventListener('mousedown', function (event) {return _this.onMouseDown(main, event);}, false);\n\n    // Keyboard events\n    this.keyboard.domElement.addEventListener('keydown', function (event) {\n      // Only once\n      if (event.repeat) {\n        return;\n      }\n\n      if (_this.keyboard.eventMatches(event, 'w')) {\n        document.getElementById('help-head').style.display = 'none';\n        main.moveForward = 1 * main.movementSpeed;\n      }\n\n      if (_this.keyboard.eventMatches(event, 'a')) {\n        main.yawRight = 1 * main.rotationSpeed;\n      }\n\n      if (_this.keyboard.eventMatches(event, 'd')) {\n        main.yawLeft = 1 * main.rotationSpeed;\n      }\n\n      if (_this.keyboard.eventMatches(event, 's')) {\n        main.moveBackwards = 1 * main.movementSpeed;\n      }\n\n      // if (this.keyboard.eventMatches(event, 'e')) {\n      //   this.data = main.export();\n      //\n      //   const a = document.createElement('a');\n      //   const blob = new Blob([this.data], {'type':'text/plain'});\n      //   a.href = window.URL.createObjectURL(blob);\n      //   a.download = 'export.json';\n      //   a.click();\n      // }\n\n      // if (this.keyboard.eventMatches(event, 'i')) {\n      //   const i = document.getElementById('import');\n      //   i.click();\n      //   i.addEventListener('change', handleFiles, false);\n      //\n      //   function handleFiles() {\n      //     const reader = new FileReader();\n      //     reader.addEventListener('load', (e) => {\n      //       main.import(e.target.result);\n      //     });\n      //     reader.readAsText(this.files[0]);\n      //   }\n      // }\n\n      if (_this.keyboard.eventMatches(event, 'backspace') ||\n      _this.keyboard.eventMatches(event, 'delete')) {\n\n        if (main.activeObject && main.activeObject.type === 'SoundTrajectory') {\n          if (main.activeObject.selectedPoint && main.activeObject.splinePoints.length > 2) {\n            main.activeObject.removePoint();\n          }\n        }\n\n        if (main.activeObject && main.activeObject.type === 'SoundZone') {\n          if (main.activeObject.selectedPoint && main.activeObject.splinePoints.length > 3) {\n            main.activeObject.removePoint();\n          } else {\n            main.removeSoundZone(main.activeObject);\n            main.activeObject = null;\n          }\n        }\n\n        if (main.activeObject && main.activeObject.type === 'SoundObject') {\n          if (main.isEditingObject) {\n            if (main.interactiveCone) {\n              main.removeCone(main.activeObject, main.interactiveCone);\n            }\n          } else {\n            main.removeSoundObject(main.activeObject);\n\n            if (main.activeObject.trajectory)\n            main.removeSoundTrajectory(main.activeObject.trajectory);\n\n            main.activeObject = null;\n          }\n        }\n      }\n\n      if (_config2.default.isDev) {\n        if (_this.keyboard.eventMatches(event, 'h')) {\n          var base = document.getElementsByClassName('rs-base')[0];\n\n          if (base.style.display === 'none') base.style.display = 'block';else\n          base.style.display = 'none';\n        }\n      }\n    });\n\n    this.keyboard.domElement.addEventListener('keyup', function (event) {\n      // Only once\n      if (event.repeat) {\n        return;\n      }\n\n      if (_this.keyboard.eventMatches(event, 'w')) {\n        main.moveForward = 0;\n      }\n\n      if (_this.keyboard.eventMatches(event, 'a')) {\n        main.yawRight = 0;\n      }\n\n      if (_this.keyboard.eventMatches(event, 'd')) {\n        main.yawLeft = 0;\n      }\n\n      if (_this.keyboard.eventMatches(event, 's')) {\n        main.moveBackwards = 0;\n      }\n\n      // if (this.keyboard.eventMatches(event, 'r')) {\n      //   main.reset(true);\n      // }\n\n      if (_this.keyboard.eventMatches(event, 'u')) {\n        main.isUserStudyLoading = !main.isUserStudyLoading;\n      }\n    });\n  }_createClass(Interaction, [{ key: 'onMouseOver', value: function onMouseOver(\n\n    event) {\n      event.preventDefault();\n\n      _config2.default.isMouseOver = true;\n    } }, { key: 'onMouseLeave', value: function onMouseLeave(\n\n    event) {\n      event.preventDefault();\n\n      _config2.default.isMouseOver = false;\n    } }, { key: 'onMouseMove', value: function onMouseMove(\n\n    main, event) {\n      event.preventDefault();\n\n      clearTimeout(this.timeout);\n      this.timeout = setTimeout(function () {_config2.default.isMouseMoving = false;}, 200);\n\n      _config2.default.isMouseMoving = true;\n\n      main.setMousePosition(event);\n      if (main.isMouseDown === true && !main.isEditingObject) {\n        if (main.isAddingTrajectory === true) {\n          if (main.activeObject.type === 'SoundObject') {\n            main.mouse.y = main.activeObject.containerObject.position.y;\n            main.path.addPoint(main.mouse);\n          }\n        }\n\n        if (main.isAddingObject === true) {\n          main.path.addPoint(main.mouse);\n        }\n\n        if (main.activeObject) {\n          if (main.activeObject.type === 'SoundTrajectory') {\n            main.activeObject.move(main.mouse, main.nonScaledMouse, main.perspectiveView);\n          } else\n          {\n            main.activeObject.move(main);\n          }\n        }\n      } //end if(main.isMouseDown...)\n\n      // show cursor on hover\n      else if (!main.isEditingObject && main.activeObject) {\n          // make sure object to raycast to is the trajectory\n          var obj = main.activeObject;\n          if (obj.type === 'SoundObject') {\n            if (obj.trajectory) {\n              obj = obj.trajectory;\n            } else\n            {\n              return;\n            }\n          }\n\n          switch (obj.type) {\n            case 'SoundTrajectory':\n            case 'SoundZone':\n              var intersection = obj.objectUnderMouse(main.ray);\n              if (intersection) {\n                obj.showCursor(intersection.object, intersection.point);\n              } else\n              {\n                obj.hideCursor();\n              }\n              break;\n            default:\n              break;}\n\n\n        }\n\n      if (main.isEditingObject) {(function () {\n          var intersect3 = void 0;\n\n          if (main.isMouseDown) {\n            // point cone towards mouse pointer\n            intersect3 = main.ray.intersectObject(main.activeObject.raycastSphere)[0];\n\n            if (main.interactiveCone != null && intersect3) {\n              main.activeObject.pointCone(main.interactiveCone, intersect3.point);\n            } else\n            {\n              // console.log('no cone is a snow cone')\n            }\n          } else\n          {\n            intersect3 = main.ray.intersectObjects(main.activeObject.cones)[0];\n\n            // temp set color on hover\n            main.activeObject.cones.forEach(function (cone) {\n              if (intersect3 && intersect3.object.uuid === cone.uuid) {\n                cone.isHighlighted = true;\n                cone.material.color.set(cone.hoverColor());\n              } else\n              if (cone.isHighlighted) {\n                cone.isHighlighted = false;\n                cone.material.color.set(cone.baseColor);\n              }\n            });\n          }})();\n      } //end if(main.isEditingObject)\n    } }, { key: 'onMouseUp', value: function onMouseUp(\n\n    main, event, hasFocus) {\n      // turn gui pointer events back on\n      main.gui.enable();\n      document.getElementById('GlobalContainer').style.pointerEvents = 'auto';\n\n      // turn controls back on\n      main.controls.enable();\n\n      // mouse leaves the container\n      if (!hasFocus) {_config2.default.isMouseOver = false;}\n      if (main.isMouseDown === false) {return;}\n\n      // actual mouseup interaction\n      main.setMousePosition(event);\n      var obj = void 0;\n\n      if (main.isAddingTrajectory) {\n        obj = main.path.createObject(main);\n\n        main.toggleAddTrajectory(false);\n      }\n\n      if (main.isAddingObject) {\n        obj = main.path.createObject(main);\n\n        main.setActiveObject(obj);\n        main.toggleAddObject();\n        main.isAddingObject = false;\n      }\n\n      if (main.isEditingObject) {\n        if (main.interactiveCone) {\n          main.interactiveCone.material.color.set(main.interactiveCone.baseColor);\n        }\n      }\n\n      main.isMouseDown = false;\n\n      for (var i in main.soundObjects) {\n        if (main.soundObjects[i].type === 'SoundObject') main.soundObjects[i].calculateMovementSpeed();\n      }\n    } }, { key: 'onMouseDown', value: function onMouseDown(\n\n    main, event) {\n      // turn gui events off when interacting with scene objects\n      main.gui.disable();\n      document.getElementById('GlobalContainer').style.pointerEvents = 'none';\n\n      /**\n                                                                                * !keyPressed is added to avoid interaction with object when the camera\n                                                                                * is being rotated. It can (should) be changed into a flag more specific\n                                                                                * to this action.\n                                                                                */\n      if (!main.keyPressed) {\n        main.isMouseDown = true;\n\n        /**\n                                  * Create a collection array of all the object in the scene and check if\n                                  * any of these objects isUnderMouse (a function which is passed our raycaster).\n                                  *\n                                  * If there is indeed an intersected object, set it as the activeObject.\n                                  */\n        var everyComponent = [].concat(main.soundObjects, main.soundTrajectories, main.soundZones);\n        var intersectObjects = everyComponent.filter(function (obj) {\n          return obj.isUnderMouse(main.ray);\n        });\n\n        // if adding trajectory, check that mousedown is valid\n        main.isAddingTrajectory = main.isAddingTrajectory && intersectObjects[0] === main.activeObject;\n\n        // set activeObject to intersected object\n        if (!main.isEditingObject) {\n          if (intersectObjects.length > 0 && !main.isAddingObject) {\n            // if soundzones overlap, keep last selected\n            if (!(main.activeObject && main.activeObject.type === 'SoundZone' && intersectObjects[0].type === 'SoundZone' && intersectObjects.indexOf(main.activeObject) > -1)) {\n              main.setActiveObject(intersectObjects[0]);\n            }\n          } else\n          {\n            main.setActiveObject(null);\n          }\n        }\n\n        // disable controls when add or moving an object\n        if (main.isAddingTrajectory || main.isAddingObject || main.activeObject && !main.isEditingObject) {\n          main.controls.disable();\n        }\n\n        /**\n           * If adding a trajectory, ask the trajectory interface to initate a new\n           * trajectory at the mouse position determined in setMousePosition()\n           *\n           * Same for the zone.\n           */\n        if (main.isAddingTrajectory) {\n          main.mouse.y = main.activeObject.containerObject.position.y;\n          main.path.beginAt(main.mouse, main.activeObject);\n        }\n\n        if (main.isAddingObject) {\n          main.path.beginAt(main.mouse);\n        }\n\n        /* If the most recent active object interacted with again, select it: */\n        if (main.activeObject && main.activeObject.isUnderMouse(main.ray)) {\n          // click inside active object\n          if (main.activeObject.type != 'SoundObject') {\n            var intersect = main.activeObject.objectUnderMouse(main.ray);\n            main.activeObject.select(intersect, main);\n          } else {\n            main.activeObject.select(main);\n          }\n        }\n\n        /**\n           * In object edit mode a different interaction scheme is followed.\n           */\n        if (main.isEditingObject) {\n          if (!main.activeObject || !main.activeObject.cones) {\n            console.log('wheres my cone :(', main.activeObject); //error check\n          }\n\n          var intersect2 = main.ray.intersectObjects(main.activeObject.cones)[0];\n          if (intersect2) {\n            main.interactiveCone = intersect2.object;\n            main.controls.disable();\n          } else\n          {\n            main.interactiveCone = null;\n          }\n        }\n      }\n    } }]);return Interaction;}();exports.default = Interaction;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/managers/interaction.js\n// module id = 23\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/managers/interaction.js?");

/***/ },
/* 24 */
/***/ function(module, exports) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}var ALIAS = {\n  'left': 37,\n  'up': 38,\n  'right': 39,\n  'down': 40,\n  'space': 32,\n  'tab': 9,\n  'backspace': 8,\n  'delete': 46,\n  'escape': 27 };var\n\n\nKeyboard = function () {\n  function Keyboard(domElement) {var _this = this;_classCallCheck(this, Keyboard);\n    this.domElement = domElement || document;\n    this.keyCodes = {};\n\n    // bind keyEvents\n    this.domElement.addEventListener('keydown', function (event) {return _this.onKeyChange(event);}, false);\n    this.domElement.addEventListener('keyup', function (event) {return _this.onKeyChange(event);}, false);\n\n    // bind window blur\n    window.addEventListener('blur', function () {return _this.onBlur;}, false);\n  }_createClass(Keyboard, [{ key: 'destroy', value: function destroy()\n\n    {var _this2 = this;\n      this.domElement.removeEventListener('keydown', function (event) {return _this2.onKeyChange(event);}, false);\n      this.domElement.removeEventListener('keyup', function (event) {return _this2.onKeyChange(event);}, false);\n\n      // unbind window blur event\n      window.removeEventListener('blur', function () {return _this2.onBlur;}, false);\n    } }, { key: 'onBlur', value: function onBlur()\n\n    {\n      for (var prop in this.keyCodes) {\n        this.keyCodes[prop] = false;}\n    } }, { key: 'onKeyChange', value: function onKeyChange(\n\n    event) {\n      // log to debug\n      //console.log('onKeyChange', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n\n      // update this.keyCodes\n      var keyCode = event.keyCode;\n      this.keyCodes[keyCode] = event.type === 'keydown';\n    } }, { key: 'pressed', value: function pressed(\n\n    keyDesc) {\n      var keys = keyDesc.split('+');\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var pressed = false;\n        if (Object.keys(ALIAS).indexOf(key) != -1) {\n          pressed = this.keyCodes[ALIAS[key]];\n        } else {\n          pressed = this.keyCodes[key.toUpperCase().charCodeAt(0)];\n        }\n        if (!pressed)\n        return false;\n      }\n\n      return true;\n    } }, { key: 'eventMatches', value: function eventMatches(\n\n    event, keyDesc) {\n      var aliases = ALIAS;\n      var aliasKeys = Object.keys(aliases);\n      var keys = keyDesc.split('+');\n      // log to debug\n      // console.log('eventMatches', event, event.keyCode, event.shiftKey, event.ctrlKey, event.altKey, event.metaKey)\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var pressed = false;\n        if (key === 'shift') {\n          pressed = event.shiftKey ? true : false;\n        } else if (key === 'ctrl') {\n          pressed = event.ctrlKey ? true : false;\n        } else if (key === 'alt') {\n          pressed = event.altKey ? true : false;\n        } else if (key === 'meta') {\n          pressed = event.metaKey ? true : false;\n        } else if (aliasKeys.indexOf(key) !== -1) {\n          pressed = event.keyCode === aliases[key];\n        } else if (event.keyCode === key.toUpperCase().charCodeAt(0)) {\n          pressed = true;\n        }\n        if (!pressed)\n        return false;\n      }\n\n      return true;\n    } }]);return Keyboard;}();exports.default = Keyboard;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/utils/keyboard.js\n// module id = 24\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/utils/keyboard.js?");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';Object.defineProperty(exports, \"__esModule\", { value: true });var _createClass = function () {function defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}return function (Constructor, protoProps, staticProps) {if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;};}();var _helpers = __webpack_require__(8);var _helpers2 = _interopRequireDefault(_helpers);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError(\"Cannot call a class as a function\");}}var\n\nGUIWindow = function () {\n  function GUIWindow(main) {_classCallCheck(this, GUIWindow);\n    this.id = null; // uuid of displayed \"shape\" or \"containerObject\"\n    this.obj = null; // the object whose information is being displayed\n\n    this.listeners = [];\n\n    this.app = main;\n    this.container = document.getElementById('guis');\n    this.isDisabled = false;\n    this.display();\n\n    // add listeners for dragging parameters\n    document.addEventListener('mousemove', this.drag.bind(this));\n    document.addEventListener('mouseup', this.stopDragging.bind(this));\n    this.dragEvent = {};\n  }\n\n  // ------- showing/hiding the overall gui ---------- //\n  _createClass(GUIWindow, [{ key: 'display', value: function display(\n    obj) {\n      if (obj) {\n        this.show(obj);\n      } else\n      {\n        this.hide();\n        this.id = this.obj = null;\n      }\n    }\n\n    // disable/enable pointer events\n  }, { key: 'disable', value: function disable() {\n      this.isDisabled = true;\n    } }, { key: 'enable', value: function enable()\n    {\n      this.isDisabled = false;\n    }\n\n    // clear gui and listeners\n  }, { key: 'clear', value: function clear() {\n      this.container.innerHTML = '';\n      this.listeners = [];\n    }\n\n    // show gui\n  }, { key: 'show', value: function show(obj) {\n      if (!obj) {return;}\n\n      // get details of object\n      switch (obj.type) {\n        case 'SoundTrajectory':\n          obj = obj.parentSoundObject;\n        // no break => get details of sound object\n        case 'SoundObject':\n          if (this.id !== obj.containerObject.uuid) {\n            // init a new gui\n            this.clear();\n            this.id = obj.containerObject.uuid;\n            this.obj = obj;\n            this.initObjectGUI(obj);\n          } else\n          {\n            // read and update object parameters\n            this.updateObjectGUI(obj);\n          }\n          break;\n        case 'SoundZone':\n          if (this.id !== obj.shape.uuid) {\n            // init a new gui\n            this.clear();\n            this.id = obj.shape.uuid;\n            this.obj = obj;\n            this.initSoundzoneGUI(obj);\n          } else\n          {\n            // read and update object parameters\n            this.updateSoundzoneGUI(obj);\n          }\n          break;\n        default:\n          console.log('cannot show ui for type', obj.type);\n          break;}\n\n      this.container.style.opacity = 1;\n      this.container.style.pointerEvents = this.isDisabled ? 'none' : 'auto';\n    }\n\n    // hide gui\n  }, { key: 'hide', value: function hide() {\n      this.container.style.opacity = 0;\n      this.container.style.pointerEvents = 'none';\n    }\n\n\n    //----------- initiating objects --------- //\n\n    // add navigation arrows\n  }, { key: 'addNav', value: function addNav(e, elem) {\n      var arrow = document.createElement('div');\n      arrow.className = 'nav nav-' + e.direction + ' nav-' + e.type;\n\n      var glyph = e.direction === 'left' ? '‹' : '›';\n\n      arrow.appendChild(document.createTextNode(glyph));\n      elem.appendChild(arrow);\n      arrow.onclick = this.nav.bind(this, e);\n    }\n\n    // set up initial parameters for a sound object\n  }, { key: 'initObjectGUI', value: function initObjectGUI(object) {var _this = this;\n      var mesh = object.containerObject;\n      var elem = this.addElem('Object ' + (this.app.soundObjects.indexOf(object) + 1), true);\n\n      function setObjectPosition(component, dx) {\n        var destination = mesh.position.clone();\n        destination[component] += dx;\n\n        // clamp y to [-300,300]\n        destination.y = Math.min(Math.max(-300, destination.y), 300);\n\n        // move all child objects of the object\n        object.setPosition(destination);\n\n        if (object.trajectory) {\n          // move trajectory\n          if (component === 'y') {\n            object.trajectory.splinePoints.forEach(function (pt) {\n              pt[component] = Math.min(Math.max(-300, pt[component] + dx), 300);\n            });\n            object.trajectory.updateTrajectory();\n          } else\n          {\n            object.trajectory.objects.forEach(function (obj) {\n              obj.position[component] += dx;\n            });\n            object.trajectory.splinePoints.forEach(function (pt) {\n              pt[component] += dx;\n            });\n          }\n        }\n      } //end setObjectPosition\n\n      function changeVolume(dx) {\n        if (object.omniSphere.sound && object.omniSphere.sound.volume) {\n          // clamp value to (0.05, 2)\n          var volume = Math.max(Math.min(object.omniSphere.sound.volume.gain.value + dx / 50, 2), 0.05);\n          object.omniSphere.sound.volume.gain.value = volume;\n          object.changeRadius();\n        }\n      }\n\n      this.addParameter({\n        property: 'File',\n        value: object.omniSphere.sound ? object.omniSphere.sound.name.split('/').pop() : 'None',\n        type: 'file-input',\n        display: object.omniSphere.sound,\n        events: [{ type: 'click', callback: this.addSound.bind(this) }] },\n      elem).id = \"omnisphere-sound-loader\";\n\n      this.addParameter({\n        property: 'Volume',\n        value: object.omniSphere.sound && object.omniSphere.sound.volume ? object.omniSphere.sound.volume.gain.value : 'N/A',\n        type: 'number',\n        cls: 'volume',\n        bind: changeVolume },\n      elem);\n\n      /* global object parameters */\n      var gElem = document.createElement('div');\n      gElem.id = \"object-globals\";\n      elem.appendChild(gElem);\n      gElem.style.display = this.app.isEditingObject ? 'none' : 'block';\n\n      this.addParameter({\n        property: 'Position X',\n        value: Number(mesh.position.x.toFixed(2)),\n        type: 'number',\n        cls: 'x',\n        bind: setObjectPosition.bind(this, \"x\") },\n      gElem);\n\n      this.addParameter({\n        property: 'Position Y',\n        value: Number(mesh.position.z.toFixed(2)),\n        type: 'number',\n        cls: 'z',\n        bind: setObjectPosition.bind(this, \"z\") },\n      gElem);\n\n      this.addParameter({\n        property: 'Altitude',\n        value: Number(mesh.position.y.toFixed(2)),\n        type: 'number',\n        cls: 'y',\n        bind: setObjectPosition.bind(this, \"y\") },\n      gElem);\n\n      var coneCount = this.addParameter({\n        property: '# of cones',\n        value: object.cones.length },\n      gElem);\n      coneCount.id = 'cone-count';\n\n      // insert cone window\n      object.cones.forEach(function (cone) {\n        _this.addCone(cone).style.display = 'none';\n      });\n\n      // \"add cone\" dialog\n      var addConeElem = this.addParameter({\n        value: 'Add cone',\n        events: [{\n          type: 'click',\n          callback: this.addSound.bind(this) }] });\n\n\n      addConeElem.id = 'add-cone';\n\n      if (object.trajectory) {\n        this.addTrajectory(object);\n      } else\n      {\n        this.addTrajectoryDialog();\n      }\n\n      this.addNav({ type: \"object\", direction: \"left\" }, elem);\n      this.addNav({ type: \"object\", direction: \"right\" }, elem);\n    }\n\n    // \"add trajectory\" dialog\n  }, { key: 'addTrajectoryDialog', value: function addTrajectoryDialog() {\n      var addTrajectoryElem = this.addParameter({\n        value: 'Add trajectory',\n        events: [{\n          type: 'click',\n          callback: this.app.toggleAddTrajectory.bind(this.app, true) }] });\n\n\n      addTrajectoryElem.id = 'add-trajectory';\n    }\n\n    // set up initial parameters for a sound object cone\n  }, { key: 'addCone', value: function addCone(cone) {\n      var elem = this.addElem('', false, document.getElementById('add-cone'));\n      elem.id = 'cone-' + cone.id;\n      elem.className = 'cone';\n\n      // set bg color\n      var color = cone.hoverColor().getHSL();\n      color.h *= 360;\n      color.s *= 100;\n      color.l = Math.max(color.l * 100, 70);\n      elem.style.backgroundColor = 'hsl(' + color.h + ',' + color.s + '%,' + color.l + '%)';\n\n      var object = this.obj;\n\n      function changeVolume(dx) {\n        if (cone.sound && cone.sound.volume) {\n\n          // clamp value to (0.05, 2)\n          var volume = Math.max(Math.min(cone.sound.volume.gain.value + dx / 50, 2), 0.05);\n\n          if (volume !== cone.sound.volume.gain.value) {\n            // modify cone length\n            cone.sound.volume.gain.value = volume;\n            object.changeLength(cone);\n          }\n        }\n      }\n\n      function changeSpread(dx) {\n        if (cone.sound && cone.sound.spread) {\n          // clamp value to (0.05,1)\n          var spread = Math.max(Math.min(cone.sound.spread + dx / 100, 1), 0.05);\n\n          if (spread !== cone.sound.spread) {\n            // modify cone width\n            cone.sound.spread = spread;\n            object.changeWidth(cone);\n          }\n\n        }\n      }\n\n      function setConeRotation(component, dx) {\n        // clamp lat/long values\n        var lat = cone.lat || 0.0001;\n        var long = cone.long || 0.0001;\n\n        if (component === \"lat\") {\n          if (long > 0) {\n            lat -= dx * Math.PI / 180;\n          } else\n          {\n            lat += dx * Math.PI / 180;\n          }\n          if (lat > Math.PI) {\n            lat = Math.PI - lat;\n            long = -long;\n          } else\n          if (lat < -Math.PI) {\n            lat = Math.PI - lat;\n            long = -long;\n          }\n        } else\n        {\n          long += dx * Math.PI / 180;\n          if (long > Math.PI * 2) {\n            long -= Math.PI * 2;\n          } else\n          if (long < -Math.PI * 2) {\n            long += Math.PI * 2;\n          }\n        }\n\n        object.pointConeMagic(cone, lat, long);\n      }\n\n      this.addParameter({\n        property: 'File',\n        value: cone.filename,\n        events: [{\n          type: 'click',\n          callback: this.addSound.bind(this) }] },\n\n      elem);\n      this.addParameter({\n        property: 'Volume',\n        value: Number(cone.sound.volume.gain.value.toFixed(3)),\n        type: 'number',\n        cls: 'volume',\n        suffix: ' dB',\n        bind: changeVolume },\n      elem);\n      this.addParameter({\n        property: 'Spread',\n        value: Number(cone.sound.spread.toFixed(3)),\n        type: 'number',\n        cls: 'spread',\n        bind: changeSpread },\n      elem);\n      this.addParameter({\n        property: 'Longitude',\n        value: Math.round(cone.long * 180 / Math.PI),\n        type: 'number',\n        cls: 'long',\n        suffix: '˚',\n        bind: setConeRotation.bind(this, \"long\") },\n      elem);\n      this.addParameter({\n        property: 'Latitude',\n        value: Math.round(cone.lat * 180 / Math.PI),\n        type: 'number',\n        cls: 'lat',\n        suffix: '˚',\n        bind: setConeRotation.bind(this, \"lat\") },\n      elem);\n      this.addParameter({\n        value: 'Remove Cone',\n        events: [{\n          type: 'click',\n          callback: function () {\n            this.app.removeCone(this.obj, cone);\n          }.bind(this) }] },\n\n      elem);\n\n      /* Cone navigation */\n      this.addNav({ type: \"cone\", direction: \"left\" }, elem);\n      this.addNav({ type: \"cone\", direction: \"right\" }, elem);\n\n      return elem;\n    }\n\n    // remove cone parameter window\n  }, { key: 'removeCone', value: function removeCone(cone) {\n      var cones = this.container.getElementsByClassName('cone');\n      for (var i = 0; i < cones.length; ++i) {\n        if (cones[i].id.split('-').pop() == cone.id) {\n          cones[i].parentNode.removeChild(cones[i]);\n          return;\n        }\n      }\n    }\n\n    // set up initial parameters for a sound object trajectory path\n  }, { key: 'addTrajectory', value: function addTrajectory(object) {\n      var elem = this.addElem('Trajectory');\n      elem.id = 'trajectory';\n\n      this.addParameter({\n        property: 'Speed',\n        value: object.movementSpeed,\n        suffix: ' m/s',\n        type: 'number',\n        cls: 'speed',\n        bind: function bind(dx) {\n          var speed = object.movementSpeed + dx / 10;\n          object.movementSpeed = Math.min(Math.max(-40, speed), 40);\n          object.calculateMovementSpeed();\n        } },\n      elem);\n\n      this.addParameter({\n        value: 'Delete',\n        events: [{\n          type: 'click',\n          callback: function () {\n            this.app.removeSoundTrajectory(object.trajectory);\n            object.trajectory = null;\n            elem.parentNode.removeChild(elem);\n            this.addTrajectoryDialog();\n          }.bind(this) }] },\n\n      elem);\n\n      return elem;\n    } }, { key: 'disableGlobalParameters', value: function disableGlobalParameters()\n\n    {\n      var global = document.getElementById('object-globals');\n      if (global) {\n        global.style.display = 'none';\n      }\n    } }, { key: 'enableGlobalParameters', value: function enableGlobalParameters()\n    {\n      var global = document.getElementById('object-globals');\n      if (global) {\n        global.style.display = 'block';\n      }\n    }\n\n    // set up initial parameters for a soundzone\n  }, { key: 'initSoundzoneGUI', value: function initSoundzoneGUI(zone) {\n      var elem = this.addElem('Zone ' + (this.app.soundZones.indexOf(zone) + 1));\n\n      function setZonePosition(component, dx) {\n        zone.containerObject.position[component] += dx;\n      }\n\n      function setZoneRotation(dx) {\n        var rotation = zone.containerObject.rotation.y + dx * Math.PI / 180;\n\n        if (rotation < Math.PI) {rotation += Math.PI * 2;}\n        if (rotation > Math.PI) {rotation -= Math.PI * 2;}\n        zone.containerObject.rotation.y = rotation;\n      }\n\n      function changeVolume(dx) {\n        if (zone.sound) {\n\n          var volume = Math.max(Math.min(zone.sound.source.volume.gain.value + dx / 50, 2), 0.0);\n          zone.shape.material.opacity = _helpers2.default.mapRange(volume, 0, 2, 0.05, 0.35);\n          zone.volume = volume;\n          zone.sound.source.volume.gain.value = volume;\n        }\n      }\n\n      var pos = zone.containerObject.position;\n      this.addParameter({\n        property: 'File',\n        value: zone.sound ? zone.sound.name.split('/').pop() : 'None',\n        type: 'file-input',\n        display: zone.sound,\n        events: [{ type: 'click', callback: this.addSound.bind(this) }] },\n      elem);\n\n      this.addParameter({\n        property: 'Volume',\n        value: zone.sound ? zone.sound.source.volume.gain.value : 'N/A',\n        type: 'number',\n        cls: 'volume',\n        bind: changeVolume },\n      elem);\n\n      this.addParameter({\n        property: 'Position X',\n        value: Number(pos.x.toFixed(2)),\n        type: 'number',\n        cls: 'x',\n        bind: setZonePosition.bind(this, \"x\") },\n      elem);\n\n      this.addParameter({\n        property: 'Position Y',\n        value: Number(pos.z.toFixed(2)),\n        type: 'number',\n        cls: 'z',\n        bind: setZonePosition.bind(this, \"z\") },\n      elem);\n\n      this.addParameter({\n        property: 'Rotation',\n        value: Number((zone.containerObject.rotation.y * 180 / Math.PI).toFixed(2)),\n        type: 'number',\n        cls: 'rotation',\n        suffix: '˚',\n        bind: setZoneRotation.bind(this) },\n      elem);\n    }\n\n\n    //----- updating objects -------//\n\n    // update parameters of sound object\n  }, { key: 'updateObjectGUI', value: function updateObjectGUI(object) {var _this2 = this;\n\n      // update sound volume\n      var volume = this.container.querySelector('.volume .value');\n      this.replaceTextContent(volume, object.omniSphere.sound && object.omniSphere.sound.volume ? object.omniSphere.sound.volume.gain.value : 'N/A');\n\n      // update position parameters\n      var pos = object.containerObject.position;\n      var x = this.container.querySelector('.x .value');\n      var y = this.container.querySelector('.y .value');\n      var z = this.container.querySelector('.z .value');\n\n      this.replaceTextContent(x, pos.x);\n      this.replaceTextContent(y, pos.y);\n      this.replaceTextContent(z, pos.z);\n\n      // check if trajectory exists\n      if (object.trajectory) {\n\n        // check if option to add trajectory still exists\n        var addTrajectory = document.getElementById('add-trajectory');\n        if (addTrajectory) {\n          this.container.removeChild(addTrajectory);\n          this.addTrajectory(object);\n        } else\n        {\n          // update trajectory parameters\n          var speed = this.container.querySelector('.speed .value');\n          if (speed) {\n            this.replaceTextContent(speed, object.movementSpeed);\n          }\n        }\n      }\n\n      // update number of cones\n      this.replaceTextContent(document.getElementById('cone-count').querySelector('.value'), object.cones.length);\n\n      // get cone information\n      if (object.cones && object.cones.length > 0) {(function () {\n\n          var cones = _this2.container.getElementsByClassName('cone');\n\n          _this2.app.interactiveCone == _this2.app.interactiveCone || object.cones[0];\n\n          object.cones.forEach(function (cone, i) {\n            if (cone === _this2.app.interactiveCone) {\n              cones[i].style.display = 'block';\n              _this2.replaceTextContent(cones[i].getElementsByTagName('h4')[0], 'Cone ' + (i + 1) + ' of ' + object.cones.length);\n              _this2.replaceTextContent(cones[i].querySelector('.lat .value'), cone.lat * 180 / Math.PI, 0);\n              _this2.replaceTextContent(cones[i].querySelector('.long .value'), cone.long * 180 / Math.PI, 0);\n              _this2.replaceTextContent(cones[i].querySelector('.volume .value'), cone.sound.volume.gain.value, 2, true);\n              _this2.replaceTextContent(cones[i].querySelector('.spread .value'), cone.sound.spread, 2, true);\n            } else\n            {\n              cones[i].style.display = 'none';\n            }\n          });})();\n      }\n    }\n\n    // update parameters of sound zone\n  }, { key: 'updateSoundzoneGUI', value: function updateSoundzoneGUI(zone) {\n      var pos = zone.containerObject.position;\n      var x = this.container.querySelector('.x .value');\n      var z = this.container.querySelector('.z .value');\n      var rotation = this.container.querySelector('.rotation .value');\n      var volume = this.container.querySelector('.volume .value');\n      this.replaceTextContent(x, pos.x);\n      this.replaceTextContent(z, pos.z);\n      this.replaceTextContent(rotation, zone.containerObject.rotation.y * 180 / Math.PI);\n      this.replaceTextContent(volume, zone.sound && zone.sound.source ? zone.sound.source.volume.gain.value : 'N/A');\n    }\n\n    // ------------ event callbacks ------------ //\n    // attach a sound to an object\n  }, { key: 'addSound', value: function addSound(e) {\n      var obj = this.obj;\n      var span = e.target;\n      var input = document.getElementById('soundPicker');\n      // listen to click\n      var self = this;\n      input.onchange = function (e) {\n        var file = e.target.files[0];\n        input.parentNode.reset();\n\n        if (file) {\n          var path = 'assets/sounds/' + file.name;\n\n          // load sound onto obect\n          switch (obj.type) {\n            case 'SoundTrajectory':\n              obj = obj.parentSoundObject;\n            case 'SoundObject':\n              // check if sound is attaching to omnisphere or cone\n              if (span.parentNode.id === \"omnisphere-sound-loader\") {\n                obj.loadSound(path, self.app.audio, self.app.isMuted, obj).\n                then(function (sound) {\n                  // check for existing sound\n                  if (obj.omniSphere.sound && obj.omniSphere.sound.volume) {\n                    // copy properties of previous sound\n                    sound.volume.gain.value = obj.omniSphere.sound.volume.gain.value;\n                    sound.panner.refDistance = obj.omniSphere.sound.panner.refDistance;\n                    sound.panner.distanceModel = obj.omniSphere.sound.panner.distanceModel;\n                  }\n                  obj.omniSphere.sound = sound;\n                  obj.omniSphere.sound.name = file.name;\n                  self.replaceTextContent(span, file.name);\n                  obj.setAudioPosition(obj.omniSphere);\n                  span.nextSibling.style.display = 'inline-block';\n                }).\n                catch(function (err) {\n                  // no file was loaded: do nothing\n                  console.log(err);\n                });\n              } else\n              {var\n\n\n                text;(function () {var\n\n\n\n\n\n                  attachCone = function attachCone() {\n                    // create new cone\n                    obj.loadSound(path, self.app.audio, self.app.isMuted, cone).\n                    then(function (sound) {\n                      if (cone) {\n                        // copy properties of previous cone\n                        obj.applySoundToCone(cone, sound);\n                        obj.setAudioPosition(cone);\n\n                        // replace text with file name\n                        cone.filename = file.name;\n                        self.app.interactiveCone = cone;\n                        self.replaceTextContent(span, file.name);\n                      } else\n                      {\n                        cone = obj.createCone(sound);\n                        cone.filename = file.name;\n                        self.addCone(cone);\n                        self.app.interactiveCone = cone;\n\n                        // point cone at camera\n                        obj.pointCone(cone, self.app.camera.threeCamera.position);\n                      }\n                    }).\n                    catch(function (err) {\n                      // no file was loaded: do nothing\n                      console.log(err);\n                    });\n                  };\n\n                  // hard-coded the timeout but create the sound\n                  // after the tween is finished\n                  // replace sound attached to existing cone\n                  text = span.innerText || span.textContent;var cone = null;if (obj.cones && obj.cones.length > 0 && text) {cone = obj.cones.find(function (c) {return c.filename == text;});}if (!cone && !self.app.isEditingObject) {self.toggleEditObject();\n                    window.setTimeout(attachCone, 800);\n                  } else\n                  {\n                    attachCone();\n                  }})();\n\n              }\n              break;\n            case 'SoundZone':\n\n              // add sound to zone\n              obj.loadSound(path, self.app.audio, self.app.isMuted).\n              then(function () {\n                // replace text with file name\n                self.replaceTextContent(span, file.name);\n                span.nextSibling.style.display = 'inline-block';\n              }).\n              catch(function (err) {\n                // no file was loaded: do nothing\n                console.log(err);\n              });\n              break;\n            default:\n              break;}\n\n        }\n      };\n      input.click();\n    } }, { key: 'detachSound', value: function detachSound(\n\n    fileSpan, removeSpan) {\n\n      var self = this;\n\n      fileSpan.innerHTML = 'None';\n      removeSpan.style.display = 'none';\n\n      if (this.obj.type === \"SoundObject\") {\n        if (this.obj.omniSphere.sound && this.obj.omniSphere.sound.source) {\n          this.obj.omniSphere.sound.source.stop();\n          this.obj.omniSphere.sound.source.disconnect(this.obj.omniSphere.sound.scriptNode);\n          this.obj.omniSphere.sound.scriptNode.disconnect(self.app.audio.context.destination);\n          this.obj.omniSphere.material.opacity = 0.8;\n          this.obj.omniSphere.sound = null;\n          this.obj.changeRadius();\n        }\n      }\n      if (this.obj.type === \"SoundZone\") {\n        this.obj.filename = null;\n        this.obj.clear();\n      }\n    }\n\n    // move into/out of object edit mode\n  }, { key: 'toggleEditObject', value: function toggleEditObject() {\n\n      if (!this.app.isEditingObject) {\n        var span = this.container.querySelector('.edit-toggle .value');\n        this.editor = span;\n        this.container.classList.add('editor');\n        this.replaceTextContent(span, 'Exit editor');\n        // Mutes the objects besides the one being edited\n        this.app.muteAll(this.app.activeObject);\n        this.app.enterEditObjectView();\n      } else\n      {\n        this.app.exitEditObjectView();\n      }\n    } }, { key: 'exitEditorGui', value: function exitEditorGui()\n\n    {\n\n      this.app.unmuteAll();\n      var span = this.container.querySelector('.edit-toggle .value');\n      this.editor = null;\n      this.container.classList.remove('editor');\n      this.replaceTextContent(span, 'Edit object');\n    }\n\n    // switch between different cones and objects\n  }, { key: 'nav', value: function nav(e) {\n      if (e.type === 'cone') {\n        var i = this.obj.cones.indexOf(this.app.interactiveCone);\n        if (i > -1) {\n          i = e.direction === 'left' ? i - 1 + this.obj.cones.length : i + 1;\n          this.app.interactiveCone = this.obj.cones[i % this.obj.cones.length];\n        }\n      } else\n      {\n        var everyObject = [].concat(this.app.soundObjects /*, this.app.soundZones*/);\n        var _i = everyObject.indexOf(this.obj);\n        if (_i > -1) {\n          _i = e.direction === 'left' ? _i - 1 + everyObject.length : _i + 1;\n          this.app.setActiveObject(everyObject[_i % everyObject.length]);\n          this.app.tweenToObjectView();\n        }\n      }\n    } }, { key: 'startDragging', value: function startDragging(\n\n    e) {\n      this.app.controls.disable();\n\n      var l = this.listeners.find(function (l) {return l.elem === e.target || l.elem === e.target.parentNode;});\n\n      if (l && l.callback) {\n        this.dragEvent.call = l.callback;\n        this.dragEvent.editing = e.target;\n        this.dragEvent.x = e.x;\n      }\n    } }, { key: 'drag', value: function drag(\n    e) {\n      if (!this.dragEvent.editing) {\n        return;\n      }\n      var dx = e.x == undefined ? e.movementX : e.x - this.dragEvent.x;\n      this.dragEvent.x = e.x;\n      this.dragEvent.call(dx);\n    } }, { key: 'stopDragging', value: function stopDragging(\n    e) {\n      if (!this.dragEvent.editing) {\n        return;\n      }\n\n      this.dragEvent = {};\n      this.app.controls.enable();\n    } }, { key: 'addSwipeEvents', value: function addSwipeEvents(\n\n    div, title, isObject) {\n      // add touch interactions\n      var x = null,\n      y = null,\n      dx = null,\n      dy = null;\n      var controls = this.app.controls;\n      title.onmousedown = function (e) {\n        x = e.clientX;\n        y = e.clientY;\n        controls.disable();\n      };\n\n      div.onmousemove = function (e) {\n        if (x == null || y == null) {return;}\n        dx = e.clientX - x;\n        dy = e.clientY - y;\n        if (Math.abs(dx) > 15) {\n          if (dx > 0) {\n            title.style.marginLeft = Math.min(dx - 10 / 2, 50) + 'px';\n          } else\n          {\n            title.style.marginLeft = Math.max(dx + 10 / 2, -50) + 'px';\n          }\n        } else\n        {\n          title.style.marginLeft = 0;\n        }\n      };\n\n      var self = this;\n\n      div.onmouseup = function () {\n        if (x == null || y == null) {return;}\n        title.style.marginLeft = 0;\n        if (Math.abs(dx) >= 40) {\n          var direction = dx < 0 ? \"left\" : \"right\";\n          var objectType = isObject ? \"object\" : \"cone\";\n          self.nav({ direction: direction, type: objectType });\n        }\n        x = y = dx = dy = null;\n        controls.enable();\n      };\n\n      div.onmouseleave = function (e) {\n        if (x == null || y == null) {return;}\n        if (e.target.parentNode != div) {\n          div.onmouseup();\n        }\n      };\n    }\n    //---------- dom building blocks -----------//\n    // add a new div\n  }, { key: 'addElem', value: function addElem(name, addEditParameter, siblingAfter) {\n      var div = document.createElement('div');\n      var title = document.createElement('h4');\n      title.appendChild(document.createTextNode(name));\n\n      div.appendChild(title);\n      this.container.insertBefore(div, siblingAfter || null);\n\n      if (addEditParameter) {\n        // \"edit object\" dialog\n        this.addParameter({\n          value: this.app.isEditingObject ? 'Exit editor' : 'Edit object',\n          cls: 'edit-toggle',\n          events: [{\n            type: 'click',\n            callback: this.toggleEditObject.bind(this) }] },\n\n        title);\n      }\n\n      if (addEditParameter || siblingAfter) {\n        this.addSwipeEvents(div, title, addEditParameter);\n      }\n      return div;\n    }\n\n    // add a line for the parameter in the UI\n    // parameter p can contain properties:\n    //      property\n    //      value\n    //      cls:     class name for quicker dom access\n    //      type:    number, file, etc?\n    //      suffix:  a string to be appended to the value\n    //      events:  array of event names & callback functions\n  }, { key: 'addParameter', value: function addParameter(p, container) {\n      container = container || this.container;\n\n      var div = document.createElement('div');\n      if (p.cls) {div.className = p.cls;}\n\n      var prop = document.createElement('span');\n      prop.className = 'property';\n      prop.appendChild(document.createTextNode(p.property));\n\n      var val = document.createElement('span');\n      val.className = 'valueSpan';\n\n      if (p.type === 'number') {\n        val.style.cursor = 'ew-resize';\n      }\n\n      if (p.events) {\n        p.events.forEach(function (evt) {\n          if (!evt.target) {\n            val['on' + evt.type] = evt.callback;\n          } else\n          {\n            evt.target.addEventListener(evt.type, evt.callback);\n          }\n        });\n      }\n\n      // shortcut to apply \"startDragging\" mousedown event\n      if (p.bind) {\n        val.onmousedown = this.startDragging.bind(this);\n        this.listeners.push({\n          elem: val,\n          callback: p.bind });\n\n      }\n\n      if (p.suffix) {\n        var span = document.createElement('span');\n        span.className = 'value';\n        span.appendChild(document.createTextNode(p.value));\n        val.appendChild(span);\n        val.appendChild(document.createTextNode(p.suffix));\n      } else\n      {\n        val.appendChild(document.createTextNode(p.value));\n        val.className += ' value';\n      }\n\n\n      // append all values to dom\n      if (p.property != undefined) {div.appendChild(prop);}\n      if (p.value != undefined) {div.appendChild(val);}\n\n      if (p.type == 'file-input') {\n        var removeFile = document.createElement('span');\n        removeFile.appendChild(document.createTextNode('×'));\n        removeFile.className = 'remove-file';\n        div.appendChild(removeFile);\n\n        removeFile.style.display = p.display ? 'inline-block' : 'none';\n        removeFile.onclick = this.detachSound.bind(this, val, removeFile);\n      }\n\n      container.append(div);\n      return div;\n    }\n\n    // updating text in html\n  }, { key: 'replaceTextContent', value: function replaceTextContent(parent, text, sigfigs, float) {\n      // while(parent.firstChild) { parent.removeChild(parent.firstChild); }\n      if (!isNaN(text)) {\n        if (isNaN(sigfigs)) {\n          text = (+text).toFixed(2);\n        } else\n        {\n          text = (+text).toFixed(sigfigs);\n        }\n        if (!float) text = +text;\n      }\n      parent.innerHTML = text;\n      // parent.appendChild(document.createTextNode(text));\n    } }]);return GUIWindow;}();exports.default = GUIWindow;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/app/managers/guiwindow.js\n// module id = 25\n// module chunks = 0\n//# sourceURL=webpack:///./src/js/app/managers/guiwindow.js?");

/***/ }
/******/ ]);