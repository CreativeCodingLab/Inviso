<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Inviso Interaction</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                margin:0px;
            }
        </style>

        <script> var activeObject = null; </script>
        <script src="js/three.min.js"></script>
        <script src="js/simplify3D.js"></script>
        <script src="js/AxisHelper.js"></script>
        <script src="js/OBJLoader.js"></script>
        <script src="js/TrackballControls.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script src="js/Tween.js"></script>
        <script src="js/dat.gui.min.js"></script>

        <script src="SoundTrajectory.js"></script>
        <script src="SoundObject.js"></script>
        <script src="SoundZone.js"></script>
        <link rel="stylesheet" href="css/gui.css">
    </head>

    <body>

        <input id="myInput" type="file" style="visibility:hidden">
        <div id="UIContainer">
          <button id="add-object-button"> + </button>
          <div id="guis"></div>
        </div>

<script>

    var scene, camera, controls, container, renderer;

    var mouse = new THREE.Vector3();
    var nonScaledMouse = new THREE.Vector3();
    var ray = new THREE.Raycaster();
    var walkingRay = new THREE.Raycaster();

    var isMouseDown = false;
    var isAddingTrajectory = false;
    var isAddingObject = false;
    var isAddingObject = false;
    var isEditingObject = false;

    var floor;
    var counter = 1;
    var movementSpeed = 5;
    var increment = 0.01;
    var direction = 1;

    var audio;
    var soundObjects = [];
    var soundTrajectories = [];
    var soundZones = [];

    var axisHelper;
    var loader;
    var headModel;
    var moveForward = 0, moveBackwards = 0;
    var yawLeft = 0, yawRight = 0;
    var rotationSpeed = 0.05;
    var listenerMovementSpeed = 5;

    var perspectiveView = false;
    var keyPressed = false;

    var interactiveCone = null, previousInteractiveCone = null;
    var selectedConeColor, unselectedConeColor;
    var placingCone = false;
    var replacingCone = false;

    var cameraPosition = new THREE.Vector3();

    init();
    render();

    function init() {

      setupAudio();

      container = document.createElement( 'div' );
      document.body.appendChild( container );

      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
      camera.position.set(0, 2500, 0);
      camera.updateProjectionMatrix();

      controls = new THREE.OrbitControls( camera );
      controls.minPolarAngle = -Math.PI/2;
      controls.maxPolarAngle = Math.PI/2;
      controls.enabled = false;

      ray.linePrecision = 10;

      scene = new THREE.Scene();
      scene.add(camera);
      scene.add( new THREE.AmbientLight( 0x909090 ) );

      /*
      Defining the listener functions for the GUI
      (will be obsolete once we brew our own GUI).
      */
      var obj = {

        loadFile : function() {
          document.getElementById("myInput").click();
        },
        addTrajectory : function() {
          toggleAddTrajectory();
        },
        attachSound : function() {

          attachSound();

          /*
          If we are not in the object close-up view, attaching a cone enables
          the edit object mode.
          */
          if(!isEditingObject){
            isEditingObject = true;

            /*
            Lerp between the object's position and the head model's position to
            determine where the camera and the head model, which is attached to the
            listener node, will go.

            The tweening performs the zooming into the object motion.
            */
            cameraPosition.lerpVectors(activeObject.containerObject.position, headModel.position,
            500 / headModel.position.distanceTo(activeObject.containerObject.position));

            var tween = new TWEEN.Tween(camera.position)
            .to(cameraPosition, 800)
            .onComplete(function() {
              headModel.position.copy(cameraPosition);
              headModel.lookAt(activeObject.containerObject.position);
              axisHelper.position.copy(cameraPosition);
              axisHelper.lookAt(activeObject.containerObject.position);})
            .start();

            var tween2 = new TWEEN.Tween(controls.center)
            .to(activeObject.containerObject.position, 800)
            .start();
          }
        },

        /*
        We can also exclusively get into (or get back into) object edit mode.
        Same tweening actions are performed.
        */
        editObject : function() {

          if(!isEditingObject){
            cameraPosition.lerpVectors(activeObject.containerObject.position, headModel.position,
            500 / headModel.position.distanceTo(activeObject.containerObject.position));

            var tween = new TWEEN.Tween(camera.position)
            .to(cameraPosition, 800)
            .onComplete(function() {
              headModel.position.copy(cameraPosition);
              headModel.lookAt(activeObject.containerObject.position);
              axisHelper.position.copy(cameraPosition);
              axisHelper.lookAt(activeObject.containerObject.position);})
            .start();

            var tween2 = new TWEEN.Tween(controls.center)
            .to(activeObject.containerObject.position, 800)
            .start();
          }
          isEditingObject = !isEditingObject;
        }
      };

      /*
      Setting up the GUI.
      */
      var objectGui = new dat.GUI({ autoPlace: false });
      objectGui.width = 250;
      var customContainer = document.getElementById('guis');
      customContainer.appendChild(objectGui.domElement);

      objectGui.add(obj, 'loadFile').name('Load Sound File');
      objectGui.add(obj, 'attachSound').name('Attach Sound');
      objectGui.add(obj, 'addTrajectory').name('Add Trajectory');
      objectGui.add(obj, 'editObject').name('Edit Object');

      guis.style.display = "block";

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setClearColor( 0xf0f0f0 );
      renderer.setSize( window.innerWidth, window.innerHeight );
      renderer.autoClear = false;

      /*
      Setting up the trajectory and zone interfaces. These will return
      us the trajectory and zone instances when we ask for them.
      */
      trajectory.setScene(scene);
      zone.setScene(scene);

      /*
      The X-Z raycasting plane for determining where on the floor
      the user is clicking.
       */
      var geometry = new THREE.PlaneGeometry(5000, 5000);
      var material = new THREE.MeshBasicMaterial( {color: 0xffffff, side: THREE.DoubleSide, visible: false} );
      floor = new THREE.Mesh( geometry, material );
      floor.rotation.x = Math.PI/2;
      scene.add(floor);

      /*
      Setting up the head model (i.e. the visual representation of the listener node),
      and the axis lines attached to it
      */
      axisHelper = new THREE.AxisHelper(60);
      axisHelper.rotation.y += Math.PI;
      scene.add(axisHelper);

      loader = new THREE.OBJLoader();
      loader.load('assets/head.obj', function(object){
        headModel = object;
        headModel.position.y = 1; // necessary for raycasting onto the zone shape

        headModel.rotation.y += Math.PI;
        headModel.scale.set(30, 30, 30);
        scene.add(headModel);
      });

      /* The floor */
      var grid = new THREE.GridHelper( 5000, 100 );
      grid.position.y = -300;
      grid.material.opacity = 0.25;
      grid.material.transparent = true;
      scene.add( grid );

      /*
      Setting up some lights.
      FEATURE REQUEST: Shadows of objects cast on the floor.
      */
      var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
      dirLight.color.setHSL( 0.1, 1, 0.95 );
      dirLight.position.set( -1, 1.75, 1 );
      dirLight.position.multiplyScalar( 50 );
      scene.add( dirLight );

      unselectedConeColor = new THREE.Color(0x80FFE7);
      selectedConeColor = new THREE.Color(0xFFCCCC);

      container.appendChild( renderer.domElement );
      container.addEventListener( 'mousedown', onMouseDown, false );
      container.addEventListener( 'mouseup', onMouseUp, false );
      container.addEventListener( 'mouseleave', onMouseUp, false );
      container.addEventListener( 'mousemove', onMouseMove, false );
      document.body.addEventListener( 'keydown', onKeyDown, false);
      document.body.addEventListener( 'keyup', onKeyUp, false);

      document.querySelector('#add-object-button').onclick = toggleAddObject.bind(this);
      window.addEventListener( 'resize', onWindowResize, false );
    }

    /*
    Initi function to setup up the audio conext, and initial position of listener node.
    */
    function setupAudio(){

      var a = {};
      audio = a;

      window.AudioContext = window.AudioContext || window.webkitAudioContext;

      a.context = new AudioContext();
      a.context.listener.setOrientation(0,0,-1,0,1,0);
      a.context.listener.setPosition(0, 0, 1);
      a.destination = a.context.createGain();
      a.destination.connect(a.context.destination);
    }

    /*
    Function for updating the listener node's position whenever the
    head model's position is altered. The model object is passed in as a
    parameter.
    */
    function setListenerPosition(object) {

      var q = new THREE.Vector3();
      object.updateMatrixWorld();
      q.setFromMatrixPosition(object.matrixWorld);
      /* This sets the listener node position. */
      audio.context.listener.setPosition(q.x, q.y, q.z);

      var m = object.matrix;
      var mx = m.elements[12], my = m.elements[13], mz = m.elements[14];
      m.elements[12] = m.elements[13] = m.elements[14] = 0;

      var vec = new THREE.Vector3(0,0,-1);
      vec.applyProjection(m);
      vec.normalize();

      var up = new THREE.Vector3(0,-1,0);
      up.applyProjection(m);
      up.normalize();

      /* This sets the listener node orientation. */
      audio.context.listener.setOrientation(vec.x, vec.y, vec.z, up.x, up.y, up.z);

      m.elements[12] = mx;
      m.elements[13] = my;
      m.elements[14] = mz;
    }

    function render() {

      /* Stops an object trajectory motion if the used clicks onto a moving object */
      for(var i in soundObjects){
        if( !isMouseDown || soundObjects[i] != activeObject) {
          if( soundObjects[i].type === 'SoundObject') soundObjects[i].followTrajectory();
        }
      }

      /* Camera tweening object update */
      TWEEN.update();

      /*
      Differentiating between perspective and bird's-eye views. If the camera is tilted
      enough the perspective view is activated, restring user's placement of object in the
      X-Z plane
      */
      if( controls.getPolarAngle() > 0.4 ) perspectiveView = true; else perspectiveView = false;

      /* Updating camera controls. */
      controls.update();
      /* CHecking if the user has waled into a sound zone in each frame. */
      checkZones();
      /* Updating the head model's position and orientation in each frame. */
      updateDummyHead();
      requestAnimationFrame( this.render.bind(this) );

      renderer.clear();
      renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );
      renderer.render( scene, camera );

      /* Making the GUI visible if an object is selected */
      if ( activeObject ) document.getElementById('guis').style.display = 'block';
      else document.getElementById('guis').style.display = 'none';
    }

    /*
    Checks if the user has walked into a sound zone by raycasting from the
    head model's position onto each sound zone into scene and checking if there
    is a hit.
    */
    function checkZones() {

      if( soundZones.length > 0 ){

        var walkingRayVector = new THREE.Vector3(0, -1, 0);
        walkingRay.set(headModel.position, walkingRayVector);

        for(var i in soundZones){
          var intersects = walkingRay.intersectObject( soundZones[i].shape );
          if(intersects.length > 0) {
            /*
            Flagging a zone "under user" to activate the audio file associated
            with the sound zone.
            */
            soundZones[i].underUser();
          }
          else {
            soundZones[i].notUnderUser();
          }
        }
      }
    }

    /*
    Function for attaching an already loaded sound file to an object in
    the scene. Once there is a loaded sound, it will be attached to any object
    until a new sound file is loaded.
    */
    function attachSound() {

      var x = document.getElementById("myInput");
      if( activeObject.type === 'SoundObject' ){ activeObject.createCone('assets/' + x.files[0].name); }
      if( activeObject.type === 'SoundZone' ){ activeObject.loadSound('assets/' + x.files[0].name); }
      if( activeObject.type === 'SoundTrajectory' ) activeObject.parentSoundObject.createCone('assets/' + x.files[0].name);
    }

    /*
    Sets the trajectory adding state on. If the scene is in perspective view when
    this is called, it will be reset to bird's eye.
    */
    function toggleAddTrajectory() {

      if(perspectiveView) controls.reset();
      isAddingTrajectory = !isAddingTrajectory;
    }

    /*
    Sets the object adding state on. If the scene is in perspective view when
    this is called, it will be reset to bird's eye.
    */
    function toggleAddObject() {

      if(perspectiveView) controls.reset();
      isAddingObject = !isAddingObject;
    }

    /*
    Sets the the last clicked (active) object.
    Calls a "secActive()" function ob the selected object.
    */
    function setActiveObject(obj) {

      if (activeObject) {
        activeObject.setInactive();
      }
      activeObject = obj;

      if (obj) {
        obj.setActive();
      }
    }

    /* Updates the head model's position and orientation in each frame. */
    function updateDummyHead(){

      if(headModel){
        axisHelper.rotation.y += - yawLeft + yawRight;
        headModel.rotation.y += - yawLeft + yawRight;
        axisHelper.translateZ( - moveBackwards + moveForward);
        headModel.translateZ( - moveBackwards + moveForward);
        setListenerPosition(headModel);
      }
    }

    /*
    USER INTERACTION FUNCTIONS:
    - mouse down
    - mouse up
    - mouse move
    - key down
    - key up
    */

    /*
    Calculates a normalized mouse position based on the raycasting
    to the floor.
    nonScaledMouse: mouse posiiton in pixels
    mouse: raycast hit position
    */
    function setMousePosition(event) {

      var pointer = new THREE.Vector3();
      pointer.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);

      nonScaledMouse = pointer;

      ray.setFromCamera( pointer, camera );

      var intersects = ray.intersectObject( floor );
      if(intersects.length > 0) {
        mouse = intersects[0].point;
      }
    }

    /* Evenet listenr for mouse click downs */
    function onMouseDown(e) {

      /*
      !keyPressed is added to avoid interaction with object when the camera
      is being rotated. It can (should) be changed into a flag more specific
      to this action.
      */
      if( !keyPressed ){

        isMouseDown = true;

        /*
        Create a collection array of all the object in the scene and check if
        any of these objects isUnderMouse (a function which is passed our raycaster).

        If there is indeed an intersected object, set it as the activeObject.
        */
        var everyComponent = [].concat(soundObjects, soundZones, soundTrajectories);

        var intersectObjects = everyComponent.filter(function(obj) {
            return obj.isUnderMouse(ray);
        });

        if( everyComponent.length > 0 ) setActiveObject(intersectObjects[0]);
        else setActiveObject(null);

        /*
        If adding a trajectory, ask the trajectory interface to initate a new
        trajectory at the mouse position determined in setMousePosition()

        Same for the zone.
        */
        if (isAddingTrajectory) {
          mouse.y = activeObject.containerObject.position.y;
          trajectory.beginAt(mouse);
        }

        if (isAddingObject) {
          zone.beginAt(mouse);
        }

        /* If the most recent active object interacted with again, select it: */
        if (activeObject && activeObject.isUnderMouse(ray)) {
            // click inside active object
          if ( activeObject.type != 'SoundObject'){
            var intersect = activeObject.objectUnderMouse(ray);
            activeObject.select(intersect);
          }else{
            activeObject.select();
          }
        }

        /*
        In object edit mode a different interaction scheme is followed.
        */
        if ( isEditingObject ){

          var intersects = ray.intersectObjects(activeObject.containerObject.children);

        	if (intersects.length > 0) {

        		var intersect = intersects[0];

        		switch(intersect.object.name){

        			case "cone":

        				previousInteractiveCone = interactiveCone;
        				if(interactiveCone == intersect.object.id - activeObject.cones[0].id){
        					placingCone = false;
        					interactiveCone = null;
        				}
        				else{
        					interactiveCone = intersect.object.id - activeObject.cones[0].id;
        					replacingCone = true;
        				}
        			break;

        			case "visibleSphere":

        				replacingCone = false;
        			break;
        		}
          }else{

        		previousInteractiveCone = interactiveCone;
        		placingCone = false;
        		replacingCone = false;
        		interactiveCone = null;
        	}

        	if(previousInteractiveCone !== null) activeObject.cones[previousInteractiveCone].material.color = new THREE.Color(unselectedConeColor);
        	if(interactiveCone !== null) activeObject.cones[interactiveCone].material.color = new THREE.Color(selectedConeColor);
        }

      }

    }

    function onMouseUp(e) {

      var obj;

      if (isAddingTrajectory) {
        obj = trajectory.createObject();
        activeObject.trajectory = obj;
        obj.parentSoundObject = activeObject;
        if (obj && obj.type === 'SoundTrajectory') {
          soundTrajectories.push(obj);
        }
        toggleAddTrajectory();
        isAddingTrajectory = false;
      }

      if (isAddingObject) {
        obj = zone.createObject();
        if (obj && obj.type === 'SoundZone') {
          soundZones.push(obj);
        }
        if (obj && obj.type === 'SoundObject') {
          soundObjects.push(obj);
        }

        setActiveObject(obj);
        toggleAddObject();
        isAddingObject = false;
      }

      isMouseDown = false;

      for( var i in soundObjects ){
        if( soundObjects[i].type === 'SoundObject') soundObjects[i].calculateMovementSpeed();
      }
    }

    function onMouseMove(e) {

      setMousePosition(e);
      if (isMouseDown === true && !isEditingObject) {
        if( activeObject ){
          activeObject.move();
        }

        if (isAddingTrajectory === true) {
          if (activeObject.type === 'SoundObject') {
            mouse.y = activeObject.containerObject.position.y;
            trajectory.addPoint(mouse);
          }
        }

        if (isAddingObject === true) {
          zone.addPoint(mouse);
        }

        if (activeObject && activeObject.type === 'SoundTrajectory') {
            var intersection = activeObject.objectUnderMouse(ray);

            if (isMouseDown === true) {
                // click+drag
                activeObject.move(mouse);
            }
            else {
                // hover cursor over line

                if (intersection && intersection.object.type === 'Line') {
                    activeObject.showCursor();
                    activeObject.setCursor(intersection.point);
                }
                else if (intersection && intersection.object.parent.type === 'Object3D') {
                    activeObject.showCursor();
                    activeObject.setCursor(intersection.object.parent.position);

                }
                else {
                    activeObject.showCursor(false);
                }
            }
          }
      }

      if(isEditingObject){

        var intersects = ray.intersectObject(activeObject.raycastSphere);
        var intersect = intersects[0];

        if (intersects.length > 0 && placingCone){
          activeObject.cones[interactiveCone].lookAt(intersect.point);
          setPosition(activeObject.cones[interactiveCone]);
        }else if(isMouseDown){
          if(intersects.length > 0 && replacingCone){

            var coneRotation = new THREE.Vector3();
            coneRotation.subVectors(intersect.point, activeObject.containerObject.position);
            activeObject.cones[interactiveCone].lookAt(coneRotation);
            activeObject.setAudioPosition(activeObject.cones[interactiveCone]);
          }
        }
      }
    }

    function onKeyDown(e) {

      keyPressed = true;

      var key = e.keyCode || e.which;
      switch(key) {
        case 87: moveForward = 1 * movementSpeed; break; //W
        case 83: moveBackwards = 1 * movementSpeed; break; //S
        case 68: yawLeft = 1 * rotationSpeed; break; // D
        case 65: yawRight = 1 * rotationSpeed; break; // A
        case 67: controls.enabled = true; break; // C

        case 8: case 46:    // Backspace & Delete
          e.preventDefault();
          if (activeObject && activeObject.type === 'SoundTrajectory') {

            if (activeObject.selectedPoint && activeObject.splinePoints.length > 3) {
              activeObject.removePoint();
            }
          }

          if (activeObject && activeObject.type === 'SoundZone') {

            if (activeObject.selectedPoint && activeObject.splinePoints.length > 3) {
              activeObject.removePoint();
            }
            else {
              removeSoundZone(activeObject);
              activeObject = null;
            }
          }

          if (activeObject && activeObject.type === 'SoundObject') {
            removeSoundObject(activeObject);
            removeSoundTrajectory(activeObject.trajectory);
            activeObject = null;
          }
        break;
      }
    }

    function onKeyUp(e) {

      keyPressed = false;

      var key = e.keyCode || e.which;
      switch(key) {
        case 87: moveForward = 0; break; //W
        case 83: moveBackwards = 0; break; //S
        case 68: yawLeft = 0; break; // D
        case 65: yawRight = 0; break; // A
        case 67: controls.enabled = false; break; // C
        case 82: controls.reset(); if( isEditingObject ) isEditingObject = false; break; // R
      }
    }

    function removeSoundZone (soundZone) {
      var i = soundZones.indexOf(soundZone);
      soundZones[i].notUnderUser();
      soundZone.removeFromScene(scene);
      soundZones.splice(i,1);
    }

    function removeSoundObject (soundObject) {
      soundObject.removeFromScene(scene);
      var i = soundObjects.indexOf(soundObject);
      soundObjects.splice(i,1);
    }

    function removeSoundTrajectory (soundTrajectory) {
      soundTrajectory.removeFromScene(scene);
      var i = soundTrajectories.indexOf(soundTrajectory);
      soundTrajectories.splice(i,1);
    }

    function onWindowResize(){

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

</script>
</body>
</html>
